// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/extensions/filters/http/ext_authz/v3/ext_authz.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Extensions.Filters.Http.ExtAuthz.V3 {

  /// <summary>Holder for reflection information generated from envoy/extensions/filters/http/ext_authz/v3/ext_authz.proto</summary>
  public static partial class ExtAuthzReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/extensions/filters/http/ext_authz/v3/ext_authz.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ExtAuthzReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjplbnZveS9leHRlbnNpb25zL2ZpbHRlcnMvaHR0cC9leHRfYXV0aHovdjMv",
            "ZXh0X2F1dGh6LnByb3RvEiplbnZveS5leHRlbnNpb25zLmZpbHRlcnMuaHR0",
            "cC5leHRfYXV0aHoudjMaH2Vudm95L2NvbmZpZy9jb3JlL3YzL2Jhc2UucHJv",
            "dG8aKGVudm95L2NvbmZpZy9jb3JlL3YzL2NvbmZpZ19zb3VyY2UucHJvdG8a",
            "J2Vudm95L2NvbmZpZy9jb3JlL3YzL2dycGNfc2VydmljZS5wcm90bxojZW52",
            "b3kvY29uZmlnL2NvcmUvdjMvaHR0cF91cmkucHJvdG8aJGVudm95L3R5cGUv",
            "bWF0Y2hlci92My9tZXRhZGF0YS5wcm90bxoiZW52b3kvdHlwZS9tYXRjaGVy",
            "L3YzL3N0cmluZy5wcm90bxofZW52b3kvdHlwZS92My9odHRwX3N0YXR1cy5w",
            "cm90bxogdWRwYS9hbm5vdGF0aW9ucy9zZW5zaXRpdmUucHJvdG8aHXVkcGEv",
            "YW5ub3RhdGlvbnMvc3RhdHVzLnByb3RvGiF1ZHBhL2Fubm90YXRpb25zL3Zl",
            "cnNpb25pbmcucHJvdG8aF3ZhbGlkYXRlL3ZhbGlkYXRlLnByb3RvIs4GCghF",
            "eHRBdXRoehI5CgxncnBjX3NlcnZpY2UYASABKAsyIS5lbnZveS5jb25maWcu",
            "Y29yZS52My5HcnBjU2VydmljZUgAEk8KDGh0dHBfc2VydmljZRgDIAEoCzI3",
            "LmVudm95LmV4dGVuc2lvbnMuZmlsdGVycy5odHRwLmV4dF9hdXRoei52My5I",
            "dHRwU2VydmljZUgAEkkKFXRyYW5zcG9ydF9hcGlfdmVyc2lvbhgMIAEoDjIg",
            "LmVudm95LmNvbmZpZy5jb3JlLnYzLkFwaVZlcnNpb25CCPpCBYIBAhABEhoK",
            "EmZhaWx1cmVfbW9kZV9hbGxvdxgCIAEoCBJVChF3aXRoX3JlcXVlc3RfYm9k",
            "eRgFIAEoCzI6LmVudm95LmV4dGVuc2lvbnMuZmlsdGVycy5odHRwLmV4dF9h",
            "dXRoei52My5CdWZmZXJTZXR0aW5ncxIZChFjbGVhcl9yb3V0ZV9jYWNoZRgG",
            "IAEoCBIyCg9zdGF0dXNfb25fZXJyb3IYByABKAsyGS5lbnZveS50eXBlLnYz",
            "Lkh0dHBTdGF0dXMSIwobbWV0YWRhdGFfY29udGV4dF9uYW1lc3BhY2VzGAgg",
            "AygJEkYKDmZpbHRlcl9lbmFibGVkGAkgASgLMi4uZW52b3kuY29uZmlnLmNv",
            "cmUudjMuUnVudGltZUZyYWN0aW9uYWxQZXJjZW50EkcKF2ZpbHRlcl9lbmFi",
            "bGVkX21ldGFkYXRhGA4gASgLMiYuZW52b3kudHlwZS5tYXRjaGVyLnYzLk1l",
            "dGFkYXRhTWF0Y2hlchJBCg9kZW55X2F0X2Rpc2FibGUYCyABKAsyKC5lbnZv",
            "eS5jb25maWcuY29yZS52My5SdW50aW1lRmVhdHVyZUZsYWcSIAoYaW5jbHVk",
            "ZV9wZWVyX2NlcnRpZmljYXRlGAogASgIEhMKC3N0YXRfcHJlZml4GA0gASgJ",
            "EiUKHWJvb3RzdHJhcF9tZXRhZGF0YV9sYWJlbHNfa2V5GA8gASgJOjWaxYge",
            "MAouZW52b3kuY29uZmlnLmZpbHRlci5odHRwLmV4dF9hdXRoei52Mi5FeHRB",
            "dXRoekIKCghzZXJ2aWNlc0oECAQQBVIJdXNlX2FscGhhIqcBCg5CdWZmZXJT",
            "ZXR0aW5ncxIiChFtYXhfcmVxdWVzdF9ieXRlcxgBIAEoDUIH+kIEKgIgABId",
            "ChVhbGxvd19wYXJ0aWFsX21lc3NhZ2UYAiABKAgSFQoNcGFja19hc19ieXRl",
            "cxgDIAEoCDo7msWIHjYKNGVudm95LmNvbmZpZy5maWx0ZXIuaHR0cC5leHRf",
            "YXV0aHoudjIuQnVmZmVyU2V0dGluZ3Mi6wIKC0h0dHBTZXJ2aWNlEjEKCnNl",
            "cnZlcl91cmkYASABKAsyHS5lbnZveS5jb25maWcuY29yZS52My5IdHRwVXJp",
            "EhMKC3BhdGhfcHJlZml4GAIgASgJEl8KFWF1dGhvcml6YXRpb25fcmVxdWVz",
            "dBgHIAEoCzJALmVudm95LmV4dGVuc2lvbnMuZmlsdGVycy5odHRwLmV4dF9h",
            "dXRoei52My5BdXRob3JpemF0aW9uUmVxdWVzdBJhChZhdXRob3JpemF0aW9u",
            "X3Jlc3BvbnNlGAggASgLMkEuZW52b3kuZXh0ZW5zaW9ucy5maWx0ZXJzLmh0",
            "dHAuZXh0X2F1dGh6LnYzLkF1dGhvcml6YXRpb25SZXNwb25zZTo4msWIHjMK",
            "MWVudm95LmNvbmZpZy5maWx0ZXIuaHR0cC5leHRfYXV0aHoudjIuSHR0cFNl",
            "cnZpY2VKBAgDEARKBAgEEAVKBAgFEAZKBAgGEAci1wEKFEF1dGhvcml6YXRp",
            "b25SZXF1ZXN0EkEKD2FsbG93ZWRfaGVhZGVycxgBIAEoCzIoLmVudm95LnR5",
            "cGUubWF0Y2hlci52My5MaXN0U3RyaW5nTWF0Y2hlchI5Cg5oZWFkZXJzX3Rv",
            "X2FkZBgCIAMoCzIhLmVudm95LmNvbmZpZy5jb3JlLnYzLkhlYWRlclZhbHVl",
            "OkGaxYgePAo6ZW52b3kuY29uZmlnLmZpbHRlci5odHRwLmV4dF9hdXRoei52",
            "Mi5BdXRob3JpemF0aW9uUmVxdWVzdCLtAwoVQXV0aG9yaXphdGlvblJlc3Bv",
            "bnNlEkoKGGFsbG93ZWRfdXBzdHJlYW1faGVhZGVycxgBIAEoCzIoLmVudm95",
            "LnR5cGUubWF0Y2hlci52My5MaXN0U3RyaW5nTWF0Y2hlchJUCiJhbGxvd2Vk",
            "X3Vwc3RyZWFtX2hlYWRlcnNfdG9fYXBwZW5kGAMgASgLMiguZW52b3kudHlw",
            "ZS5tYXRjaGVyLnYzLkxpc3RTdHJpbmdNYXRjaGVyEkgKFmFsbG93ZWRfY2xp",
            "ZW50X2hlYWRlcnMYAiABKAsyKC5lbnZveS50eXBlLm1hdGNoZXIudjMuTGlz",
            "dFN0cmluZ01hdGNoZXISUwohYWxsb3dlZF9jbGllbnRfaGVhZGVyc19vbl9z",
            "dWNjZXNzGAQgASgLMiguZW52b3kudHlwZS5tYXRjaGVyLnYzLkxpc3RTdHJp",
            "bmdNYXRjaGVyEk8KHWR5bmFtaWNfbWV0YWRhdGFfZnJvbV9oZWFkZXJzGAUg",
            "ASgLMiguZW52b3kudHlwZS5tYXRjaGVyLnYzLkxpc3RTdHJpbmdNYXRjaGVy",
            "OkKaxYgePQo7ZW52b3kuY29uZmlnLmZpbHRlci5odHRwLmV4dF9hdXRoei52",
            "Mi5BdXRob3JpemF0aW9uUmVzcG9uc2Ui3gEKEEV4dEF1dGh6UGVyUm91dGUS",
            "GwoIZGlzYWJsZWQYASABKAhCB/pCBGoCCAFIABJdCg5jaGVja19zZXR0aW5n",
            "cxgCIAEoCzI5LmVudm95LmV4dGVuc2lvbnMuZmlsdGVycy5odHRwLmV4dF9h",
            "dXRoei52My5DaGVja1NldHRpbmdzQgj6QgWKAQIQAUgAOj2axYgeOAo2ZW52",
            "b3kuY29uZmlnLmZpbHRlci5odHRwLmV4dF9hdXRoei52Mi5FeHRBdXRoelBl",
            "clJvdXRlQg8KCG92ZXJyaWRlEgP4QgEiowIKDUNoZWNrU2V0dGluZ3MSdAoS",
            "Y29udGV4dF9leHRlbnNpb25zGAEgAygLMlAuZW52b3kuZXh0ZW5zaW9ucy5m",
            "aWx0ZXJzLmh0dHAuZXh0X2F1dGh6LnYzLkNoZWNrU2V0dGluZ3MuQ29udGV4",
            "dEV4dGVuc2lvbnNFbnRyeUIGuLeLpAIBEiYKHmRpc2FibGVfcmVxdWVzdF9i",
            "b2R5X2J1ZmZlcmluZxgCIAEoCBo4ChZDb250ZXh0RXh0ZW5zaW9uc0VudHJ5",
            "EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAE6OprFiB41CjNlbnZv",
            "eS5jb25maWcuZmlsdGVyLmh0dHAuZXh0X2F1dGh6LnYyLkNoZWNrU2V0dGlu",
            "Z3NCUwo4aW8uZW52b3lwcm94eS5lbnZveS5leHRlbnNpb25zLmZpbHRlcnMu",
            "aHR0cC5leHRfYXV0aHoudjNCDUV4dEF1dGh6UHJvdG9QAbqAyNEGAhACYgZw",
            "cm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Core.V3.BaseReflection.Descriptor, global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor, global::Envoy.Config.Core.V3.GrpcServiceReflection.Descriptor, global::Envoy.Config.Core.V3.HttpUriReflection.Descriptor, global::Envoy.Type.Matcher.V3.MetadataReflection.Descriptor, global::Envoy.Type.Matcher.V3.StringReflection.Descriptor, global::Envoy.Type.V3.HttpStatusReflection.Descriptor, global::Udpa.Annotations.SensitiveReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.ExtAuthz), global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.ExtAuthz.Parser, new[]{ "GrpcService", "HttpService", "TransportApiVersion", "FailureModeAllow", "WithRequestBody", "ClearRouteCache", "StatusOnError", "MetadataContextNamespaces", "FilterEnabled", "FilterEnabledMetadata", "DenyAtDisable", "IncludePeerCertificate", "StatPrefix", "BootstrapMetadataLabelsKey" }, new[]{ "Services" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.BufferSettings), global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.BufferSettings.Parser, new[]{ "MaxRequestBytes", "AllowPartialMessage", "PackAsBytes" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.HttpService), global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.HttpService.Parser, new[]{ "ServerUri", "PathPrefix", "AuthorizationRequest", "AuthorizationResponse" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.AuthorizationRequest), global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.AuthorizationRequest.Parser, new[]{ "AllowedHeaders", "HeadersToAdd" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.AuthorizationResponse), global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.AuthorizationResponse.Parser, new[]{ "AllowedUpstreamHeaders", "AllowedUpstreamHeadersToAppend", "AllowedClientHeaders", "AllowedClientHeadersOnSuccess", "DynamicMetadataFromHeaders" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.ExtAuthzPerRoute), global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.ExtAuthzPerRoute.Parser, new[]{ "Disabled", "CheckSettings" }, new[]{ "Override" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.CheckSettings), global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.CheckSettings.Parser, new[]{ "ContextExtensions", "DisableRequestBodyBuffering" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, })
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// [#next-free-field: 16]
  /// </summary>
  public sealed partial class ExtAuthz : pb::IMessage<ExtAuthz>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ExtAuthz> _parser = new pb::MessageParser<ExtAuthz>(() => new ExtAuthz());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ExtAuthz> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.ExtAuthzReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExtAuthz() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExtAuthz(ExtAuthz other) : this() {
      transportApiVersion_ = other.transportApiVersion_;
      failureModeAllow_ = other.failureModeAllow_;
      withRequestBody_ = other.withRequestBody_ != null ? other.withRequestBody_.Clone() : null;
      clearRouteCache_ = other.clearRouteCache_;
      statusOnError_ = other.statusOnError_ != null ? other.statusOnError_.Clone() : null;
      metadataContextNamespaces_ = other.metadataContextNamespaces_.Clone();
      filterEnabled_ = other.filterEnabled_ != null ? other.filterEnabled_.Clone() : null;
      filterEnabledMetadata_ = other.filterEnabledMetadata_ != null ? other.filterEnabledMetadata_.Clone() : null;
      denyAtDisable_ = other.denyAtDisable_ != null ? other.denyAtDisable_.Clone() : null;
      includePeerCertificate_ = other.includePeerCertificate_;
      statPrefix_ = other.statPrefix_;
      bootstrapMetadataLabelsKey_ = other.bootstrapMetadataLabelsKey_;
      switch (other.ServicesCase) {
        case ServicesOneofCase.GrpcService:
          GrpcService = other.GrpcService.Clone();
          break;
        case ServicesOneofCase.HttpService:
          HttpService = other.HttpService.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExtAuthz Clone() {
      return new ExtAuthz(this);
    }

    /// <summary>Field number for the "grpc_service" field.</summary>
    public const int GrpcServiceFieldNumber = 1;
    /// <summary>
    /// gRPC service configuration (default timeout: 200ms).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.GrpcService GrpcService {
      get { return servicesCase_ == ServicesOneofCase.GrpcService ? (global::Envoy.Config.Core.V3.GrpcService) services_ : null; }
      set {
        services_ = value;
        servicesCase_ = value == null ? ServicesOneofCase.None : ServicesOneofCase.GrpcService;
      }
    }

    /// <summary>Field number for the "http_service" field.</summary>
    public const int HttpServiceFieldNumber = 3;
    /// <summary>
    /// HTTP service configuration (default timeout: 200ms).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.HttpService HttpService {
      get { return servicesCase_ == ServicesOneofCase.HttpService ? (global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.HttpService) services_ : null; }
      set {
        services_ = value;
        servicesCase_ = value == null ? ServicesOneofCase.None : ServicesOneofCase.HttpService;
      }
    }

    /// <summary>Field number for the "transport_api_version" field.</summary>
    public const int TransportApiVersionFieldNumber = 12;
    private global::Envoy.Config.Core.V3.ApiVersion transportApiVersion_ = global::Envoy.Config.Core.V3.ApiVersion.Auto;
    /// <summary>
    /// API version for ext_authz transport protocol. This describes the ext_authz gRPC endpoint and
    /// version of messages used on the wire.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ApiVersion TransportApiVersion {
      get { return transportApiVersion_; }
      set {
        transportApiVersion_ = value;
      }
    }

    /// <summary>Field number for the "failure_mode_allow" field.</summary>
    public const int FailureModeAllowFieldNumber = 2;
    private bool failureModeAllow_;
    /// <summary>
    ///  Changes filter's behaviour on errors:
    ///
    ///  1. When set to true, the filter will *accept* client request even if the communication with
    ///  the authorization service has failed, or if the authorization service has returned a HTTP 5xx
    ///  error.
    ///
    ///  2. When set to false, ext-authz will *reject* client requests and return a *Forbidden*
    ///  response if the communication with the authorization service has failed, or if the
    ///  authorization service has returned a HTTP 5xx error.
    ///
    /// Note that errors can be *always* tracked in the :ref:`stats
    /// &lt;config_http_filters_ext_authz_stats>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FailureModeAllow {
      get { return failureModeAllow_; }
      set {
        failureModeAllow_ = value;
      }
    }

    /// <summary>Field number for the "with_request_body" field.</summary>
    public const int WithRequestBodyFieldNumber = 5;
    private global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.BufferSettings withRequestBody_;
    /// <summary>
    /// Enables filter to buffer the client request body and send it within the authorization request.
    /// A ``x-envoy-auth-partial-body: false|true`` metadata header will be added to the authorization
    /// request message indicating if the body data is partial.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.BufferSettings WithRequestBody {
      get { return withRequestBody_; }
      set {
        withRequestBody_ = value;
      }
    }

    /// <summary>Field number for the "clear_route_cache" field.</summary>
    public const int ClearRouteCacheFieldNumber = 6;
    private bool clearRouteCache_;
    /// <summary>
    /// Clears route cache in order to allow the external authorization service to correctly affect
    /// routing decisions. Filter clears all cached routes when:
    ///
    /// 1. The field is set to *true*.
    ///
    /// 2. The status returned from the authorization service is a HTTP 200 or gRPC 0.
    ///
    /// 3. At least one *authorization response header* is added to the client request, or is used for
    /// altering another client request header.
    ///
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ClearRouteCache {
      get { return clearRouteCache_; }
      set {
        clearRouteCache_ = value;
      }
    }

    /// <summary>Field number for the "status_on_error" field.</summary>
    public const int StatusOnErrorFieldNumber = 7;
    private global::Envoy.Type.V3.HttpStatus statusOnError_;
    /// <summary>
    /// Sets the HTTP status that is returned to the client when there is a network error between the
    /// filter and the authorization server. The default status is HTTP 403 Forbidden.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.V3.HttpStatus StatusOnError {
      get { return statusOnError_; }
      set {
        statusOnError_ = value;
      }
    }

    /// <summary>Field number for the "metadata_context_namespaces" field.</summary>
    public const int MetadataContextNamespacesFieldNumber = 8;
    private static readonly pb::FieldCodec<string> _repeated_metadataContextNamespaces_codec
        = pb::FieldCodec.ForString(66);
    private readonly pbc::RepeatedField<string> metadataContextNamespaces_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies a list of metadata namespaces whose values, if present, will be passed to the
    /// ext_authz service as an opaque *protobuf::Struct*.
    ///
    /// For example, if the *jwt_authn* filter is used and :ref:`payload_in_metadata
    /// &lt;envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.payload_in_metadata>` is set,
    /// then the following will pass the jwt payload to the authorization server.
    ///
    /// .. code-block:: yaml
    ///
    ///    metadata_context_namespaces:
    ///    - envoy.filters.http.jwt_authn
    ///
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> MetadataContextNamespaces {
      get { return metadataContextNamespaces_; }
    }

    /// <summary>Field number for the "filter_enabled" field.</summary>
    public const int FilterEnabledFieldNumber = 9;
    private global::Envoy.Config.Core.V3.RuntimeFractionalPercent filterEnabled_;
    /// <summary>
    /// Specifies if the filter is enabled.
    ///
    /// If :ref:`runtime_key &lt;envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is specified,
    /// Envoy will lookup the runtime key to get the percentage of requests to filter.
    ///
    /// If this field is not specified, the filter will be enabled for all requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.RuntimeFractionalPercent FilterEnabled {
      get { return filterEnabled_; }
      set {
        filterEnabled_ = value;
      }
    }

    /// <summary>Field number for the "filter_enabled_metadata" field.</summary>
    public const int FilterEnabledMetadataFieldNumber = 14;
    private global::Envoy.Type.Matcher.V3.MetadataMatcher filterEnabledMetadata_;
    /// <summary>
    /// Specifies if the filter is enabled with metadata matcher.
    /// If this field is not specified, the filter will be enabled for all requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.MetadataMatcher FilterEnabledMetadata {
      get { return filterEnabledMetadata_; }
      set {
        filterEnabledMetadata_ = value;
      }
    }

    /// <summary>Field number for the "deny_at_disable" field.</summary>
    public const int DenyAtDisableFieldNumber = 11;
    private global::Envoy.Config.Core.V3.RuntimeFeatureFlag denyAtDisable_;
    /// <summary>
    /// Specifies whether to deny the requests, when the filter is disabled.
    /// If :ref:`runtime_key &lt;envoy_v3_api_field_config.core.v3.RuntimeFeatureFlag.runtime_key>` is specified,
    /// Envoy will lookup the runtime key to determine whether to deny request for
    /// filter protected path at filter disabling. If filter is disabled in
    /// typed_per_filter_config for the path, requests will not be denied.
    ///
    /// If this field is not specified, all requests will be allowed when disabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.RuntimeFeatureFlag DenyAtDisable {
      get { return denyAtDisable_; }
      set {
        denyAtDisable_ = value;
      }
    }

    /// <summary>Field number for the "include_peer_certificate" field.</summary>
    public const int IncludePeerCertificateFieldNumber = 10;
    private bool includePeerCertificate_;
    /// <summary>
    /// Specifies if the peer certificate is sent to the external service.
    ///
    /// When this field is true, Envoy will include the peer X.509 certificate, if available, in the
    /// :ref:`certificate&lt;envoy_v3_api_field_service.auth.v3.AttributeContext.Peer.certificate>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IncludePeerCertificate {
      get { return includePeerCertificate_; }
      set {
        includePeerCertificate_ = value;
      }
    }

    /// <summary>Field number for the "stat_prefix" field.</summary>
    public const int StatPrefixFieldNumber = 13;
    private string statPrefix_ = "";
    /// <summary>
    /// Optional additional prefix to use when emitting statistics. This allows to distinguish
    /// emitted statistics between configured *ext_authz* filters in an HTTP filter chain. For example:
    ///
    /// .. code-block:: yaml
    ///
    ///   http_filters:
    ///     - name: envoy.filters.http.ext_authz
    ///       typed_config:
    ///         "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
    ///         stat_prefix: waf # This emits ext_authz.waf.ok, ext_authz.waf.denied, etc.
    ///     - name: envoy.filters.http.ext_authz
    ///       typed_config:
    ///         "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
    ///         stat_prefix: blocker # This emits ext_authz.blocker.ok, ext_authz.blocker.denied, etc.
    ///
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StatPrefix {
      get { return statPrefix_; }
      set {
        statPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "bootstrap_metadata_labels_key" field.</summary>
    public const int BootstrapMetadataLabelsKeyFieldNumber = 15;
    private string bootstrapMetadataLabelsKey_ = "";
    /// <summary>
    /// Optional labels that will be passed to :ref:`labels&lt;envoy_v3_api_field_service.auth.v3.AttributeContext.Peer.labels>` in
    /// :ref:`destination&lt;envoy_v3_api_field_service.auth.v3.AttributeContext.destination>`.
    /// The labels will be read from :ref:`metadata&lt;envoy_v3_api_msg_config.core.v3.Node>` with the specified key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string BootstrapMetadataLabelsKey {
      get { return bootstrapMetadataLabelsKey_; }
      set {
        bootstrapMetadataLabelsKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private object services_;
    /// <summary>Enum of possible cases for the "services" oneof.</summary>
    public enum ServicesOneofCase {
      None = 0,
      GrpcService = 1,
      HttpService = 3,
    }
    private ServicesOneofCase servicesCase_ = ServicesOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServicesOneofCase ServicesCase {
      get { return servicesCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearServices() {
      servicesCase_ = ServicesOneofCase.None;
      services_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ExtAuthz);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ExtAuthz other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(GrpcService, other.GrpcService)) return false;
      if (!object.Equals(HttpService, other.HttpService)) return false;
      if (TransportApiVersion != other.TransportApiVersion) return false;
      if (FailureModeAllow != other.FailureModeAllow) return false;
      if (!object.Equals(WithRequestBody, other.WithRequestBody)) return false;
      if (ClearRouteCache != other.ClearRouteCache) return false;
      if (!object.Equals(StatusOnError, other.StatusOnError)) return false;
      if(!metadataContextNamespaces_.Equals(other.metadataContextNamespaces_)) return false;
      if (!object.Equals(FilterEnabled, other.FilterEnabled)) return false;
      if (!object.Equals(FilterEnabledMetadata, other.FilterEnabledMetadata)) return false;
      if (!object.Equals(DenyAtDisable, other.DenyAtDisable)) return false;
      if (IncludePeerCertificate != other.IncludePeerCertificate) return false;
      if (StatPrefix != other.StatPrefix) return false;
      if (BootstrapMetadataLabelsKey != other.BootstrapMetadataLabelsKey) return false;
      if (ServicesCase != other.ServicesCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (servicesCase_ == ServicesOneofCase.GrpcService) hash ^= GrpcService.GetHashCode();
      if (servicesCase_ == ServicesOneofCase.HttpService) hash ^= HttpService.GetHashCode();
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) hash ^= TransportApiVersion.GetHashCode();
      if (FailureModeAllow != false) hash ^= FailureModeAllow.GetHashCode();
      if (withRequestBody_ != null) hash ^= WithRequestBody.GetHashCode();
      if (ClearRouteCache != false) hash ^= ClearRouteCache.GetHashCode();
      if (statusOnError_ != null) hash ^= StatusOnError.GetHashCode();
      hash ^= metadataContextNamespaces_.GetHashCode();
      if (filterEnabled_ != null) hash ^= FilterEnabled.GetHashCode();
      if (filterEnabledMetadata_ != null) hash ^= FilterEnabledMetadata.GetHashCode();
      if (denyAtDisable_ != null) hash ^= DenyAtDisable.GetHashCode();
      if (IncludePeerCertificate != false) hash ^= IncludePeerCertificate.GetHashCode();
      if (StatPrefix.Length != 0) hash ^= StatPrefix.GetHashCode();
      if (BootstrapMetadataLabelsKey.Length != 0) hash ^= BootstrapMetadataLabelsKey.GetHashCode();
      hash ^= (int) servicesCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (servicesCase_ == ServicesOneofCase.GrpcService) {
        output.WriteRawTag(10);
        output.WriteMessage(GrpcService);
      }
      if (FailureModeAllow != false) {
        output.WriteRawTag(16);
        output.WriteBool(FailureModeAllow);
      }
      if (servicesCase_ == ServicesOneofCase.HttpService) {
        output.WriteRawTag(26);
        output.WriteMessage(HttpService);
      }
      if (withRequestBody_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WithRequestBody);
      }
      if (ClearRouteCache != false) {
        output.WriteRawTag(48);
        output.WriteBool(ClearRouteCache);
      }
      if (statusOnError_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(StatusOnError);
      }
      metadataContextNamespaces_.WriteTo(output, _repeated_metadataContextNamespaces_codec);
      if (filterEnabled_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(FilterEnabled);
      }
      if (IncludePeerCertificate != false) {
        output.WriteRawTag(80);
        output.WriteBool(IncludePeerCertificate);
      }
      if (denyAtDisable_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(DenyAtDisable);
      }
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        output.WriteRawTag(96);
        output.WriteEnum((int) TransportApiVersion);
      }
      if (StatPrefix.Length != 0) {
        output.WriteRawTag(106);
        output.WriteString(StatPrefix);
      }
      if (filterEnabledMetadata_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(FilterEnabledMetadata);
      }
      if (BootstrapMetadataLabelsKey.Length != 0) {
        output.WriteRawTag(122);
        output.WriteString(BootstrapMetadataLabelsKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (servicesCase_ == ServicesOneofCase.GrpcService) {
        output.WriteRawTag(10);
        output.WriteMessage(GrpcService);
      }
      if (FailureModeAllow != false) {
        output.WriteRawTag(16);
        output.WriteBool(FailureModeAllow);
      }
      if (servicesCase_ == ServicesOneofCase.HttpService) {
        output.WriteRawTag(26);
        output.WriteMessage(HttpService);
      }
      if (withRequestBody_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WithRequestBody);
      }
      if (ClearRouteCache != false) {
        output.WriteRawTag(48);
        output.WriteBool(ClearRouteCache);
      }
      if (statusOnError_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(StatusOnError);
      }
      metadataContextNamespaces_.WriteTo(ref output, _repeated_metadataContextNamespaces_codec);
      if (filterEnabled_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(FilterEnabled);
      }
      if (IncludePeerCertificate != false) {
        output.WriteRawTag(80);
        output.WriteBool(IncludePeerCertificate);
      }
      if (denyAtDisable_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(DenyAtDisable);
      }
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        output.WriteRawTag(96);
        output.WriteEnum((int) TransportApiVersion);
      }
      if (StatPrefix.Length != 0) {
        output.WriteRawTag(106);
        output.WriteString(StatPrefix);
      }
      if (filterEnabledMetadata_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(FilterEnabledMetadata);
      }
      if (BootstrapMetadataLabelsKey.Length != 0) {
        output.WriteRawTag(122);
        output.WriteString(BootstrapMetadataLabelsKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (servicesCase_ == ServicesOneofCase.GrpcService) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GrpcService);
      }
      if (servicesCase_ == ServicesOneofCase.HttpService) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpService);
      }
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TransportApiVersion);
      }
      if (FailureModeAllow != false) {
        size += 1 + 1;
      }
      if (withRequestBody_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WithRequestBody);
      }
      if (ClearRouteCache != false) {
        size += 1 + 1;
      }
      if (statusOnError_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StatusOnError);
      }
      size += metadataContextNamespaces_.CalculateSize(_repeated_metadataContextNamespaces_codec);
      if (filterEnabled_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FilterEnabled);
      }
      if (filterEnabledMetadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FilterEnabledMetadata);
      }
      if (denyAtDisable_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DenyAtDisable);
      }
      if (IncludePeerCertificate != false) {
        size += 1 + 1;
      }
      if (StatPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StatPrefix);
      }
      if (BootstrapMetadataLabelsKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BootstrapMetadataLabelsKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ExtAuthz other) {
      if (other == null) {
        return;
      }
      if (other.TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        TransportApiVersion = other.TransportApiVersion;
      }
      if (other.FailureModeAllow != false) {
        FailureModeAllow = other.FailureModeAllow;
      }
      if (other.withRequestBody_ != null) {
        if (withRequestBody_ == null) {
          WithRequestBody = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.BufferSettings();
        }
        WithRequestBody.MergeFrom(other.WithRequestBody);
      }
      if (other.ClearRouteCache != false) {
        ClearRouteCache = other.ClearRouteCache;
      }
      if (other.statusOnError_ != null) {
        if (statusOnError_ == null) {
          StatusOnError = new global::Envoy.Type.V3.HttpStatus();
        }
        StatusOnError.MergeFrom(other.StatusOnError);
      }
      metadataContextNamespaces_.Add(other.metadataContextNamespaces_);
      if (other.filterEnabled_ != null) {
        if (filterEnabled_ == null) {
          FilterEnabled = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
        }
        FilterEnabled.MergeFrom(other.FilterEnabled);
      }
      if (other.filterEnabledMetadata_ != null) {
        if (filterEnabledMetadata_ == null) {
          FilterEnabledMetadata = new global::Envoy.Type.Matcher.V3.MetadataMatcher();
        }
        FilterEnabledMetadata.MergeFrom(other.FilterEnabledMetadata);
      }
      if (other.denyAtDisable_ != null) {
        if (denyAtDisable_ == null) {
          DenyAtDisable = new global::Envoy.Config.Core.V3.RuntimeFeatureFlag();
        }
        DenyAtDisable.MergeFrom(other.DenyAtDisable);
      }
      if (other.IncludePeerCertificate != false) {
        IncludePeerCertificate = other.IncludePeerCertificate;
      }
      if (other.StatPrefix.Length != 0) {
        StatPrefix = other.StatPrefix;
      }
      if (other.BootstrapMetadataLabelsKey.Length != 0) {
        BootstrapMetadataLabelsKey = other.BootstrapMetadataLabelsKey;
      }
      switch (other.ServicesCase) {
        case ServicesOneofCase.GrpcService:
          if (GrpcService == null) {
            GrpcService = new global::Envoy.Config.Core.V3.GrpcService();
          }
          GrpcService.MergeFrom(other.GrpcService);
          break;
        case ServicesOneofCase.HttpService:
          if (HttpService == null) {
            HttpService = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.HttpService();
          }
          HttpService.MergeFrom(other.HttpService);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Envoy.Config.Core.V3.GrpcService subBuilder = new global::Envoy.Config.Core.V3.GrpcService();
            if (servicesCase_ == ServicesOneofCase.GrpcService) {
              subBuilder.MergeFrom(GrpcService);
            }
            input.ReadMessage(subBuilder);
            GrpcService = subBuilder;
            break;
          }
          case 16: {
            FailureModeAllow = input.ReadBool();
            break;
          }
          case 26: {
            global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.HttpService subBuilder = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.HttpService();
            if (servicesCase_ == ServicesOneofCase.HttpService) {
              subBuilder.MergeFrom(HttpService);
            }
            input.ReadMessage(subBuilder);
            HttpService = subBuilder;
            break;
          }
          case 42: {
            if (withRequestBody_ == null) {
              WithRequestBody = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.BufferSettings();
            }
            input.ReadMessage(WithRequestBody);
            break;
          }
          case 48: {
            ClearRouteCache = input.ReadBool();
            break;
          }
          case 58: {
            if (statusOnError_ == null) {
              StatusOnError = new global::Envoy.Type.V3.HttpStatus();
            }
            input.ReadMessage(StatusOnError);
            break;
          }
          case 66: {
            metadataContextNamespaces_.AddEntriesFrom(input, _repeated_metadataContextNamespaces_codec);
            break;
          }
          case 74: {
            if (filterEnabled_ == null) {
              FilterEnabled = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
            }
            input.ReadMessage(FilterEnabled);
            break;
          }
          case 80: {
            IncludePeerCertificate = input.ReadBool();
            break;
          }
          case 90: {
            if (denyAtDisable_ == null) {
              DenyAtDisable = new global::Envoy.Config.Core.V3.RuntimeFeatureFlag();
            }
            input.ReadMessage(DenyAtDisable);
            break;
          }
          case 96: {
            TransportApiVersion = (global::Envoy.Config.Core.V3.ApiVersion) input.ReadEnum();
            break;
          }
          case 106: {
            StatPrefix = input.ReadString();
            break;
          }
          case 114: {
            if (filterEnabledMetadata_ == null) {
              FilterEnabledMetadata = new global::Envoy.Type.Matcher.V3.MetadataMatcher();
            }
            input.ReadMessage(FilterEnabledMetadata);
            break;
          }
          case 122: {
            BootstrapMetadataLabelsKey = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Envoy.Config.Core.V3.GrpcService subBuilder = new global::Envoy.Config.Core.V3.GrpcService();
            if (servicesCase_ == ServicesOneofCase.GrpcService) {
              subBuilder.MergeFrom(GrpcService);
            }
            input.ReadMessage(subBuilder);
            GrpcService = subBuilder;
            break;
          }
          case 16: {
            FailureModeAllow = input.ReadBool();
            break;
          }
          case 26: {
            global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.HttpService subBuilder = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.HttpService();
            if (servicesCase_ == ServicesOneofCase.HttpService) {
              subBuilder.MergeFrom(HttpService);
            }
            input.ReadMessage(subBuilder);
            HttpService = subBuilder;
            break;
          }
          case 42: {
            if (withRequestBody_ == null) {
              WithRequestBody = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.BufferSettings();
            }
            input.ReadMessage(WithRequestBody);
            break;
          }
          case 48: {
            ClearRouteCache = input.ReadBool();
            break;
          }
          case 58: {
            if (statusOnError_ == null) {
              StatusOnError = new global::Envoy.Type.V3.HttpStatus();
            }
            input.ReadMessage(StatusOnError);
            break;
          }
          case 66: {
            metadataContextNamespaces_.AddEntriesFrom(ref input, _repeated_metadataContextNamespaces_codec);
            break;
          }
          case 74: {
            if (filterEnabled_ == null) {
              FilterEnabled = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
            }
            input.ReadMessage(FilterEnabled);
            break;
          }
          case 80: {
            IncludePeerCertificate = input.ReadBool();
            break;
          }
          case 90: {
            if (denyAtDisable_ == null) {
              DenyAtDisable = new global::Envoy.Config.Core.V3.RuntimeFeatureFlag();
            }
            input.ReadMessage(DenyAtDisable);
            break;
          }
          case 96: {
            TransportApiVersion = (global::Envoy.Config.Core.V3.ApiVersion) input.ReadEnum();
            break;
          }
          case 106: {
            StatPrefix = input.ReadString();
            break;
          }
          case 114: {
            if (filterEnabledMetadata_ == null) {
              FilterEnabledMetadata = new global::Envoy.Type.Matcher.V3.MetadataMatcher();
            }
            input.ReadMessage(FilterEnabledMetadata);
            break;
          }
          case 122: {
            BootstrapMetadataLabelsKey = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configuration for buffering the request data.
  /// </summary>
  public sealed partial class BufferSettings : pb::IMessage<BufferSettings>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BufferSettings> _parser = new pb::MessageParser<BufferSettings>(() => new BufferSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<BufferSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.ExtAuthzReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BufferSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BufferSettings(BufferSettings other) : this() {
      maxRequestBytes_ = other.maxRequestBytes_;
      allowPartialMessage_ = other.allowPartialMessage_;
      packAsBytes_ = other.packAsBytes_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BufferSettings Clone() {
      return new BufferSettings(this);
    }

    /// <summary>Field number for the "max_request_bytes" field.</summary>
    public const int MaxRequestBytesFieldNumber = 1;
    private uint maxRequestBytes_;
    /// <summary>
    /// Sets the maximum size of a message body that the filter will hold in memory. Envoy will return
    /// *HTTP 413* and will *not* initiate the authorization process when buffer reaches the number
    /// set in this field. Note that this setting will have precedence over :ref:`failure_mode_allow
    /// &lt;envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.failure_mode_allow>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint MaxRequestBytes {
      get { return maxRequestBytes_; }
      set {
        maxRequestBytes_ = value;
      }
    }

    /// <summary>Field number for the "allow_partial_message" field.</summary>
    public const int AllowPartialMessageFieldNumber = 2;
    private bool allowPartialMessage_;
    /// <summary>
    /// When this field is true, Envoy will buffer the message until *max_request_bytes* is reached.
    /// The authorization request will be dispatched and no 413 HTTP error will be returned by the
    /// filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowPartialMessage {
      get { return allowPartialMessage_; }
      set {
        allowPartialMessage_ = value;
      }
    }

    /// <summary>Field number for the "pack_as_bytes" field.</summary>
    public const int PackAsBytesFieldNumber = 3;
    private bool packAsBytes_;
    /// <summary>
    /// If true, the body sent to the external authorization service is set with raw bytes, it sets
    /// the :ref:`raw_body&lt;envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.raw_body>`
    /// field of HTTP request attribute context. Otherwise, :ref:`
    /// body&lt;envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.body>` will be filled
    /// with UTF-8 string request body.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool PackAsBytes {
      get { return packAsBytes_; }
      set {
        packAsBytes_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as BufferSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(BufferSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MaxRequestBytes != other.MaxRequestBytes) return false;
      if (AllowPartialMessage != other.AllowPartialMessage) return false;
      if (PackAsBytes != other.PackAsBytes) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (MaxRequestBytes != 0) hash ^= MaxRequestBytes.GetHashCode();
      if (AllowPartialMessage != false) hash ^= AllowPartialMessage.GetHashCode();
      if (PackAsBytes != false) hash ^= PackAsBytes.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MaxRequestBytes != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(MaxRequestBytes);
      }
      if (AllowPartialMessage != false) {
        output.WriteRawTag(16);
        output.WriteBool(AllowPartialMessage);
      }
      if (PackAsBytes != false) {
        output.WriteRawTag(24);
        output.WriteBool(PackAsBytes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MaxRequestBytes != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(MaxRequestBytes);
      }
      if (AllowPartialMessage != false) {
        output.WriteRawTag(16);
        output.WriteBool(AllowPartialMessage);
      }
      if (PackAsBytes != false) {
        output.WriteRawTag(24);
        output.WriteBool(PackAsBytes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (MaxRequestBytes != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxRequestBytes);
      }
      if (AllowPartialMessage != false) {
        size += 1 + 1;
      }
      if (PackAsBytes != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(BufferSettings other) {
      if (other == null) {
        return;
      }
      if (other.MaxRequestBytes != 0) {
        MaxRequestBytes = other.MaxRequestBytes;
      }
      if (other.AllowPartialMessage != false) {
        AllowPartialMessage = other.AllowPartialMessage;
      }
      if (other.PackAsBytes != false) {
        PackAsBytes = other.PackAsBytes;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MaxRequestBytes = input.ReadUInt32();
            break;
          }
          case 16: {
            AllowPartialMessage = input.ReadBool();
            break;
          }
          case 24: {
            PackAsBytes = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            MaxRequestBytes = input.ReadUInt32();
            break;
          }
          case 16: {
            AllowPartialMessage = input.ReadBool();
            break;
          }
          case 24: {
            PackAsBytes = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// HttpService is used for raw HTTP communication between the filter and the authorization service.
  /// When configured, the filter will parse the client request and use these attributes to call the
  /// authorization server. Depending on the response, the filter may reject or accept the client
  /// request. Note that in any of these events, metadata can be added, removed or overridden by the
  /// filter:
  ///
  /// *On authorization request*, a list of allowed request headers may be supplied. See
  /// :ref:`allowed_headers
  /// &lt;envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationRequest.allowed_headers>`
  /// for details. Additional headers metadata may be added to the authorization request. See
  /// :ref:`headers_to_add
  /// &lt;envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationRequest.headers_to_add>` for
  /// details.
  ///
  /// On authorization response status HTTP 200 OK, the filter will allow traffic to the upstream and
  /// additional headers metadata may be added to the original client request. See
  /// :ref:`allowed_upstream_headers
  /// &lt;envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_upstream_headers>`
  /// for details. Additionally, the filter may add additional headers to the client's response. See
  /// :ref:`allowed_client_headers_on_success
  /// &lt;envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_client_headers_on_success>`
  /// for details.
  ///
  /// On other authorization response statuses, the filter will not allow traffic. Additional headers
  /// metadata as well as body may be added to the client's response. See :ref:`allowed_client_headers
  /// &lt;envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_client_headers>`
  /// for details.
  /// [#next-free-field: 9]
  /// </summary>
  public sealed partial class HttpService : pb::IMessage<HttpService>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HttpService> _parser = new pb::MessageParser<HttpService>(() => new HttpService());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HttpService> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.ExtAuthzReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpService() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpService(HttpService other) : this() {
      serverUri_ = other.serverUri_ != null ? other.serverUri_.Clone() : null;
      pathPrefix_ = other.pathPrefix_;
      authorizationRequest_ = other.authorizationRequest_ != null ? other.authorizationRequest_.Clone() : null;
      authorizationResponse_ = other.authorizationResponse_ != null ? other.authorizationResponse_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpService Clone() {
      return new HttpService(this);
    }

    /// <summary>Field number for the "server_uri" field.</summary>
    public const int ServerUriFieldNumber = 1;
    private global::Envoy.Config.Core.V3.HttpUri serverUri_;
    /// <summary>
    /// Sets the HTTP server URI which the authorization requests must be sent to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.HttpUri ServerUri {
      get { return serverUri_; }
      set {
        serverUri_ = value;
      }
    }

    /// <summary>Field number for the "path_prefix" field.</summary>
    public const int PathPrefixFieldNumber = 2;
    private string pathPrefix_ = "";
    /// <summary>
    /// Sets a prefix to the value of authorization request header *Path*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PathPrefix {
      get { return pathPrefix_; }
      set {
        pathPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "authorization_request" field.</summary>
    public const int AuthorizationRequestFieldNumber = 7;
    private global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.AuthorizationRequest authorizationRequest_;
    /// <summary>
    /// Settings used for controlling authorization request metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.AuthorizationRequest AuthorizationRequest {
      get { return authorizationRequest_; }
      set {
        authorizationRequest_ = value;
      }
    }

    /// <summary>Field number for the "authorization_response" field.</summary>
    public const int AuthorizationResponseFieldNumber = 8;
    private global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.AuthorizationResponse authorizationResponse_;
    /// <summary>
    /// Settings used for controlling authorization response metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.AuthorizationResponse AuthorizationResponse {
      get { return authorizationResponse_; }
      set {
        authorizationResponse_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HttpService);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HttpService other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ServerUri, other.ServerUri)) return false;
      if (PathPrefix != other.PathPrefix) return false;
      if (!object.Equals(AuthorizationRequest, other.AuthorizationRequest)) return false;
      if (!object.Equals(AuthorizationResponse, other.AuthorizationResponse)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (serverUri_ != null) hash ^= ServerUri.GetHashCode();
      if (PathPrefix.Length != 0) hash ^= PathPrefix.GetHashCode();
      if (authorizationRequest_ != null) hash ^= AuthorizationRequest.GetHashCode();
      if (authorizationResponse_ != null) hash ^= AuthorizationResponse.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (serverUri_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ServerUri);
      }
      if (PathPrefix.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(PathPrefix);
      }
      if (authorizationRequest_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(AuthorizationRequest);
      }
      if (authorizationResponse_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AuthorizationResponse);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (serverUri_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ServerUri);
      }
      if (PathPrefix.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(PathPrefix);
      }
      if (authorizationRequest_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(AuthorizationRequest);
      }
      if (authorizationResponse_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AuthorizationResponse);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (serverUri_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ServerUri);
      }
      if (PathPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PathPrefix);
      }
      if (authorizationRequest_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AuthorizationRequest);
      }
      if (authorizationResponse_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AuthorizationResponse);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HttpService other) {
      if (other == null) {
        return;
      }
      if (other.serverUri_ != null) {
        if (serverUri_ == null) {
          ServerUri = new global::Envoy.Config.Core.V3.HttpUri();
        }
        ServerUri.MergeFrom(other.ServerUri);
      }
      if (other.PathPrefix.Length != 0) {
        PathPrefix = other.PathPrefix;
      }
      if (other.authorizationRequest_ != null) {
        if (authorizationRequest_ == null) {
          AuthorizationRequest = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.AuthorizationRequest();
        }
        AuthorizationRequest.MergeFrom(other.AuthorizationRequest);
      }
      if (other.authorizationResponse_ != null) {
        if (authorizationResponse_ == null) {
          AuthorizationResponse = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.AuthorizationResponse();
        }
        AuthorizationResponse.MergeFrom(other.AuthorizationResponse);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (serverUri_ == null) {
              ServerUri = new global::Envoy.Config.Core.V3.HttpUri();
            }
            input.ReadMessage(ServerUri);
            break;
          }
          case 18: {
            PathPrefix = input.ReadString();
            break;
          }
          case 58: {
            if (authorizationRequest_ == null) {
              AuthorizationRequest = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.AuthorizationRequest();
            }
            input.ReadMessage(AuthorizationRequest);
            break;
          }
          case 66: {
            if (authorizationResponse_ == null) {
              AuthorizationResponse = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.AuthorizationResponse();
            }
            input.ReadMessage(AuthorizationResponse);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (serverUri_ == null) {
              ServerUri = new global::Envoy.Config.Core.V3.HttpUri();
            }
            input.ReadMessage(ServerUri);
            break;
          }
          case 18: {
            PathPrefix = input.ReadString();
            break;
          }
          case 58: {
            if (authorizationRequest_ == null) {
              AuthorizationRequest = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.AuthorizationRequest();
            }
            input.ReadMessage(AuthorizationRequest);
            break;
          }
          case 66: {
            if (authorizationResponse_ == null) {
              AuthorizationResponse = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.AuthorizationResponse();
            }
            input.ReadMessage(AuthorizationResponse);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class AuthorizationRequest : pb::IMessage<AuthorizationRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AuthorizationRequest> _parser = new pb::MessageParser<AuthorizationRequest>(() => new AuthorizationRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AuthorizationRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.ExtAuthzReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AuthorizationRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AuthorizationRequest(AuthorizationRequest other) : this() {
      allowedHeaders_ = other.allowedHeaders_ != null ? other.allowedHeaders_.Clone() : null;
      headersToAdd_ = other.headersToAdd_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AuthorizationRequest Clone() {
      return new AuthorizationRequest(this);
    }

    /// <summary>Field number for the "allowed_headers" field.</summary>
    public const int AllowedHeadersFieldNumber = 1;
    private global::Envoy.Type.Matcher.V3.ListStringMatcher allowedHeaders_;
    /// <summary>
    /// Authorization request includes the client request headers that have a correspondent match
    /// in the :ref:`list &lt;envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>`.
    ///
    /// .. note::
    ///
    ///   In addition to the the user's supplied matchers, ``Host``, ``Method``, ``Path``,
    ///   ``Content-Length``, and ``Authorization`` are **automatically included** to the list.
    ///
    /// .. note::
    ///
    ///   By default, ``Content-Length`` header is set to ``0`` and the request to the authorization
    ///   service has no message body. However, the authorization request *may* include the buffered
    ///   client request body (controlled by :ref:`with_request_body
    ///   &lt;envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.with_request_body>`
    ///   setting) hence the value of its ``Content-Length`` reflects the size of its payload size.
    ///
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.ListStringMatcher AllowedHeaders {
      get { return allowedHeaders_; }
      set {
        allowedHeaders_ = value;
      }
    }

    /// <summary>Field number for the "headers_to_add" field.</summary>
    public const int HeadersToAddFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.HeaderValue> _repeated_headersToAdd_codec
        = pb::FieldCodec.ForMessage(18, global::Envoy.Config.Core.V3.HeaderValue.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValue> headersToAdd_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValue>();
    /// <summary>
    /// Sets a list of headers that will be included to the request to authorization service. Note that
    /// client request of the same key will be overridden.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValue> HeadersToAdd {
      get { return headersToAdd_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AuthorizationRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AuthorizationRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AllowedHeaders, other.AllowedHeaders)) return false;
      if(!headersToAdd_.Equals(other.headersToAdd_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (allowedHeaders_ != null) hash ^= AllowedHeaders.GetHashCode();
      hash ^= headersToAdd_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (allowedHeaders_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AllowedHeaders);
      }
      headersToAdd_.WriteTo(output, _repeated_headersToAdd_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (allowedHeaders_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AllowedHeaders);
      }
      headersToAdd_.WriteTo(ref output, _repeated_headersToAdd_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (allowedHeaders_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AllowedHeaders);
      }
      size += headersToAdd_.CalculateSize(_repeated_headersToAdd_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AuthorizationRequest other) {
      if (other == null) {
        return;
      }
      if (other.allowedHeaders_ != null) {
        if (allowedHeaders_ == null) {
          AllowedHeaders = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
        }
        AllowedHeaders.MergeFrom(other.AllowedHeaders);
      }
      headersToAdd_.Add(other.headersToAdd_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (allowedHeaders_ == null) {
              AllowedHeaders = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
            }
            input.ReadMessage(AllowedHeaders);
            break;
          }
          case 18: {
            headersToAdd_.AddEntriesFrom(input, _repeated_headersToAdd_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (allowedHeaders_ == null) {
              AllowedHeaders = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
            }
            input.ReadMessage(AllowedHeaders);
            break;
          }
          case 18: {
            headersToAdd_.AddEntriesFrom(ref input, _repeated_headersToAdd_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#next-free-field: 6]
  /// </summary>
  public sealed partial class AuthorizationResponse : pb::IMessage<AuthorizationResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AuthorizationResponse> _parser = new pb::MessageParser<AuthorizationResponse>(() => new AuthorizationResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AuthorizationResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.ExtAuthzReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AuthorizationResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AuthorizationResponse(AuthorizationResponse other) : this() {
      allowedUpstreamHeaders_ = other.allowedUpstreamHeaders_ != null ? other.allowedUpstreamHeaders_.Clone() : null;
      allowedUpstreamHeadersToAppend_ = other.allowedUpstreamHeadersToAppend_ != null ? other.allowedUpstreamHeadersToAppend_.Clone() : null;
      allowedClientHeaders_ = other.allowedClientHeaders_ != null ? other.allowedClientHeaders_.Clone() : null;
      allowedClientHeadersOnSuccess_ = other.allowedClientHeadersOnSuccess_ != null ? other.allowedClientHeadersOnSuccess_.Clone() : null;
      dynamicMetadataFromHeaders_ = other.dynamicMetadataFromHeaders_ != null ? other.dynamicMetadataFromHeaders_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AuthorizationResponse Clone() {
      return new AuthorizationResponse(this);
    }

    /// <summary>Field number for the "allowed_upstream_headers" field.</summary>
    public const int AllowedUpstreamHeadersFieldNumber = 1;
    private global::Envoy.Type.Matcher.V3.ListStringMatcher allowedUpstreamHeaders_;
    /// <summary>
    /// When this :ref:`list &lt;envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
    /// response headers that have a correspondent match will be added to the original client request.
    /// Note that coexistent headers will be overridden.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.ListStringMatcher AllowedUpstreamHeaders {
      get { return allowedUpstreamHeaders_; }
      set {
        allowedUpstreamHeaders_ = value;
      }
    }

    /// <summary>Field number for the "allowed_upstream_headers_to_append" field.</summary>
    public const int AllowedUpstreamHeadersToAppendFieldNumber = 3;
    private global::Envoy.Type.Matcher.V3.ListStringMatcher allowedUpstreamHeadersToAppend_;
    /// <summary>
    /// When this :ref:`list &lt;envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
    /// response headers that have a correspondent match will be added to the client's response. Note
    /// that coexistent headers will be appended.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.ListStringMatcher AllowedUpstreamHeadersToAppend {
      get { return allowedUpstreamHeadersToAppend_; }
      set {
        allowedUpstreamHeadersToAppend_ = value;
      }
    }

    /// <summary>Field number for the "allowed_client_headers" field.</summary>
    public const int AllowedClientHeadersFieldNumber = 2;
    private global::Envoy.Type.Matcher.V3.ListStringMatcher allowedClientHeaders_;
    /// <summary>
    /// When this :ref:`list &lt;envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>`. is set, authorization
    /// response headers that have a correspondent match will be added to the client's response. Note
    /// that when this list is *not* set, all the authorization response headers, except *Authority
    /// (Host)* will be in the response to the client. When a header is included in this list, *Path*,
    /// *Status*, *Content-Length*, *WWWAuthenticate* and *Location* are automatically added.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.ListStringMatcher AllowedClientHeaders {
      get { return allowedClientHeaders_; }
      set {
        allowedClientHeaders_ = value;
      }
    }

    /// <summary>Field number for the "allowed_client_headers_on_success" field.</summary>
    public const int AllowedClientHeadersOnSuccessFieldNumber = 4;
    private global::Envoy.Type.Matcher.V3.ListStringMatcher allowedClientHeadersOnSuccess_;
    /// <summary>
    /// When this :ref:`list &lt;envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>`. is set, authorization
    /// response headers that have a correspondent match will be added to the client's response when
    /// the authorization response itself is successful, i.e. not failed or denied. When this list is
    /// *not* set, no additional headers will be added to the client's response on success.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.ListStringMatcher AllowedClientHeadersOnSuccess {
      get { return allowedClientHeadersOnSuccess_; }
      set {
        allowedClientHeadersOnSuccess_ = value;
      }
    }

    /// <summary>Field number for the "dynamic_metadata_from_headers" field.</summary>
    public const int DynamicMetadataFromHeadersFieldNumber = 5;
    private global::Envoy.Type.Matcher.V3.ListStringMatcher dynamicMetadataFromHeaders_;
    /// <summary>
    /// When this :ref:`list &lt;envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
    /// response headers that have a correspondent match will be emitted as dynamic metadata to be consumed
    /// by the next filter. This metadata lives in a namespace specified by the canonical name of extension filter
    /// that requires it:
    ///
    /// - :ref:`envoy.filters.http.ext_authz &lt;config_http_filters_ext_authz_dynamic_metadata>` for HTTP filter.
    /// - :ref:`envoy.filters.network.ext_authz &lt;config_network_filters_ext_authz_dynamic_metadata>` for network filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.ListStringMatcher DynamicMetadataFromHeaders {
      get { return dynamicMetadataFromHeaders_; }
      set {
        dynamicMetadataFromHeaders_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AuthorizationResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AuthorizationResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AllowedUpstreamHeaders, other.AllowedUpstreamHeaders)) return false;
      if (!object.Equals(AllowedUpstreamHeadersToAppend, other.AllowedUpstreamHeadersToAppend)) return false;
      if (!object.Equals(AllowedClientHeaders, other.AllowedClientHeaders)) return false;
      if (!object.Equals(AllowedClientHeadersOnSuccess, other.AllowedClientHeadersOnSuccess)) return false;
      if (!object.Equals(DynamicMetadataFromHeaders, other.DynamicMetadataFromHeaders)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (allowedUpstreamHeaders_ != null) hash ^= AllowedUpstreamHeaders.GetHashCode();
      if (allowedUpstreamHeadersToAppend_ != null) hash ^= AllowedUpstreamHeadersToAppend.GetHashCode();
      if (allowedClientHeaders_ != null) hash ^= AllowedClientHeaders.GetHashCode();
      if (allowedClientHeadersOnSuccess_ != null) hash ^= AllowedClientHeadersOnSuccess.GetHashCode();
      if (dynamicMetadataFromHeaders_ != null) hash ^= DynamicMetadataFromHeaders.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (allowedUpstreamHeaders_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AllowedUpstreamHeaders);
      }
      if (allowedClientHeaders_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AllowedClientHeaders);
      }
      if (allowedUpstreamHeadersToAppend_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(AllowedUpstreamHeadersToAppend);
      }
      if (allowedClientHeadersOnSuccess_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(AllowedClientHeadersOnSuccess);
      }
      if (dynamicMetadataFromHeaders_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(DynamicMetadataFromHeaders);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (allowedUpstreamHeaders_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AllowedUpstreamHeaders);
      }
      if (allowedClientHeaders_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AllowedClientHeaders);
      }
      if (allowedUpstreamHeadersToAppend_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(AllowedUpstreamHeadersToAppend);
      }
      if (allowedClientHeadersOnSuccess_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(AllowedClientHeadersOnSuccess);
      }
      if (dynamicMetadataFromHeaders_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(DynamicMetadataFromHeaders);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (allowedUpstreamHeaders_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AllowedUpstreamHeaders);
      }
      if (allowedUpstreamHeadersToAppend_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AllowedUpstreamHeadersToAppend);
      }
      if (allowedClientHeaders_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AllowedClientHeaders);
      }
      if (allowedClientHeadersOnSuccess_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AllowedClientHeadersOnSuccess);
      }
      if (dynamicMetadataFromHeaders_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DynamicMetadataFromHeaders);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AuthorizationResponse other) {
      if (other == null) {
        return;
      }
      if (other.allowedUpstreamHeaders_ != null) {
        if (allowedUpstreamHeaders_ == null) {
          AllowedUpstreamHeaders = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
        }
        AllowedUpstreamHeaders.MergeFrom(other.AllowedUpstreamHeaders);
      }
      if (other.allowedUpstreamHeadersToAppend_ != null) {
        if (allowedUpstreamHeadersToAppend_ == null) {
          AllowedUpstreamHeadersToAppend = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
        }
        AllowedUpstreamHeadersToAppend.MergeFrom(other.AllowedUpstreamHeadersToAppend);
      }
      if (other.allowedClientHeaders_ != null) {
        if (allowedClientHeaders_ == null) {
          AllowedClientHeaders = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
        }
        AllowedClientHeaders.MergeFrom(other.AllowedClientHeaders);
      }
      if (other.allowedClientHeadersOnSuccess_ != null) {
        if (allowedClientHeadersOnSuccess_ == null) {
          AllowedClientHeadersOnSuccess = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
        }
        AllowedClientHeadersOnSuccess.MergeFrom(other.AllowedClientHeadersOnSuccess);
      }
      if (other.dynamicMetadataFromHeaders_ != null) {
        if (dynamicMetadataFromHeaders_ == null) {
          DynamicMetadataFromHeaders = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
        }
        DynamicMetadataFromHeaders.MergeFrom(other.DynamicMetadataFromHeaders);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (allowedUpstreamHeaders_ == null) {
              AllowedUpstreamHeaders = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
            }
            input.ReadMessage(AllowedUpstreamHeaders);
            break;
          }
          case 18: {
            if (allowedClientHeaders_ == null) {
              AllowedClientHeaders = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
            }
            input.ReadMessage(AllowedClientHeaders);
            break;
          }
          case 26: {
            if (allowedUpstreamHeadersToAppend_ == null) {
              AllowedUpstreamHeadersToAppend = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
            }
            input.ReadMessage(AllowedUpstreamHeadersToAppend);
            break;
          }
          case 34: {
            if (allowedClientHeadersOnSuccess_ == null) {
              AllowedClientHeadersOnSuccess = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
            }
            input.ReadMessage(AllowedClientHeadersOnSuccess);
            break;
          }
          case 42: {
            if (dynamicMetadataFromHeaders_ == null) {
              DynamicMetadataFromHeaders = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
            }
            input.ReadMessage(DynamicMetadataFromHeaders);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (allowedUpstreamHeaders_ == null) {
              AllowedUpstreamHeaders = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
            }
            input.ReadMessage(AllowedUpstreamHeaders);
            break;
          }
          case 18: {
            if (allowedClientHeaders_ == null) {
              AllowedClientHeaders = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
            }
            input.ReadMessage(AllowedClientHeaders);
            break;
          }
          case 26: {
            if (allowedUpstreamHeadersToAppend_ == null) {
              AllowedUpstreamHeadersToAppend = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
            }
            input.ReadMessage(AllowedUpstreamHeadersToAppend);
            break;
          }
          case 34: {
            if (allowedClientHeadersOnSuccess_ == null) {
              AllowedClientHeadersOnSuccess = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
            }
            input.ReadMessage(AllowedClientHeadersOnSuccess);
            break;
          }
          case 42: {
            if (dynamicMetadataFromHeaders_ == null) {
              DynamicMetadataFromHeaders = new global::Envoy.Type.Matcher.V3.ListStringMatcher();
            }
            input.ReadMessage(DynamicMetadataFromHeaders);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Extra settings on a per virtualhost/route/weighted-cluster level.
  /// </summary>
  public sealed partial class ExtAuthzPerRoute : pb::IMessage<ExtAuthzPerRoute>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ExtAuthzPerRoute> _parser = new pb::MessageParser<ExtAuthzPerRoute>(() => new ExtAuthzPerRoute());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ExtAuthzPerRoute> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.ExtAuthzReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExtAuthzPerRoute() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExtAuthzPerRoute(ExtAuthzPerRoute other) : this() {
      switch (other.OverrideCase) {
        case OverrideOneofCase.Disabled:
          Disabled = other.Disabled;
          break;
        case OverrideOneofCase.CheckSettings:
          CheckSettings = other.CheckSettings.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExtAuthzPerRoute Clone() {
      return new ExtAuthzPerRoute(this);
    }

    /// <summary>Field number for the "disabled" field.</summary>
    public const int DisabledFieldNumber = 1;
    /// <summary>
    /// Disable the ext auth filter for this particular vhost or route.
    /// If disabled is specified in multiple per-filter-configs, the most specific one will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Disabled {
      get { return overrideCase_ == OverrideOneofCase.Disabled ? (bool) override_ : false; }
      set {
        override_ = value;
        overrideCase_ = OverrideOneofCase.Disabled;
      }
    }

    /// <summary>Field number for the "check_settings" field.</summary>
    public const int CheckSettingsFieldNumber = 2;
    /// <summary>
    /// Check request settings for this route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.CheckSettings CheckSettings {
      get { return overrideCase_ == OverrideOneofCase.CheckSettings ? (global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.CheckSettings) override_ : null; }
      set {
        override_ = value;
        overrideCase_ = value == null ? OverrideOneofCase.None : OverrideOneofCase.CheckSettings;
      }
    }

    private object override_;
    /// <summary>Enum of possible cases for the "override" oneof.</summary>
    public enum OverrideOneofCase {
      None = 0,
      Disabled = 1,
      CheckSettings = 2,
    }
    private OverrideOneofCase overrideCase_ = OverrideOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OverrideOneofCase OverrideCase {
      get { return overrideCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOverride() {
      overrideCase_ = OverrideOneofCase.None;
      override_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ExtAuthzPerRoute);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ExtAuthzPerRoute other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Disabled != other.Disabled) return false;
      if (!object.Equals(CheckSettings, other.CheckSettings)) return false;
      if (OverrideCase != other.OverrideCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (overrideCase_ == OverrideOneofCase.Disabled) hash ^= Disabled.GetHashCode();
      if (overrideCase_ == OverrideOneofCase.CheckSettings) hash ^= CheckSettings.GetHashCode();
      hash ^= (int) overrideCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (overrideCase_ == OverrideOneofCase.Disabled) {
        output.WriteRawTag(8);
        output.WriteBool(Disabled);
      }
      if (overrideCase_ == OverrideOneofCase.CheckSettings) {
        output.WriteRawTag(18);
        output.WriteMessage(CheckSettings);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (overrideCase_ == OverrideOneofCase.Disabled) {
        output.WriteRawTag(8);
        output.WriteBool(Disabled);
      }
      if (overrideCase_ == OverrideOneofCase.CheckSettings) {
        output.WriteRawTag(18);
        output.WriteMessage(CheckSettings);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (overrideCase_ == OverrideOneofCase.Disabled) {
        size += 1 + 1;
      }
      if (overrideCase_ == OverrideOneofCase.CheckSettings) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CheckSettings);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ExtAuthzPerRoute other) {
      if (other == null) {
        return;
      }
      switch (other.OverrideCase) {
        case OverrideOneofCase.Disabled:
          Disabled = other.Disabled;
          break;
        case OverrideOneofCase.CheckSettings:
          if (CheckSettings == null) {
            CheckSettings = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.CheckSettings();
          }
          CheckSettings.MergeFrom(other.CheckSettings);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Disabled = input.ReadBool();
            break;
          }
          case 18: {
            global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.CheckSettings subBuilder = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.CheckSettings();
            if (overrideCase_ == OverrideOneofCase.CheckSettings) {
              subBuilder.MergeFrom(CheckSettings);
            }
            input.ReadMessage(subBuilder);
            CheckSettings = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Disabled = input.ReadBool();
            break;
          }
          case 18: {
            global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.CheckSettings subBuilder = new global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.CheckSettings();
            if (overrideCase_ == OverrideOneofCase.CheckSettings) {
              subBuilder.MergeFrom(CheckSettings);
            }
            input.ReadMessage(subBuilder);
            CheckSettings = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Extra settings for the check request.
  /// </summary>
  public sealed partial class CheckSettings : pb::IMessage<CheckSettings>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CheckSettings> _parser = new pb::MessageParser<CheckSettings>(() => new CheckSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CheckSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Http.ExtAuthz.V3.ExtAuthzReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CheckSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CheckSettings(CheckSettings other) : this() {
      contextExtensions_ = other.contextExtensions_.Clone();
      disableRequestBodyBuffering_ = other.disableRequestBodyBuffering_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CheckSettings Clone() {
      return new CheckSettings(this);
    }

    /// <summary>Field number for the "context_extensions" field.</summary>
    public const int ContextExtensionsFieldNumber = 1;
    private static readonly pbc::MapField<string, string>.Codec _map_contextExtensions_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 10);
    private readonly pbc::MapField<string, string> contextExtensions_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Context extensions to set on the CheckRequest's
    /// :ref:`AttributeContext.context_extensions&lt;envoy_v3_api_field_service.auth.v3.AttributeContext.context_extensions>`
    ///
    /// You can use this to provide extra context for the external authorization server on specific
    /// virtual hosts/routes. For example, adding a context extension on the virtual host level can
    /// give the ext-authz server information on what virtual host is used without needing to parse the
    /// host header. If CheckSettings is specified in multiple per-filter-configs, they will be merged
    /// in order, and the result will be used.
    ///
    /// Merge semantics for this field are such that keys from more specific configs override.
    ///
    /// .. note::
    ///
    ///   These settings are only applied to a filter configured with a
    ///   :ref:`grpc_service&lt;envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.grpc_service>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> ContextExtensions {
      get { return contextExtensions_; }
    }

    /// <summary>Field number for the "disable_request_body_buffering" field.</summary>
    public const int DisableRequestBodyBufferingFieldNumber = 2;
    private bool disableRequestBodyBuffering_;
    /// <summary>
    /// When set to true, disable the configured :ref:`with_request_body
    /// &lt;envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.with_request_body>` for a route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool DisableRequestBodyBuffering {
      get { return disableRequestBodyBuffering_; }
      set {
        disableRequestBodyBuffering_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CheckSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CheckSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!ContextExtensions.Equals(other.ContextExtensions)) return false;
      if (DisableRequestBodyBuffering != other.DisableRequestBodyBuffering) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= ContextExtensions.GetHashCode();
      if (DisableRequestBodyBuffering != false) hash ^= DisableRequestBodyBuffering.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      contextExtensions_.WriteTo(output, _map_contextExtensions_codec);
      if (DisableRequestBodyBuffering != false) {
        output.WriteRawTag(16);
        output.WriteBool(DisableRequestBodyBuffering);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      contextExtensions_.WriteTo(ref output, _map_contextExtensions_codec);
      if (DisableRequestBodyBuffering != false) {
        output.WriteRawTag(16);
        output.WriteBool(DisableRequestBodyBuffering);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += contextExtensions_.CalculateSize(_map_contextExtensions_codec);
      if (DisableRequestBodyBuffering != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CheckSettings other) {
      if (other == null) {
        return;
      }
      contextExtensions_.Add(other.contextExtensions_);
      if (other.DisableRequestBodyBuffering != false) {
        DisableRequestBodyBuffering = other.DisableRequestBodyBuffering;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            contextExtensions_.AddEntriesFrom(input, _map_contextExtensions_codec);
            break;
          }
          case 16: {
            DisableRequestBodyBuffering = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            contextExtensions_.AddEntriesFrom(ref input, _map_contextExtensions_codec);
            break;
          }
          case 16: {
            DisableRequestBodyBuffering = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
