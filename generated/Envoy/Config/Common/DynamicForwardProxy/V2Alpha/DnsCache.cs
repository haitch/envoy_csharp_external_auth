// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/common/dynamic_forward_proxy/v2alpha/dns_cache.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Common.DynamicForwardProxy.V2Alpha {

  /// <summary>Holder for reflection information generated from envoy/config/common/dynamic_forward_proxy/v2alpha/dns_cache.proto</summary>
  public static partial class DnsCacheReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/common/dynamic_forward_proxy/v2alpha/dns_cache.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static DnsCacheReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CkFlbnZveS9jb25maWcvY29tbW9uL2R5bmFtaWNfZm9yd2FyZF9wcm94eS92",
            "MmFscGhhL2Ruc19jYWNoZS5wcm90bxIxZW52b3kuY29uZmlnLmNvbW1vbi5k",
            "eW5hbWljX2ZvcndhcmRfcHJveHkudjJhbHBoYRoaZW52b3kvYXBpL3YyL2Ns",
            "dXN0ZXIucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90bxoe",
            "Z29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvGh51ZHBhL2Fubm90YXRp",
            "b25zL21pZ3JhdGUucHJvdG8aHXVkcGEvYW5ub3RhdGlvbnMvc3RhdHVzLnBy",
            "b3RvGhd2YWxpZGF0ZS92YWxpZGF0ZS5wcm90byLsAgoORG5zQ2FjaGVDb25m",
            "aWcSFQoEbmFtZRgBIAEoCUIH+kIEcgIgARJKChFkbnNfbG9va3VwX2ZhbWls",
            "eRgCIAEoDjIlLmVudm95LmFwaS52Mi5DbHVzdGVyLkRuc0xvb2t1cEZhbWls",
            "eUII+kIFggECEAESQQoQZG5zX3JlZnJlc2hfcmF0ZRgDIAEoCzIZLmdvb2ds",
            "ZS5wcm90b2J1Zi5EdXJhdGlvbkIM+kIJqgEGMgQQwIQ9EjUKCGhvc3RfdHRs",
            "GAQgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQgj6QgWqAQIqABI4",
            "CgltYXhfaG9zdHMYBSABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFs",
            "dWVCB/pCBCoCIAASQwoYZG5zX2ZhaWx1cmVfcmVmcmVzaF9yYXRlGAYgASgL",
            "MiEuZW52b3kuYXBpLnYyLkNsdXN0ZXIuUmVmcmVzaFJhdGVCkgEKP2lvLmVu",
            "dm95cHJveHkuZW52b3kuY29uZmlnLmNvbW1vbi5keW5hbWljX2ZvcndhcmRf",
            "cHJveHkudjJhbHBoYUINRG5zQ2FjaGVQcm90b1AB8pj+jwUyEjBlbnZveS5l",
            "eHRlbnNpb25zLmNvbW1vbi5keW5hbWljX2ZvcndhcmRfcHJveHkudjO6gMjR",
            "BgIQAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.ClusterReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Udpa.Annotations.MigrateReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Common.DynamicForwardProxy.V2Alpha.DnsCacheConfig), global::Envoy.Config.Common.DynamicForwardProxy.V2Alpha.DnsCacheConfig.Parser, new[]{ "Name", "DnsLookupFamily", "DnsRefreshRate", "HostTtl", "MaxHosts", "DnsFailureRefreshRate" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration for the dynamic forward proxy DNS cache. See the :ref:`architecture overview
  /// &lt;arch_overview_http_dynamic_forward_proxy>` for more information.
  /// [#next-free-field: 7]
  /// </summary>
  public sealed partial class DnsCacheConfig : pb::IMessage<DnsCacheConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DnsCacheConfig> _parser = new pb::MessageParser<DnsCacheConfig>(() => new DnsCacheConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DnsCacheConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Common.DynamicForwardProxy.V2Alpha.DnsCacheReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DnsCacheConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DnsCacheConfig(DnsCacheConfig other) : this() {
      name_ = other.name_;
      dnsLookupFamily_ = other.dnsLookupFamily_;
      dnsRefreshRate_ = other.dnsRefreshRate_ != null ? other.dnsRefreshRate_.Clone() : null;
      hostTtl_ = other.hostTtl_ != null ? other.hostTtl_.Clone() : null;
      MaxHosts = other.MaxHosts;
      dnsFailureRefreshRate_ = other.dnsFailureRefreshRate_ != null ? other.dnsFailureRefreshRate_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DnsCacheConfig Clone() {
      return new DnsCacheConfig(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the cache. Multiple named caches allow independent dynamic forward proxy
    /// configurations to operate within a single Envoy process using different configurations. All
    /// configurations with the same name *must* otherwise have the same settings when referenced
    /// from different configuration components. Configuration will fail to load if this is not
    /// the case.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "dns_lookup_family" field.</summary>
    public const int DnsLookupFamilyFieldNumber = 2;
    private global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily dnsLookupFamily_ = global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto;
    /// <summary>
    /// The DNS lookup family to use during resolution.
    ///
    /// [#comment:TODO(mattklein123): Figure out how to support IPv4/IPv6 "happy eyeballs" mode. The
    /// way this might work is a new lookup family which returns both IPv4 and IPv6 addresses, and
    /// then configures a host to have a primary and fall back address. With this, we could very
    /// likely build a "happy eyeballs" connection pool which would race the primary / fall back
    /// address and return the one that wins. This same method could potentially also be used for
    /// QUIC to TCP fall back.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily DnsLookupFamily {
      get { return dnsLookupFamily_; }
      set {
        dnsLookupFamily_ = value;
      }
    }

    /// <summary>Field number for the "dns_refresh_rate" field.</summary>
    public const int DnsRefreshRateFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration dnsRefreshRate_;
    /// <summary>
    /// The DNS refresh rate for currently cached DNS hosts. If not specified defaults to 60s.
    ///
    /// .. note:
    ///
    ///  The returned DNS TTL is not currently used to alter the refresh rate. This feature will be
    ///  added in a future change.
    ///
    /// .. note:
    ///
    /// The refresh rate is rounded to the closest millisecond, and must be at least 1ms.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration DnsRefreshRate {
      get { return dnsRefreshRate_; }
      set {
        dnsRefreshRate_ = value;
      }
    }

    /// <summary>Field number for the "host_ttl" field.</summary>
    public const int HostTtlFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration hostTtl_;
    /// <summary>
    /// The TTL for hosts that are unused. Hosts that have not been used in the configured time
    /// interval will be purged. If not specified defaults to 5m.
    ///
    /// .. note:
    ///
    ///   The TTL is only checked at the time of DNS refresh, as specified by *dns_refresh_rate*. This
    ///   means that if the configured TTL is shorter than the refresh rate the host may not be removed
    ///   immediately.
    ///
    ///  .. note:
    ///
    ///   The TTL has no relation to DNS TTL and is only used to control Envoy's resource usage.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration HostTtl {
      get { return hostTtl_; }
      set {
        hostTtl_ = value;
      }
    }

    /// <summary>Field number for the "max_hosts" field.</summary>
    public const int MaxHostsFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_maxHosts_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? maxHosts_;
    /// <summary>
    /// The maximum number of hosts that the cache will hold. If not specified defaults to 1024.
    ///
    /// .. note:
    ///
    ///   The implementation is approximate and enforced independently on each worker thread, thus
    ///   it is possible for the maximum hosts in the cache to go slightly above the configured
    ///   value depending on timing. This is similar to how other circuit breakers work.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxHosts {
      get { return maxHosts_; }
      set {
        maxHosts_ = value;
      }
    }


    /// <summary>Field number for the "dns_failure_refresh_rate" field.</summary>
    public const int DnsFailureRefreshRateFieldNumber = 6;
    private global::Envoy.Api.V2.Cluster.Types.RefreshRate dnsFailureRefreshRate_;
    /// <summary>
    /// If the DNS failure refresh rate is specified,
    /// this is used as the cache's DNS refresh rate when DNS requests are failing. If this setting is
    /// not specified, the failure refresh rate defaults to the dns_refresh_rate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Cluster.Types.RefreshRate DnsFailureRefreshRate {
      get { return dnsFailureRefreshRate_; }
      set {
        dnsFailureRefreshRate_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DnsCacheConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DnsCacheConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DnsLookupFamily != other.DnsLookupFamily) return false;
      if (!object.Equals(DnsRefreshRate, other.DnsRefreshRate)) return false;
      if (!object.Equals(HostTtl, other.HostTtl)) return false;
      if (MaxHosts != other.MaxHosts) return false;
      if (!object.Equals(DnsFailureRefreshRate, other.DnsFailureRefreshRate)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) hash ^= DnsLookupFamily.GetHashCode();
      if (dnsRefreshRate_ != null) hash ^= DnsRefreshRate.GetHashCode();
      if (hostTtl_ != null) hash ^= HostTtl.GetHashCode();
      if (maxHosts_ != null) hash ^= MaxHosts.GetHashCode();
      if (dnsFailureRefreshRate_ != null) hash ^= DnsFailureRefreshRate.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DnsLookupFamily);
      }
      if (dnsRefreshRate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(DnsRefreshRate);
      }
      if (hostTtl_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(HostTtl);
      }
      if (maxHosts_ != null) {
        _single_maxHosts_codec.WriteTagAndValue(output, MaxHosts);
      }
      if (dnsFailureRefreshRate_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(DnsFailureRefreshRate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DnsLookupFamily);
      }
      if (dnsRefreshRate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(DnsRefreshRate);
      }
      if (hostTtl_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(HostTtl);
      }
      if (maxHosts_ != null) {
        _single_maxHosts_codec.WriteTagAndValue(ref output, MaxHosts);
      }
      if (dnsFailureRefreshRate_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(DnsFailureRefreshRate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DnsLookupFamily);
      }
      if (dnsRefreshRate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DnsRefreshRate);
      }
      if (hostTtl_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HostTtl);
      }
      if (maxHosts_ != null) {
        size += _single_maxHosts_codec.CalculateSizeWithTag(MaxHosts);
      }
      if (dnsFailureRefreshRate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DnsFailureRefreshRate);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DnsCacheConfig other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) {
        DnsLookupFamily = other.DnsLookupFamily;
      }
      if (other.dnsRefreshRate_ != null) {
        if (dnsRefreshRate_ == null) {
          DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DnsRefreshRate.MergeFrom(other.DnsRefreshRate);
      }
      if (other.hostTtl_ != null) {
        if (hostTtl_ == null) {
          HostTtl = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        HostTtl.MergeFrom(other.HostTtl);
      }
      if (other.maxHosts_ != null) {
        if (maxHosts_ == null || other.MaxHosts != 0) {
          MaxHosts = other.MaxHosts;
        }
      }
      if (other.dnsFailureRefreshRate_ != null) {
        if (dnsFailureRefreshRate_ == null) {
          DnsFailureRefreshRate = new global::Envoy.Api.V2.Cluster.Types.RefreshRate();
        }
        DnsFailureRefreshRate.MergeFrom(other.DnsFailureRefreshRate);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            DnsLookupFamily = (global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily) input.ReadEnum();
            break;
          }
          case 26: {
            if (dnsRefreshRate_ == null) {
              DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DnsRefreshRate);
            break;
          }
          case 34: {
            if (hostTtl_ == null) {
              HostTtl = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(HostTtl);
            break;
          }
          case 42: {
            uint? value = _single_maxHosts_codec.Read(input);
            if (maxHosts_ == null || value != 0) {
              MaxHosts = value;
            }
            break;
          }
          case 50: {
            if (dnsFailureRefreshRate_ == null) {
              DnsFailureRefreshRate = new global::Envoy.Api.V2.Cluster.Types.RefreshRate();
            }
            input.ReadMessage(DnsFailureRefreshRate);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            DnsLookupFamily = (global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily) input.ReadEnum();
            break;
          }
          case 26: {
            if (dnsRefreshRate_ == null) {
              DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DnsRefreshRate);
            break;
          }
          case 34: {
            if (hostTtl_ == null) {
              HostTtl = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(HostTtl);
            break;
          }
          case 42: {
            uint? value = _single_maxHosts_codec.Read(ref input);
            if (maxHosts_ == null || value != 0) {
              MaxHosts = value;
            }
            break;
          }
          case 50: {
            if (dnsFailureRefreshRate_ == null) {
              DnsFailureRefreshRate = new global::Envoy.Api.V2.Cluster.Types.RefreshRate();
            }
            input.ReadMessage(DnsFailureRefreshRate);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
