// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/rbac/v3/rbac.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Rbac.V3 {

  /// <summary>Holder for reflection information generated from envoy/config/rbac/v3/rbac.proto</summary>
  public static partial class RbacReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/rbac/v3/rbac.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RbacReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ch9lbnZveS9jb25maWcvcmJhYy92My9yYmFjLnByb3RvEhRlbnZveS5jb25m",
            "aWcucmJhYy52MxoiZW52b3kvY29uZmlnL2NvcmUvdjMvYWRkcmVzcy5wcm90",
            "bxokZW52b3kvY29uZmlnL2NvcmUvdjMvZXh0ZW5zaW9uLnByb3RvGixlbnZv",
            "eS9jb25maWcvcm91dGUvdjMvcm91dGVfY29tcG9uZW50cy5wcm90bxokZW52",
            "b3kvdHlwZS9tYXRjaGVyL3YzL21ldGFkYXRhLnByb3RvGiBlbnZveS90eXBl",
            "L21hdGNoZXIvdjMvcGF0aC5wcm90bxoiZW52b3kvdHlwZS9tYXRjaGVyL3Yz",
            "L3N0cmluZy5wcm90bxoZZW52b3kvdHlwZS92My9yYW5nZS5wcm90bxomZ29v",
            "Z2xlL2FwaS9leHByL3YxYWxwaGExL2NoZWNrZWQucHJvdG8aJWdvb2dsZS9h",
            "cGkvZXhwci92MWFscGhhMS9zeW50YXgucHJvdG8aI2Vudm95L2Fubm90YXRp",
            "b25zL2RlcHJlY2F0aW9uLnByb3RvGh51ZHBhL2Fubm90YXRpb25zL21pZ3Jh",
            "dGUucHJvdG8aHXVkcGEvYW5ub3RhdGlvbnMvc3RhdHVzLnByb3RvGiF1ZHBh",
            "L2Fubm90YXRpb25zL3ZlcnNpb25pbmcucHJvdG8aF3ZhbGlkYXRlL3ZhbGlk",
            "YXRlLnByb3RvIpgCCgRSQkFDEjsKBmFjdGlvbhgBIAEoDjIhLmVudm95LmNv",
            "bmZpZy5yYmFjLnYzLlJCQUMuQWN0aW9uQgj6QgWCAQIQARI6Cghwb2xpY2ll",
            "cxgCIAMoCzIoLmVudm95LmNvbmZpZy5yYmFjLnYzLlJCQUMuUG9saWNpZXNF",
            "bnRyeRpNCg1Qb2xpY2llc0VudHJ5EgsKA2tleRgBIAEoCRIrCgV2YWx1ZRgC",
            "IAEoCzIcLmVudm95LmNvbmZpZy5yYmFjLnYzLlBvbGljeToCOAEiJgoGQWN0",
            "aW9uEgkKBUFMTE9XEAASCAoEREVOWRABEgcKA0xPRxACOiCaxYgeGwoZZW52",
            "b3kuY29uZmlnLnJiYWMudjIuUkJBQyLdAgoGUG9saWN5Ej8KC3Blcm1pc3Np",
            "b25zGAEgAygLMiAuZW52b3kuY29uZmlnLnJiYWMudjMuUGVybWlzc2lvbkII",
            "+kIFkgECCAESPQoKcHJpbmNpcGFscxgCIAMoCzIfLmVudm95LmNvbmZpZy5y",
            "YmFjLnYzLlByaW5jaXBhbEII+kIFkgECCAESTwoJY29uZGl0aW9uGAMgASgL",
            "Mh4uZ29vZ2xlLmFwaS5leHByLnYxYWxwaGExLkV4cHJCHPKY/o8FFhIUZXhw",
            "cmVzc2lvbl9zcGVjaWZpZXISXgoRY2hlY2tlZF9jb25kaXRpb24YBCABKAsy",
            "JS5nb29nbGUuYXBpLmV4cHIudjFhbHBoYTEuQ2hlY2tlZEV4cHJCHPKY/o8F",
            "FhIUZXhwcmVzc2lvbl9zcGVjaWZpZXI6IprFiB4dChtlbnZveS5jb25maWcu",
            "cmJhYy52Mi5Qb2xpY3kiwwYKClBlcm1pc3Npb24SOQoJYW5kX3J1bGVzGAEg",
            "ASgLMiQuZW52b3kuY29uZmlnLnJiYWMudjMuUGVybWlzc2lvbi5TZXRIABI4",
            "Cghvcl9ydWxlcxgCIAEoCzIkLmVudm95LmNvbmZpZy5yYmFjLnYzLlBlcm1p",
            "c3Npb24uU2V0SAASFgoDYW55GAMgASgIQgf6QgRqAggBSAASNgoGaGVhZGVy",
            "GAQgASgLMiQuZW52b3kuY29uZmlnLnJvdXRlLnYzLkhlYWRlck1hdGNoZXJI",
            "ABI2Cgh1cmxfcGF0aBgKIAEoCzIiLmVudm95LnR5cGUubWF0Y2hlci52My5Q",
            "YXRoTWF0Y2hlckgAEjkKDmRlc3RpbmF0aW9uX2lwGAUgASgLMh8uZW52b3ku",
            "Y29uZmlnLmNvcmUudjMuQ2lkclJhbmdlSAASJQoQZGVzdGluYXRpb25fcG9y",
            "dBgGIAEoDUIJ+kIGKgQY//8DSAASOwoWZGVzdGluYXRpb25fcG9ydF9yYW5n",
            "ZRgLIAEoCzIZLmVudm95LnR5cGUudjMuSW50MzJSYW5nZUgAEjoKCG1ldGFk",
            "YXRhGAcgASgLMiYuZW52b3kudHlwZS5tYXRjaGVyLnYzLk1ldGFkYXRhTWF0",
            "Y2hlckgAEjQKCG5vdF9ydWxlGAggASgLMiAuZW52b3kuY29uZmlnLnJiYWMu",
            "djMuUGVybWlzc2lvbkgAEkUKFXJlcXVlc3RlZF9zZXJ2ZXJfbmFtZRgJIAEo",
            "CzIkLmVudm95LnR5cGUubWF0Y2hlci52My5TdHJpbmdNYXRjaGVySAASPQoH",
            "bWF0Y2hlchgMIAEoCzIqLmVudm95LmNvbmZpZy5jb3JlLnYzLlR5cGVkRXh0",
            "ZW5zaW9uQ29uZmlnSAAabAoDU2V0EjkKBXJ1bGVzGAEgAygLMiAuZW52b3ku",
            "Y29uZmlnLnJiYWMudjMuUGVybWlzc2lvbkII+kIFkgECCAE6KprFiB4lCiNl",
            "bnZveS5jb25maWcucmJhYy52Mi5QZXJtaXNzaW9uLlNldDommsWIHiEKH2Vu",
            "dm95LmNvbmZpZy5yYmFjLnYyLlBlcm1pc3Npb25CCwoEcnVsZRID+EIBIp4H",
            "CglQcmluY2lwYWwSNgoHYW5kX2lkcxgBIAEoCzIjLmVudm95LmNvbmZpZy5y",
            "YmFjLnYzLlByaW5jaXBhbC5TZXRIABI1CgZvcl9pZHMYAiABKAsyIy5lbnZv",
            "eS5jb25maWcucmJhYy52My5QcmluY2lwYWwuU2V0SAASFgoDYW55GAMgASgI",
            "Qgf6QgRqAggBSAASRgoNYXV0aGVudGljYXRlZBgEIAEoCzItLmVudm95LmNv",
            "bmZpZy5yYmFjLnYzLlByaW5jaXBhbC5BdXRoZW50aWNhdGVkSAASQQoJc291",
            "cmNlX2lwGAUgASgLMh8uZW52b3kuY29uZmlnLmNvcmUudjMuQ2lkclJhbmdl",
            "QgsYAZLHhtgEAzMuMEgAEjsKEGRpcmVjdF9yZW1vdGVfaXAYCiABKAsyHy5l",
            "bnZveS5jb25maWcuY29yZS52My5DaWRyUmFuZ2VIABI0CglyZW1vdGVfaXAY",
            "CyABKAsyHy5lbnZveS5jb25maWcuY29yZS52My5DaWRyUmFuZ2VIABI2CgZo",
            "ZWFkZXIYBiABKAsyJC5lbnZveS5jb25maWcucm91dGUudjMuSGVhZGVyTWF0",
            "Y2hlckgAEjYKCHVybF9wYXRoGAkgASgLMiIuZW52b3kudHlwZS5tYXRjaGVy",
            "LnYzLlBhdGhNYXRjaGVySAASOgoIbWV0YWRhdGEYByABKAsyJi5lbnZveS50",
            "eXBlLm1hdGNoZXIudjMuTWV0YWRhdGFNYXRjaGVySAASMQoGbm90X2lkGAgg",
            "ASgLMh8uZW52b3kuY29uZmlnLnJiYWMudjMuUHJpbmNpcGFsSAAaaAoDU2V0",
            "EjYKA2lkcxgBIAMoCzIfLmVudm95LmNvbmZpZy5yYmFjLnYzLlByaW5jaXBh",
            "bEII+kIFkgECCAE6KZrFiB4kCiJlbnZveS5jb25maWcucmJhYy52Mi5Qcmlu",
            "Y2lwYWwuU2V0GogBCg1BdXRoZW50aWNhdGVkEjwKDnByaW5jaXBhbF9uYW1l",
            "GAIgASgLMiQuZW52b3kudHlwZS5tYXRjaGVyLnYzLlN0cmluZ01hdGNoZXI6",
            "M5rFiB4uCixlbnZveS5jb25maWcucmJhYy52Mi5QcmluY2lwYWwuQXV0aGVu",
            "dGljYXRlZEoECAEQAjolmsWIHiAKHmVudm95LmNvbmZpZy5yYmFjLnYyLlBy",
            "aW5jaXBhbEIRCgppZGVudGlmaWVyEgP4QgFCOQoiaW8uZW52b3lwcm94eS5l",
            "bnZveS5jb25maWcucmJhYy52M0IJUmJhY1Byb3RvUAG6gMjRBgIQAmIGcHJv",
            "dG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Core.V3.AddressReflection.Descriptor, global::Envoy.Config.Core.V3.ExtensionReflection.Descriptor, global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor, global::Envoy.Type.Matcher.V3.MetadataReflection.Descriptor, global::Envoy.Type.Matcher.V3.PathReflection.Descriptor, global::Envoy.Type.Matcher.V3.StringReflection.Descriptor, global::Envoy.Type.V3.RangeReflection.Descriptor, global::Google.Api.Expr.V1Alpha1.CheckedReflection.Descriptor, global::Google.Api.Expr.V1Alpha1.SyntaxReflection.Descriptor, global::Envoy.Annotations.DeprecationReflection.Descriptor, global::Udpa.Annotations.MigrateReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V3.RBAC), global::Envoy.Config.Rbac.V3.RBAC.Parser, new[]{ "Action", "Policies" }, null, new[]{ typeof(global::Envoy.Config.Rbac.V3.RBAC.Types.Action) }, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V3.Policy), global::Envoy.Config.Rbac.V3.Policy.Parser, new[]{ "Permissions", "Principals", "Condition", "CheckedCondition" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V3.Permission), global::Envoy.Config.Rbac.V3.Permission.Parser, new[]{ "AndRules", "OrRules", "Any", "Header", "UrlPath", "DestinationIp", "DestinationPort", "DestinationPortRange", "Metadata", "NotRule", "RequestedServerName", "Matcher" }, new[]{ "Rule" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V3.Permission.Types.Set), global::Envoy.Config.Rbac.V3.Permission.Types.Set.Parser, new[]{ "Rules" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V3.Principal), global::Envoy.Config.Rbac.V3.Principal.Parser, new[]{ "AndIds", "OrIds", "Any", "Authenticated", "SourceIp", "DirectRemoteIp", "RemoteIp", "Header", "UrlPath", "Metadata", "NotId" }, new[]{ "Identifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V3.Principal.Types.Set), global::Envoy.Config.Rbac.V3.Principal.Types.Set.Parser, new[]{ "Ids" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V3.Principal.Types.Authenticated), global::Envoy.Config.Rbac.V3.Principal.Types.Authenticated.Parser, new[]{ "PrincipalName" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Role Based Access Control (RBAC) provides service-level and method-level access control for a
  /// service. Requests are allowed or denied based on the `action` and whether a matching policy is
  /// found. For instance, if the action is ALLOW and a matching policy is found the request should be
  /// allowed.
  ///
  /// RBAC can also be used to make access logging decisions by communicating with access loggers
  /// through dynamic metadata. When the action is LOG and at least one policy matches, the
  /// `access_log_hint` value in the shared key namespace 'envoy.common' is set to `true` indicating
  /// the request should be logged.
  ///
  /// Here is an example of RBAC configuration. It has two policies:
  ///
  /// * Service account "cluster.local/ns/default/sa/admin" has full access to the service, and so
  ///   does "cluster.local/ns/default/sa/superuser".
  ///
  /// * Any user can read ("GET") the service at paths with prefix "/products", so long as the
  ///   destination port is either 80 or 443.
  ///
  ///  .. code-block:: yaml
  ///
  ///   action: ALLOW
  ///   policies:
  ///     "service-admin":
  ///       permissions:
  ///         - any: true
  ///       principals:
  ///         - authenticated:
  ///             principal_name:
  ///               exact: "cluster.local/ns/default/sa/admin"
  ///         - authenticated:
  ///             principal_name:
  ///               exact: "cluster.local/ns/default/sa/superuser"
  ///     "product-viewer":
  ///       permissions:
  ///           - and_rules:
  ///               rules:
  ///                 - header:
  ///                     name: ":method"
  ///                     string_match:
  ///                       exact: "GET"
  ///                 - url_path:
  ///                     path: { prefix: "/products" }
  ///                 - or_rules:
  ///                     rules:
  ///                       - destination_port: 80
  ///                       - destination_port: 443
  ///       principals:
  ///         - any: true
  ///
  /// </summary>
  public sealed partial class RBAC : pb::IMessage<RBAC>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RBAC> _parser = new pb::MessageParser<RBAC>(() => new RBAC());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RBAC> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V3.RbacReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RBAC() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RBAC(RBAC other) : this() {
      action_ = other.action_;
      policies_ = other.policies_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RBAC Clone() {
      return new RBAC(this);
    }

    /// <summary>Field number for the "action" field.</summary>
    public const int ActionFieldNumber = 1;
    private global::Envoy.Config.Rbac.V3.RBAC.Types.Action action_ = global::Envoy.Config.Rbac.V3.RBAC.Types.Action.Allow;
    /// <summary>
    /// The action to take if a policy matches. Every action either allows or denies a request,
    /// and can also carry out action-specific operations.
    ///
    /// Actions:
    ///
    ///  * ALLOW: Allows the request if and only if there is a policy that matches
    ///    the request.
    ///  * DENY: Allows the request if and only if there are no policies that
    ///    match the request.
    ///  * LOG: Allows all requests. If at least one policy matches, the dynamic
    ///    metadata key `access_log_hint` is set to the value `true` under the shared
    ///    key namespace 'envoy.common'. If no policies match, it is set to `false`.
    ///    Other actions do not modify this key.
    ///
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V3.RBAC.Types.Action Action {
      get { return action_; }
      set {
        action_ = value;
      }
    }

    /// <summary>Field number for the "policies" field.</summary>
    public const int PoliciesFieldNumber = 2;
    private static readonly pbc::MapField<string, global::Envoy.Config.Rbac.V3.Policy>.Codec _map_policies_codec
        = new pbc::MapField<string, global::Envoy.Config.Rbac.V3.Policy>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Envoy.Config.Rbac.V3.Policy.Parser), 18);
    private readonly pbc::MapField<string, global::Envoy.Config.Rbac.V3.Policy> policies_ = new pbc::MapField<string, global::Envoy.Config.Rbac.V3.Policy>();
    /// <summary>
    /// Maps from policy name to policy. A match occurs when at least one policy matches the request.
    /// The policies are evaluated in lexicographic order of the policy name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Envoy.Config.Rbac.V3.Policy> Policies {
      get { return policies_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RBAC);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RBAC other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Action != other.Action) return false;
      if (!Policies.Equals(other.Policies)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Action != global::Envoy.Config.Rbac.V3.RBAC.Types.Action.Allow) hash ^= Action.GetHashCode();
      hash ^= Policies.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Action != global::Envoy.Config.Rbac.V3.RBAC.Types.Action.Allow) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Action);
      }
      policies_.WriteTo(output, _map_policies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Action != global::Envoy.Config.Rbac.V3.RBAC.Types.Action.Allow) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Action);
      }
      policies_.WriteTo(ref output, _map_policies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Action != global::Envoy.Config.Rbac.V3.RBAC.Types.Action.Allow) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Action);
      }
      size += policies_.CalculateSize(_map_policies_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RBAC other) {
      if (other == null) {
        return;
      }
      if (other.Action != global::Envoy.Config.Rbac.V3.RBAC.Types.Action.Allow) {
        Action = other.Action;
      }
      policies_.Add(other.policies_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Action = (global::Envoy.Config.Rbac.V3.RBAC.Types.Action) input.ReadEnum();
            break;
          }
          case 18: {
            policies_.AddEntriesFrom(input, _map_policies_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Action = (global::Envoy.Config.Rbac.V3.RBAC.Types.Action) input.ReadEnum();
            break;
          }
          case 18: {
            policies_.AddEntriesFrom(ref input, _map_policies_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the RBAC message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Should we do safe-list or block-list style access control?
      /// </summary>
      public enum Action {
        /// <summary>
        /// The policies grant access to principals. The rest are denied. This is safe-list style
        /// access control. This is the default type.
        /// </summary>
        [pbr::OriginalName("ALLOW")] Allow = 0,
        /// <summary>
        /// The policies deny access to principals. The rest are allowed. This is block-list style
        /// access control.
        /// </summary>
        [pbr::OriginalName("DENY")] Deny = 1,
        /// <summary>
        /// The policies set the `access_log_hint` dynamic metadata key based on if requests match.
        /// All requests are allowed.
        /// </summary>
        [pbr::OriginalName("LOG")] Log = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Policy specifies a role and the principals that are assigned/denied the role.
  /// A policy matches if and only if at least one of its permissions match the
  /// action taking place AND at least one of its principals match the downstream
  /// AND the condition is true if specified.
  /// </summary>
  public sealed partial class Policy : pb::IMessage<Policy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Policy> _parser = new pb::MessageParser<Policy>(() => new Policy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Policy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V3.RbacReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Policy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Policy(Policy other) : this() {
      permissions_ = other.permissions_.Clone();
      principals_ = other.principals_.Clone();
      condition_ = other.condition_ != null ? other.condition_.Clone() : null;
      checkedCondition_ = other.checkedCondition_ != null ? other.checkedCondition_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Policy Clone() {
      return new Policy(this);
    }

    /// <summary>Field number for the "permissions" field.</summary>
    public const int PermissionsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V3.Permission> _repeated_permissions_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Rbac.V3.Permission.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V3.Permission> permissions_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V3.Permission>();
    /// <summary>
    /// Required. The set of permissions that define a role. Each permission is
    /// matched with OR semantics. To match all actions for this policy, a single
    /// Permission with the `any` field set to true should be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Rbac.V3.Permission> Permissions {
      get { return permissions_; }
    }

    /// <summary>Field number for the "principals" field.</summary>
    public const int PrincipalsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V3.Principal> _repeated_principals_codec
        = pb::FieldCodec.ForMessage(18, global::Envoy.Config.Rbac.V3.Principal.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V3.Principal> principals_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V3.Principal>();
    /// <summary>
    /// Required. The set of principals that are assigned/denied the role based on
    /// “action”. Each principal is matched with OR semantics. To match all
    /// downstreams for this policy, a single Principal with the `any` field set to
    /// true should be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Rbac.V3.Principal> Principals {
      get { return principals_; }
    }

    /// <summary>Field number for the "condition" field.</summary>
    public const int ConditionFieldNumber = 3;
    private global::Google.Api.Expr.V1Alpha1.Expr condition_;
    /// <summary>
    /// An optional symbolic expression specifying an access control
    /// :ref:`condition &lt;arch_overview_condition>`. The condition is combined
    /// with the permissions and the principals as a clause with AND semantics.
    /// Only be used when checked_condition is not used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Api.Expr.V1Alpha1.Expr Condition {
      get { return condition_; }
      set {
        condition_ = value;
      }
    }

    /// <summary>Field number for the "checked_condition" field.</summary>
    public const int CheckedConditionFieldNumber = 4;
    private global::Google.Api.Expr.V1Alpha1.CheckedExpr checkedCondition_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// An optional symbolic expression that has been successfully type checked.
    /// Only be used when condition is not used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Api.Expr.V1Alpha1.CheckedExpr CheckedCondition {
      get { return checkedCondition_; }
      set {
        checkedCondition_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Policy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Policy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!permissions_.Equals(other.permissions_)) return false;
      if(!principals_.Equals(other.principals_)) return false;
      if (!object.Equals(Condition, other.Condition)) return false;
      if (!object.Equals(CheckedCondition, other.CheckedCondition)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= permissions_.GetHashCode();
      hash ^= principals_.GetHashCode();
      if (condition_ != null) hash ^= Condition.GetHashCode();
      if (checkedCondition_ != null) hash ^= CheckedCondition.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      permissions_.WriteTo(output, _repeated_permissions_codec);
      principals_.WriteTo(output, _repeated_principals_codec);
      if (condition_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Condition);
      }
      if (checkedCondition_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(CheckedCondition);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      permissions_.WriteTo(ref output, _repeated_permissions_codec);
      principals_.WriteTo(ref output, _repeated_principals_codec);
      if (condition_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Condition);
      }
      if (checkedCondition_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(CheckedCondition);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += permissions_.CalculateSize(_repeated_permissions_codec);
      size += principals_.CalculateSize(_repeated_principals_codec);
      if (condition_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Condition);
      }
      if (checkedCondition_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CheckedCondition);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Policy other) {
      if (other == null) {
        return;
      }
      permissions_.Add(other.permissions_);
      principals_.Add(other.principals_);
      if (other.condition_ != null) {
        if (condition_ == null) {
          Condition = new global::Google.Api.Expr.V1Alpha1.Expr();
        }
        Condition.MergeFrom(other.Condition);
      }
      if (other.checkedCondition_ != null) {
        if (checkedCondition_ == null) {
          CheckedCondition = new global::Google.Api.Expr.V1Alpha1.CheckedExpr();
        }
        CheckedCondition.MergeFrom(other.CheckedCondition);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            permissions_.AddEntriesFrom(input, _repeated_permissions_codec);
            break;
          }
          case 18: {
            principals_.AddEntriesFrom(input, _repeated_principals_codec);
            break;
          }
          case 26: {
            if (condition_ == null) {
              Condition = new global::Google.Api.Expr.V1Alpha1.Expr();
            }
            input.ReadMessage(Condition);
            break;
          }
          case 34: {
            if (checkedCondition_ == null) {
              CheckedCondition = new global::Google.Api.Expr.V1Alpha1.CheckedExpr();
            }
            input.ReadMessage(CheckedCondition);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            permissions_.AddEntriesFrom(ref input, _repeated_permissions_codec);
            break;
          }
          case 18: {
            principals_.AddEntriesFrom(ref input, _repeated_principals_codec);
            break;
          }
          case 26: {
            if (condition_ == null) {
              Condition = new global::Google.Api.Expr.V1Alpha1.Expr();
            }
            input.ReadMessage(Condition);
            break;
          }
          case 34: {
            if (checkedCondition_ == null) {
              CheckedCondition = new global::Google.Api.Expr.V1Alpha1.CheckedExpr();
            }
            input.ReadMessage(CheckedCondition);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Permission defines an action (or actions) that a principal can take.
  /// [#next-free-field: 13]
  /// </summary>
  public sealed partial class Permission : pb::IMessage<Permission>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Permission> _parser = new pb::MessageParser<Permission>(() => new Permission());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Permission> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V3.RbacReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Permission() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Permission(Permission other) : this() {
      switch (other.RuleCase) {
        case RuleOneofCase.AndRules:
          AndRules = other.AndRules.Clone();
          break;
        case RuleOneofCase.OrRules:
          OrRules = other.OrRules.Clone();
          break;
        case RuleOneofCase.Any:
          Any = other.Any;
          break;
        case RuleOneofCase.Header:
          Header = other.Header.Clone();
          break;
        case RuleOneofCase.UrlPath:
          UrlPath = other.UrlPath.Clone();
          break;
        case RuleOneofCase.DestinationIp:
          DestinationIp = other.DestinationIp.Clone();
          break;
        case RuleOneofCase.DestinationPort:
          DestinationPort = other.DestinationPort;
          break;
        case RuleOneofCase.DestinationPortRange:
          DestinationPortRange = other.DestinationPortRange.Clone();
          break;
        case RuleOneofCase.Metadata:
          Metadata = other.Metadata.Clone();
          break;
        case RuleOneofCase.NotRule:
          NotRule = other.NotRule.Clone();
          break;
        case RuleOneofCase.RequestedServerName:
          RequestedServerName = other.RequestedServerName.Clone();
          break;
        case RuleOneofCase.Matcher:
          Matcher = other.Matcher.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Permission Clone() {
      return new Permission(this);
    }

    /// <summary>Field number for the "and_rules" field.</summary>
    public const int AndRulesFieldNumber = 1;
    /// <summary>
    /// A set of rules that all must match in order to define the action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V3.Permission.Types.Set AndRules {
      get { return ruleCase_ == RuleOneofCase.AndRules ? (global::Envoy.Config.Rbac.V3.Permission.Types.Set) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.AndRules;
      }
    }

    /// <summary>Field number for the "or_rules" field.</summary>
    public const int OrRulesFieldNumber = 2;
    /// <summary>
    /// A set of rules where at least one must match in order to define the action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V3.Permission.Types.Set OrRules {
      get { return ruleCase_ == RuleOneofCase.OrRules ? (global::Envoy.Config.Rbac.V3.Permission.Types.Set) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.OrRules;
      }
    }

    /// <summary>Field number for the "any" field.</summary>
    public const int AnyFieldNumber = 3;
    /// <summary>
    /// When any is set, it matches any action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Any {
      get { return ruleCase_ == RuleOneofCase.Any ? (bool) rule_ : false; }
      set {
        rule_ = value;
        ruleCase_ = RuleOneofCase.Any;
      }
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 4;
    /// <summary>
    /// A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
    /// available for HTTP request.
    /// Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
    /// field if you want to match the URL path without the query and fragment string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.HeaderMatcher Header {
      get { return ruleCase_ == RuleOneofCase.Header ? (global::Envoy.Config.Route.V3.HeaderMatcher) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.Header;
      }
    }

    /// <summary>Field number for the "url_path" field.</summary>
    public const int UrlPathFieldNumber = 10;
    /// <summary>
    /// A URL path on the incoming HTTP request. Only available for HTTP.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.PathMatcher UrlPath {
      get { return ruleCase_ == RuleOneofCase.UrlPath ? (global::Envoy.Type.Matcher.V3.PathMatcher) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.UrlPath;
      }
    }

    /// <summary>Field number for the "destination_ip" field.</summary>
    public const int DestinationIpFieldNumber = 5;
    /// <summary>
    /// A CIDR block that describes the destination IP.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.CidrRange DestinationIp {
      get { return ruleCase_ == RuleOneofCase.DestinationIp ? (global::Envoy.Config.Core.V3.CidrRange) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.DestinationIp;
      }
    }

    /// <summary>Field number for the "destination_port" field.</summary>
    public const int DestinationPortFieldNumber = 6;
    /// <summary>
    /// A port number that describes the destination port connecting to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint DestinationPort {
      get { return ruleCase_ == RuleOneofCase.DestinationPort ? (uint) rule_ : 0; }
      set {
        rule_ = value;
        ruleCase_ = RuleOneofCase.DestinationPort;
      }
    }

    /// <summary>Field number for the "destination_port_range" field.</summary>
    public const int DestinationPortRangeFieldNumber = 11;
    /// <summary>
    /// A port number range that describes a range of destination ports connecting to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.V3.Int32Range DestinationPortRange {
      get { return ruleCase_ == RuleOneofCase.DestinationPortRange ? (global::Envoy.Type.V3.Int32Range) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.DestinationPortRange;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 7;
    /// <summary>
    /// Metadata that describes additional information about the action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.MetadataMatcher Metadata {
      get { return ruleCase_ == RuleOneofCase.Metadata ? (global::Envoy.Type.Matcher.V3.MetadataMatcher) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.Metadata;
      }
    }

    /// <summary>Field number for the "not_rule" field.</summary>
    public const int NotRuleFieldNumber = 8;
    /// <summary>
    /// Negates matching the provided permission. For instance, if the value of
    /// `not_rule` would match, this permission would not match. Conversely, if
    /// the value of `not_rule` would not match, this permission would match.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V3.Permission NotRule {
      get { return ruleCase_ == RuleOneofCase.NotRule ? (global::Envoy.Config.Rbac.V3.Permission) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.NotRule;
      }
    }

    /// <summary>Field number for the "requested_server_name" field.</summary>
    public const int RequestedServerNameFieldNumber = 9;
    /// <summary>
    /// The request server from the client's connection request. This is
    /// typically TLS SNI.
    ///
    /// .. attention::
    ///
    ///   The behavior of this field may be affected by how Envoy is configured
    ///   as explained below.
    ///
    ///   * If the :ref:`TLS Inspector &lt;config_listener_filters_tls_inspector>`
    ///     filter is not added, and if a `FilterChainMatch` is not defined for
    ///     the :ref:`server name
    ///     &lt;envoy_v3_api_field_config.listener.v3.FilterChainMatch.server_names>`,
    ///     a TLS connection's requested SNI server name will be treated as if it
    ///     wasn't present.
    ///
    ///   * A :ref:`listener filter &lt;arch_overview_listener_filters>` may
    ///     overwrite a connection's requested server name within Envoy.
    ///
    /// Please refer to :ref:`this FAQ entry &lt;faq_how_to_setup_sni>` to learn to
    /// setup SNI.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.StringMatcher RequestedServerName {
      get { return ruleCase_ == RuleOneofCase.RequestedServerName ? (global::Envoy.Type.Matcher.V3.StringMatcher) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.RequestedServerName;
      }
    }

    /// <summary>Field number for the "matcher" field.</summary>
    public const int MatcherFieldNumber = 12;
    /// <summary>
    /// Extension for configuring custom matchers for RBAC.
    /// [#extension-category: envoy.rbac.matchers]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TypedExtensionConfig Matcher {
      get { return ruleCase_ == RuleOneofCase.Matcher ? (global::Envoy.Config.Core.V3.TypedExtensionConfig) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.Matcher;
      }
    }

    private object rule_;
    /// <summary>Enum of possible cases for the "rule" oneof.</summary>
    public enum RuleOneofCase {
      None = 0,
      AndRules = 1,
      OrRules = 2,
      Any = 3,
      Header = 4,
      UrlPath = 10,
      DestinationIp = 5,
      DestinationPort = 6,
      DestinationPortRange = 11,
      Metadata = 7,
      NotRule = 8,
      RequestedServerName = 9,
      Matcher = 12,
    }
    private RuleOneofCase ruleCase_ = RuleOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RuleOneofCase RuleCase {
      get { return ruleCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRule() {
      ruleCase_ = RuleOneofCase.None;
      rule_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Permission);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Permission other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AndRules, other.AndRules)) return false;
      if (!object.Equals(OrRules, other.OrRules)) return false;
      if (Any != other.Any) return false;
      if (!object.Equals(Header, other.Header)) return false;
      if (!object.Equals(UrlPath, other.UrlPath)) return false;
      if (!object.Equals(DestinationIp, other.DestinationIp)) return false;
      if (DestinationPort != other.DestinationPort) return false;
      if (!object.Equals(DestinationPortRange, other.DestinationPortRange)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(NotRule, other.NotRule)) return false;
      if (!object.Equals(RequestedServerName, other.RequestedServerName)) return false;
      if (!object.Equals(Matcher, other.Matcher)) return false;
      if (RuleCase != other.RuleCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ruleCase_ == RuleOneofCase.AndRules) hash ^= AndRules.GetHashCode();
      if (ruleCase_ == RuleOneofCase.OrRules) hash ^= OrRules.GetHashCode();
      if (ruleCase_ == RuleOneofCase.Any) hash ^= Any.GetHashCode();
      if (ruleCase_ == RuleOneofCase.Header) hash ^= Header.GetHashCode();
      if (ruleCase_ == RuleOneofCase.UrlPath) hash ^= UrlPath.GetHashCode();
      if (ruleCase_ == RuleOneofCase.DestinationIp) hash ^= DestinationIp.GetHashCode();
      if (ruleCase_ == RuleOneofCase.DestinationPort) hash ^= DestinationPort.GetHashCode();
      if (ruleCase_ == RuleOneofCase.DestinationPortRange) hash ^= DestinationPortRange.GetHashCode();
      if (ruleCase_ == RuleOneofCase.Metadata) hash ^= Metadata.GetHashCode();
      if (ruleCase_ == RuleOneofCase.NotRule) hash ^= NotRule.GetHashCode();
      if (ruleCase_ == RuleOneofCase.RequestedServerName) hash ^= RequestedServerName.GetHashCode();
      if (ruleCase_ == RuleOneofCase.Matcher) hash ^= Matcher.GetHashCode();
      hash ^= (int) ruleCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ruleCase_ == RuleOneofCase.AndRules) {
        output.WriteRawTag(10);
        output.WriteMessage(AndRules);
      }
      if (ruleCase_ == RuleOneofCase.OrRules) {
        output.WriteRawTag(18);
        output.WriteMessage(OrRules);
      }
      if (ruleCase_ == RuleOneofCase.Any) {
        output.WriteRawTag(24);
        output.WriteBool(Any);
      }
      if (ruleCase_ == RuleOneofCase.Header) {
        output.WriteRawTag(34);
        output.WriteMessage(Header);
      }
      if (ruleCase_ == RuleOneofCase.DestinationIp) {
        output.WriteRawTag(42);
        output.WriteMessage(DestinationIp);
      }
      if (ruleCase_ == RuleOneofCase.DestinationPort) {
        output.WriteRawTag(48);
        output.WriteUInt32(DestinationPort);
      }
      if (ruleCase_ == RuleOneofCase.Metadata) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (ruleCase_ == RuleOneofCase.NotRule) {
        output.WriteRawTag(66);
        output.WriteMessage(NotRule);
      }
      if (ruleCase_ == RuleOneofCase.RequestedServerName) {
        output.WriteRawTag(74);
        output.WriteMessage(RequestedServerName);
      }
      if (ruleCase_ == RuleOneofCase.UrlPath) {
        output.WriteRawTag(82);
        output.WriteMessage(UrlPath);
      }
      if (ruleCase_ == RuleOneofCase.DestinationPortRange) {
        output.WriteRawTag(90);
        output.WriteMessage(DestinationPortRange);
      }
      if (ruleCase_ == RuleOneofCase.Matcher) {
        output.WriteRawTag(98);
        output.WriteMessage(Matcher);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ruleCase_ == RuleOneofCase.AndRules) {
        output.WriteRawTag(10);
        output.WriteMessage(AndRules);
      }
      if (ruleCase_ == RuleOneofCase.OrRules) {
        output.WriteRawTag(18);
        output.WriteMessage(OrRules);
      }
      if (ruleCase_ == RuleOneofCase.Any) {
        output.WriteRawTag(24);
        output.WriteBool(Any);
      }
      if (ruleCase_ == RuleOneofCase.Header) {
        output.WriteRawTag(34);
        output.WriteMessage(Header);
      }
      if (ruleCase_ == RuleOneofCase.DestinationIp) {
        output.WriteRawTag(42);
        output.WriteMessage(DestinationIp);
      }
      if (ruleCase_ == RuleOneofCase.DestinationPort) {
        output.WriteRawTag(48);
        output.WriteUInt32(DestinationPort);
      }
      if (ruleCase_ == RuleOneofCase.Metadata) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (ruleCase_ == RuleOneofCase.NotRule) {
        output.WriteRawTag(66);
        output.WriteMessage(NotRule);
      }
      if (ruleCase_ == RuleOneofCase.RequestedServerName) {
        output.WriteRawTag(74);
        output.WriteMessage(RequestedServerName);
      }
      if (ruleCase_ == RuleOneofCase.UrlPath) {
        output.WriteRawTag(82);
        output.WriteMessage(UrlPath);
      }
      if (ruleCase_ == RuleOneofCase.DestinationPortRange) {
        output.WriteRawTag(90);
        output.WriteMessage(DestinationPortRange);
      }
      if (ruleCase_ == RuleOneofCase.Matcher) {
        output.WriteRawTag(98);
        output.WriteMessage(Matcher);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ruleCase_ == RuleOneofCase.AndRules) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AndRules);
      }
      if (ruleCase_ == RuleOneofCase.OrRules) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OrRules);
      }
      if (ruleCase_ == RuleOneofCase.Any) {
        size += 1 + 1;
      }
      if (ruleCase_ == RuleOneofCase.Header) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (ruleCase_ == RuleOneofCase.UrlPath) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UrlPath);
      }
      if (ruleCase_ == RuleOneofCase.DestinationIp) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DestinationIp);
      }
      if (ruleCase_ == RuleOneofCase.DestinationPort) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DestinationPort);
      }
      if (ruleCase_ == RuleOneofCase.DestinationPortRange) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DestinationPortRange);
      }
      if (ruleCase_ == RuleOneofCase.Metadata) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (ruleCase_ == RuleOneofCase.NotRule) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NotRule);
      }
      if (ruleCase_ == RuleOneofCase.RequestedServerName) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequestedServerName);
      }
      if (ruleCase_ == RuleOneofCase.Matcher) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Matcher);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Permission other) {
      if (other == null) {
        return;
      }
      switch (other.RuleCase) {
        case RuleOneofCase.AndRules:
          if (AndRules == null) {
            AndRules = new global::Envoy.Config.Rbac.V3.Permission.Types.Set();
          }
          AndRules.MergeFrom(other.AndRules);
          break;
        case RuleOneofCase.OrRules:
          if (OrRules == null) {
            OrRules = new global::Envoy.Config.Rbac.V3.Permission.Types.Set();
          }
          OrRules.MergeFrom(other.OrRules);
          break;
        case RuleOneofCase.Any:
          Any = other.Any;
          break;
        case RuleOneofCase.Header:
          if (Header == null) {
            Header = new global::Envoy.Config.Route.V3.HeaderMatcher();
          }
          Header.MergeFrom(other.Header);
          break;
        case RuleOneofCase.UrlPath:
          if (UrlPath == null) {
            UrlPath = new global::Envoy.Type.Matcher.V3.PathMatcher();
          }
          UrlPath.MergeFrom(other.UrlPath);
          break;
        case RuleOneofCase.DestinationIp:
          if (DestinationIp == null) {
            DestinationIp = new global::Envoy.Config.Core.V3.CidrRange();
          }
          DestinationIp.MergeFrom(other.DestinationIp);
          break;
        case RuleOneofCase.DestinationPort:
          DestinationPort = other.DestinationPort;
          break;
        case RuleOneofCase.DestinationPortRange:
          if (DestinationPortRange == null) {
            DestinationPortRange = new global::Envoy.Type.V3.Int32Range();
          }
          DestinationPortRange.MergeFrom(other.DestinationPortRange);
          break;
        case RuleOneofCase.Metadata:
          if (Metadata == null) {
            Metadata = new global::Envoy.Type.Matcher.V3.MetadataMatcher();
          }
          Metadata.MergeFrom(other.Metadata);
          break;
        case RuleOneofCase.NotRule:
          if (NotRule == null) {
            NotRule = new global::Envoy.Config.Rbac.V3.Permission();
          }
          NotRule.MergeFrom(other.NotRule);
          break;
        case RuleOneofCase.RequestedServerName:
          if (RequestedServerName == null) {
            RequestedServerName = new global::Envoy.Type.Matcher.V3.StringMatcher();
          }
          RequestedServerName.MergeFrom(other.RequestedServerName);
          break;
        case RuleOneofCase.Matcher:
          if (Matcher == null) {
            Matcher = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
          }
          Matcher.MergeFrom(other.Matcher);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Envoy.Config.Rbac.V3.Permission.Types.Set subBuilder = new global::Envoy.Config.Rbac.V3.Permission.Types.Set();
            if (ruleCase_ == RuleOneofCase.AndRules) {
              subBuilder.MergeFrom(AndRules);
            }
            input.ReadMessage(subBuilder);
            AndRules = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Config.Rbac.V3.Permission.Types.Set subBuilder = new global::Envoy.Config.Rbac.V3.Permission.Types.Set();
            if (ruleCase_ == RuleOneofCase.OrRules) {
              subBuilder.MergeFrom(OrRules);
            }
            input.ReadMessage(subBuilder);
            OrRules = subBuilder;
            break;
          }
          case 24: {
            Any = input.ReadBool();
            break;
          }
          case 34: {
            global::Envoy.Config.Route.V3.HeaderMatcher subBuilder = new global::Envoy.Config.Route.V3.HeaderMatcher();
            if (ruleCase_ == RuleOneofCase.Header) {
              subBuilder.MergeFrom(Header);
            }
            input.ReadMessage(subBuilder);
            Header = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Config.Core.V3.CidrRange subBuilder = new global::Envoy.Config.Core.V3.CidrRange();
            if (ruleCase_ == RuleOneofCase.DestinationIp) {
              subBuilder.MergeFrom(DestinationIp);
            }
            input.ReadMessage(subBuilder);
            DestinationIp = subBuilder;
            break;
          }
          case 48: {
            DestinationPort = input.ReadUInt32();
            break;
          }
          case 58: {
            global::Envoy.Type.Matcher.V3.MetadataMatcher subBuilder = new global::Envoy.Type.Matcher.V3.MetadataMatcher();
            if (ruleCase_ == RuleOneofCase.Metadata) {
              subBuilder.MergeFrom(Metadata);
            }
            input.ReadMessage(subBuilder);
            Metadata = subBuilder;
            break;
          }
          case 66: {
            global::Envoy.Config.Rbac.V3.Permission subBuilder = new global::Envoy.Config.Rbac.V3.Permission();
            if (ruleCase_ == RuleOneofCase.NotRule) {
              subBuilder.MergeFrom(NotRule);
            }
            input.ReadMessage(subBuilder);
            NotRule = subBuilder;
            break;
          }
          case 74: {
            global::Envoy.Type.Matcher.V3.StringMatcher subBuilder = new global::Envoy.Type.Matcher.V3.StringMatcher();
            if (ruleCase_ == RuleOneofCase.RequestedServerName) {
              subBuilder.MergeFrom(RequestedServerName);
            }
            input.ReadMessage(subBuilder);
            RequestedServerName = subBuilder;
            break;
          }
          case 82: {
            global::Envoy.Type.Matcher.V3.PathMatcher subBuilder = new global::Envoy.Type.Matcher.V3.PathMatcher();
            if (ruleCase_ == RuleOneofCase.UrlPath) {
              subBuilder.MergeFrom(UrlPath);
            }
            input.ReadMessage(subBuilder);
            UrlPath = subBuilder;
            break;
          }
          case 90: {
            global::Envoy.Type.V3.Int32Range subBuilder = new global::Envoy.Type.V3.Int32Range();
            if (ruleCase_ == RuleOneofCase.DestinationPortRange) {
              subBuilder.MergeFrom(DestinationPortRange);
            }
            input.ReadMessage(subBuilder);
            DestinationPortRange = subBuilder;
            break;
          }
          case 98: {
            global::Envoy.Config.Core.V3.TypedExtensionConfig subBuilder = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            if (ruleCase_ == RuleOneofCase.Matcher) {
              subBuilder.MergeFrom(Matcher);
            }
            input.ReadMessage(subBuilder);
            Matcher = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Envoy.Config.Rbac.V3.Permission.Types.Set subBuilder = new global::Envoy.Config.Rbac.V3.Permission.Types.Set();
            if (ruleCase_ == RuleOneofCase.AndRules) {
              subBuilder.MergeFrom(AndRules);
            }
            input.ReadMessage(subBuilder);
            AndRules = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Config.Rbac.V3.Permission.Types.Set subBuilder = new global::Envoy.Config.Rbac.V3.Permission.Types.Set();
            if (ruleCase_ == RuleOneofCase.OrRules) {
              subBuilder.MergeFrom(OrRules);
            }
            input.ReadMessage(subBuilder);
            OrRules = subBuilder;
            break;
          }
          case 24: {
            Any = input.ReadBool();
            break;
          }
          case 34: {
            global::Envoy.Config.Route.V3.HeaderMatcher subBuilder = new global::Envoy.Config.Route.V3.HeaderMatcher();
            if (ruleCase_ == RuleOneofCase.Header) {
              subBuilder.MergeFrom(Header);
            }
            input.ReadMessage(subBuilder);
            Header = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Config.Core.V3.CidrRange subBuilder = new global::Envoy.Config.Core.V3.CidrRange();
            if (ruleCase_ == RuleOneofCase.DestinationIp) {
              subBuilder.MergeFrom(DestinationIp);
            }
            input.ReadMessage(subBuilder);
            DestinationIp = subBuilder;
            break;
          }
          case 48: {
            DestinationPort = input.ReadUInt32();
            break;
          }
          case 58: {
            global::Envoy.Type.Matcher.V3.MetadataMatcher subBuilder = new global::Envoy.Type.Matcher.V3.MetadataMatcher();
            if (ruleCase_ == RuleOneofCase.Metadata) {
              subBuilder.MergeFrom(Metadata);
            }
            input.ReadMessage(subBuilder);
            Metadata = subBuilder;
            break;
          }
          case 66: {
            global::Envoy.Config.Rbac.V3.Permission subBuilder = new global::Envoy.Config.Rbac.V3.Permission();
            if (ruleCase_ == RuleOneofCase.NotRule) {
              subBuilder.MergeFrom(NotRule);
            }
            input.ReadMessage(subBuilder);
            NotRule = subBuilder;
            break;
          }
          case 74: {
            global::Envoy.Type.Matcher.V3.StringMatcher subBuilder = new global::Envoy.Type.Matcher.V3.StringMatcher();
            if (ruleCase_ == RuleOneofCase.RequestedServerName) {
              subBuilder.MergeFrom(RequestedServerName);
            }
            input.ReadMessage(subBuilder);
            RequestedServerName = subBuilder;
            break;
          }
          case 82: {
            global::Envoy.Type.Matcher.V3.PathMatcher subBuilder = new global::Envoy.Type.Matcher.V3.PathMatcher();
            if (ruleCase_ == RuleOneofCase.UrlPath) {
              subBuilder.MergeFrom(UrlPath);
            }
            input.ReadMessage(subBuilder);
            UrlPath = subBuilder;
            break;
          }
          case 90: {
            global::Envoy.Type.V3.Int32Range subBuilder = new global::Envoy.Type.V3.Int32Range();
            if (ruleCase_ == RuleOneofCase.DestinationPortRange) {
              subBuilder.MergeFrom(DestinationPortRange);
            }
            input.ReadMessage(subBuilder);
            DestinationPortRange = subBuilder;
            break;
          }
          case 98: {
            global::Envoy.Config.Core.V3.TypedExtensionConfig subBuilder = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            if (ruleCase_ == RuleOneofCase.Matcher) {
              subBuilder.MergeFrom(Matcher);
            }
            input.ReadMessage(subBuilder);
            Matcher = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Permission message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Used in the `and_rules` and `or_rules` fields in the `rule` oneof. Depending on the context,
      /// each are applied with the associated behavior.
      /// </summary>
      public sealed partial class Set : pb::IMessage<Set>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Set> _parser = new pb::MessageParser<Set>(() => new Set());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Set> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Rbac.V3.Permission.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Set() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Set(Set other) : this() {
          rules_ = other.rules_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Set Clone() {
          return new Set(this);
        }

        /// <summary>Field number for the "rules" field.</summary>
        public const int RulesFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V3.Permission> _repeated_rules_codec
            = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Rbac.V3.Permission.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V3.Permission> rules_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V3.Permission>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Envoy.Config.Rbac.V3.Permission> Rules {
          get { return rules_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Set);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Set other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!rules_.Equals(other.rules_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= rules_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          rules_.WriteTo(output, _repeated_rules_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          rules_.WriteTo(ref output, _repeated_rules_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          size += rules_.CalculateSize(_repeated_rules_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Set other) {
          if (other == null) {
            return;
          }
          rules_.Add(other.rules_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                rules_.AddEntriesFrom(input, _repeated_rules_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                rules_.AddEntriesFrom(ref input, _repeated_rules_codec);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Principal defines an identity or a group of identities for a downstream
  /// subject.
  /// [#next-free-field: 12]
  /// </summary>
  public sealed partial class Principal : pb::IMessage<Principal>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Principal> _parser = new pb::MessageParser<Principal>(() => new Principal());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Principal> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V3.RbacReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Principal() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Principal(Principal other) : this() {
      switch (other.IdentifierCase) {
        case IdentifierOneofCase.AndIds:
          AndIds = other.AndIds.Clone();
          break;
        case IdentifierOneofCase.OrIds:
          OrIds = other.OrIds.Clone();
          break;
        case IdentifierOneofCase.Any:
          Any = other.Any;
          break;
        case IdentifierOneofCase.Authenticated:
          Authenticated = other.Authenticated.Clone();
          break;
        case IdentifierOneofCase.SourceIp:
          SourceIp = other.SourceIp.Clone();
          break;
        case IdentifierOneofCase.DirectRemoteIp:
          DirectRemoteIp = other.DirectRemoteIp.Clone();
          break;
        case IdentifierOneofCase.RemoteIp:
          RemoteIp = other.RemoteIp.Clone();
          break;
        case IdentifierOneofCase.Header:
          Header = other.Header.Clone();
          break;
        case IdentifierOneofCase.UrlPath:
          UrlPath = other.UrlPath.Clone();
          break;
        case IdentifierOneofCase.Metadata:
          Metadata = other.Metadata.Clone();
          break;
        case IdentifierOneofCase.NotId:
          NotId = other.NotId.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Principal Clone() {
      return new Principal(this);
    }

    /// <summary>Field number for the "and_ids" field.</summary>
    public const int AndIdsFieldNumber = 1;
    /// <summary>
    /// A set of identifiers that all must match in order to define the
    /// downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V3.Principal.Types.Set AndIds {
      get { return identifierCase_ == IdentifierOneofCase.AndIds ? (global::Envoy.Config.Rbac.V3.Principal.Types.Set) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.AndIds;
      }
    }

    /// <summary>Field number for the "or_ids" field.</summary>
    public const int OrIdsFieldNumber = 2;
    /// <summary>
    /// A set of identifiers at least one must match in order to define the
    /// downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V3.Principal.Types.Set OrIds {
      get { return identifierCase_ == IdentifierOneofCase.OrIds ? (global::Envoy.Config.Rbac.V3.Principal.Types.Set) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.OrIds;
      }
    }

    /// <summary>Field number for the "any" field.</summary>
    public const int AnyFieldNumber = 3;
    /// <summary>
    /// When any is set, it matches any downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Any {
      get { return identifierCase_ == IdentifierOneofCase.Any ? (bool) identifier_ : false; }
      set {
        identifier_ = value;
        identifierCase_ = IdentifierOneofCase.Any;
      }
    }

    /// <summary>Field number for the "authenticated" field.</summary>
    public const int AuthenticatedFieldNumber = 4;
    /// <summary>
    /// Authenticated attributes that identify the downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V3.Principal.Types.Authenticated Authenticated {
      get { return identifierCase_ == IdentifierOneofCase.Authenticated ? (global::Envoy.Config.Rbac.V3.Principal.Types.Authenticated) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.Authenticated;
      }
    }

    /// <summary>Field number for the "source_ip" field.</summary>
    public const int SourceIpFieldNumber = 5;
    /// <summary>
    /// A CIDR block that describes the downstream IP.
    /// This address will honor proxy protocol, but will not honor XFF.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.CidrRange SourceIp {
      get { return identifierCase_ == IdentifierOneofCase.SourceIp ? (global::Envoy.Config.Core.V3.CidrRange) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.SourceIp;
      }
    }

    /// <summary>Field number for the "direct_remote_ip" field.</summary>
    public const int DirectRemoteIpFieldNumber = 10;
    /// <summary>
    /// A CIDR block that describes the downstream remote/origin address.
    /// Note: This is always the physical peer even if the
    /// :ref:`remote_ip &lt;envoy_v3_api_field_config.rbac.v3.Principal.remote_ip>` is
    /// inferred from for example the x-forwarder-for header, proxy protocol,
    /// etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.CidrRange DirectRemoteIp {
      get { return identifierCase_ == IdentifierOneofCase.DirectRemoteIp ? (global::Envoy.Config.Core.V3.CidrRange) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.DirectRemoteIp;
      }
    }

    /// <summary>Field number for the "remote_ip" field.</summary>
    public const int RemoteIpFieldNumber = 11;
    /// <summary>
    /// A CIDR block that describes the downstream remote/origin address.
    /// Note: This may not be the physical peer and could be different from the
    /// :ref:`direct_remote_ip
    /// &lt;envoy_v3_api_field_config.rbac.v3.Principal.direct_remote_ip>`. E.g, if the
    /// remote ip is inferred from for example the x-forwarder-for header, proxy
    /// protocol, etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.CidrRange RemoteIp {
      get { return identifierCase_ == IdentifierOneofCase.RemoteIp ? (global::Envoy.Config.Core.V3.CidrRange) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.RemoteIp;
      }
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 6;
    /// <summary>
    /// A header (or pseudo-header such as :path or :method) on the incoming HTTP
    /// request. Only available for HTTP request. Note: the pseudo-header :path
    /// includes the query and fragment string. Use the `url_path` field if you
    /// want to match the URL path without the query and fragment string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.HeaderMatcher Header {
      get { return identifierCase_ == IdentifierOneofCase.Header ? (global::Envoy.Config.Route.V3.HeaderMatcher) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.Header;
      }
    }

    /// <summary>Field number for the "url_path" field.</summary>
    public const int UrlPathFieldNumber = 9;
    /// <summary>
    /// A URL path on the incoming HTTP request. Only available for HTTP.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.PathMatcher UrlPath {
      get { return identifierCase_ == IdentifierOneofCase.UrlPath ? (global::Envoy.Type.Matcher.V3.PathMatcher) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.UrlPath;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 7;
    /// <summary>
    /// Metadata that describes additional information about the principal.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.MetadataMatcher Metadata {
      get { return identifierCase_ == IdentifierOneofCase.Metadata ? (global::Envoy.Type.Matcher.V3.MetadataMatcher) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.Metadata;
      }
    }

    /// <summary>Field number for the "not_id" field.</summary>
    public const int NotIdFieldNumber = 8;
    /// <summary>
    /// Negates matching the provided principal. For instance, if the value of
    /// `not_id` would match, this principal would not match. Conversely, if the
    /// value of `not_id` would not match, this principal would match.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V3.Principal NotId {
      get { return identifierCase_ == IdentifierOneofCase.NotId ? (global::Envoy.Config.Rbac.V3.Principal) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.NotId;
      }
    }

    private object identifier_;
    /// <summary>Enum of possible cases for the "identifier" oneof.</summary>
    public enum IdentifierOneofCase {
      None = 0,
      AndIds = 1,
      OrIds = 2,
      Any = 3,
      Authenticated = 4,
      SourceIp = 5,
      DirectRemoteIp = 10,
      RemoteIp = 11,
      Header = 6,
      UrlPath = 9,
      Metadata = 7,
      NotId = 8,
    }
    private IdentifierOneofCase identifierCase_ = IdentifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IdentifierOneofCase IdentifierCase {
      get { return identifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIdentifier() {
      identifierCase_ = IdentifierOneofCase.None;
      identifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Principal);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Principal other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AndIds, other.AndIds)) return false;
      if (!object.Equals(OrIds, other.OrIds)) return false;
      if (Any != other.Any) return false;
      if (!object.Equals(Authenticated, other.Authenticated)) return false;
      if (!object.Equals(SourceIp, other.SourceIp)) return false;
      if (!object.Equals(DirectRemoteIp, other.DirectRemoteIp)) return false;
      if (!object.Equals(RemoteIp, other.RemoteIp)) return false;
      if (!object.Equals(Header, other.Header)) return false;
      if (!object.Equals(UrlPath, other.UrlPath)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(NotId, other.NotId)) return false;
      if (IdentifierCase != other.IdentifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (identifierCase_ == IdentifierOneofCase.AndIds) hash ^= AndIds.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.OrIds) hash ^= OrIds.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Any) hash ^= Any.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Authenticated) hash ^= Authenticated.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.SourceIp) hash ^= SourceIp.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.DirectRemoteIp) hash ^= DirectRemoteIp.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.RemoteIp) hash ^= RemoteIp.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Header) hash ^= Header.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.UrlPath) hash ^= UrlPath.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Metadata) hash ^= Metadata.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.NotId) hash ^= NotId.GetHashCode();
      hash ^= (int) identifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (identifierCase_ == IdentifierOneofCase.AndIds) {
        output.WriteRawTag(10);
        output.WriteMessage(AndIds);
      }
      if (identifierCase_ == IdentifierOneofCase.OrIds) {
        output.WriteRawTag(18);
        output.WriteMessage(OrIds);
      }
      if (identifierCase_ == IdentifierOneofCase.Any) {
        output.WriteRawTag(24);
        output.WriteBool(Any);
      }
      if (identifierCase_ == IdentifierOneofCase.Authenticated) {
        output.WriteRawTag(34);
        output.WriteMessage(Authenticated);
      }
      if (identifierCase_ == IdentifierOneofCase.SourceIp) {
        output.WriteRawTag(42);
        output.WriteMessage(SourceIp);
      }
      if (identifierCase_ == IdentifierOneofCase.Header) {
        output.WriteRawTag(50);
        output.WriteMessage(Header);
      }
      if (identifierCase_ == IdentifierOneofCase.Metadata) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (identifierCase_ == IdentifierOneofCase.NotId) {
        output.WriteRawTag(66);
        output.WriteMessage(NotId);
      }
      if (identifierCase_ == IdentifierOneofCase.UrlPath) {
        output.WriteRawTag(74);
        output.WriteMessage(UrlPath);
      }
      if (identifierCase_ == IdentifierOneofCase.DirectRemoteIp) {
        output.WriteRawTag(82);
        output.WriteMessage(DirectRemoteIp);
      }
      if (identifierCase_ == IdentifierOneofCase.RemoteIp) {
        output.WriteRawTag(90);
        output.WriteMessage(RemoteIp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (identifierCase_ == IdentifierOneofCase.AndIds) {
        output.WriteRawTag(10);
        output.WriteMessage(AndIds);
      }
      if (identifierCase_ == IdentifierOneofCase.OrIds) {
        output.WriteRawTag(18);
        output.WriteMessage(OrIds);
      }
      if (identifierCase_ == IdentifierOneofCase.Any) {
        output.WriteRawTag(24);
        output.WriteBool(Any);
      }
      if (identifierCase_ == IdentifierOneofCase.Authenticated) {
        output.WriteRawTag(34);
        output.WriteMessage(Authenticated);
      }
      if (identifierCase_ == IdentifierOneofCase.SourceIp) {
        output.WriteRawTag(42);
        output.WriteMessage(SourceIp);
      }
      if (identifierCase_ == IdentifierOneofCase.Header) {
        output.WriteRawTag(50);
        output.WriteMessage(Header);
      }
      if (identifierCase_ == IdentifierOneofCase.Metadata) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (identifierCase_ == IdentifierOneofCase.NotId) {
        output.WriteRawTag(66);
        output.WriteMessage(NotId);
      }
      if (identifierCase_ == IdentifierOneofCase.UrlPath) {
        output.WriteRawTag(74);
        output.WriteMessage(UrlPath);
      }
      if (identifierCase_ == IdentifierOneofCase.DirectRemoteIp) {
        output.WriteRawTag(82);
        output.WriteMessage(DirectRemoteIp);
      }
      if (identifierCase_ == IdentifierOneofCase.RemoteIp) {
        output.WriteRawTag(90);
        output.WriteMessage(RemoteIp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (identifierCase_ == IdentifierOneofCase.AndIds) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AndIds);
      }
      if (identifierCase_ == IdentifierOneofCase.OrIds) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OrIds);
      }
      if (identifierCase_ == IdentifierOneofCase.Any) {
        size += 1 + 1;
      }
      if (identifierCase_ == IdentifierOneofCase.Authenticated) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Authenticated);
      }
      if (identifierCase_ == IdentifierOneofCase.SourceIp) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceIp);
      }
      if (identifierCase_ == IdentifierOneofCase.DirectRemoteIp) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DirectRemoteIp);
      }
      if (identifierCase_ == IdentifierOneofCase.RemoteIp) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RemoteIp);
      }
      if (identifierCase_ == IdentifierOneofCase.Header) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (identifierCase_ == IdentifierOneofCase.UrlPath) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UrlPath);
      }
      if (identifierCase_ == IdentifierOneofCase.Metadata) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (identifierCase_ == IdentifierOneofCase.NotId) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NotId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Principal other) {
      if (other == null) {
        return;
      }
      switch (other.IdentifierCase) {
        case IdentifierOneofCase.AndIds:
          if (AndIds == null) {
            AndIds = new global::Envoy.Config.Rbac.V3.Principal.Types.Set();
          }
          AndIds.MergeFrom(other.AndIds);
          break;
        case IdentifierOneofCase.OrIds:
          if (OrIds == null) {
            OrIds = new global::Envoy.Config.Rbac.V3.Principal.Types.Set();
          }
          OrIds.MergeFrom(other.OrIds);
          break;
        case IdentifierOneofCase.Any:
          Any = other.Any;
          break;
        case IdentifierOneofCase.Authenticated:
          if (Authenticated == null) {
            Authenticated = new global::Envoy.Config.Rbac.V3.Principal.Types.Authenticated();
          }
          Authenticated.MergeFrom(other.Authenticated);
          break;
        case IdentifierOneofCase.SourceIp:
          if (SourceIp == null) {
            SourceIp = new global::Envoy.Config.Core.V3.CidrRange();
          }
          SourceIp.MergeFrom(other.SourceIp);
          break;
        case IdentifierOneofCase.DirectRemoteIp:
          if (DirectRemoteIp == null) {
            DirectRemoteIp = new global::Envoy.Config.Core.V3.CidrRange();
          }
          DirectRemoteIp.MergeFrom(other.DirectRemoteIp);
          break;
        case IdentifierOneofCase.RemoteIp:
          if (RemoteIp == null) {
            RemoteIp = new global::Envoy.Config.Core.V3.CidrRange();
          }
          RemoteIp.MergeFrom(other.RemoteIp);
          break;
        case IdentifierOneofCase.Header:
          if (Header == null) {
            Header = new global::Envoy.Config.Route.V3.HeaderMatcher();
          }
          Header.MergeFrom(other.Header);
          break;
        case IdentifierOneofCase.UrlPath:
          if (UrlPath == null) {
            UrlPath = new global::Envoy.Type.Matcher.V3.PathMatcher();
          }
          UrlPath.MergeFrom(other.UrlPath);
          break;
        case IdentifierOneofCase.Metadata:
          if (Metadata == null) {
            Metadata = new global::Envoy.Type.Matcher.V3.MetadataMatcher();
          }
          Metadata.MergeFrom(other.Metadata);
          break;
        case IdentifierOneofCase.NotId:
          if (NotId == null) {
            NotId = new global::Envoy.Config.Rbac.V3.Principal();
          }
          NotId.MergeFrom(other.NotId);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Envoy.Config.Rbac.V3.Principal.Types.Set subBuilder = new global::Envoy.Config.Rbac.V3.Principal.Types.Set();
            if (identifierCase_ == IdentifierOneofCase.AndIds) {
              subBuilder.MergeFrom(AndIds);
            }
            input.ReadMessage(subBuilder);
            AndIds = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Config.Rbac.V3.Principal.Types.Set subBuilder = new global::Envoy.Config.Rbac.V3.Principal.Types.Set();
            if (identifierCase_ == IdentifierOneofCase.OrIds) {
              subBuilder.MergeFrom(OrIds);
            }
            input.ReadMessage(subBuilder);
            OrIds = subBuilder;
            break;
          }
          case 24: {
            Any = input.ReadBool();
            break;
          }
          case 34: {
            global::Envoy.Config.Rbac.V3.Principal.Types.Authenticated subBuilder = new global::Envoy.Config.Rbac.V3.Principal.Types.Authenticated();
            if (identifierCase_ == IdentifierOneofCase.Authenticated) {
              subBuilder.MergeFrom(Authenticated);
            }
            input.ReadMessage(subBuilder);
            Authenticated = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Config.Core.V3.CidrRange subBuilder = new global::Envoy.Config.Core.V3.CidrRange();
            if (identifierCase_ == IdentifierOneofCase.SourceIp) {
              subBuilder.MergeFrom(SourceIp);
            }
            input.ReadMessage(subBuilder);
            SourceIp = subBuilder;
            break;
          }
          case 50: {
            global::Envoy.Config.Route.V3.HeaderMatcher subBuilder = new global::Envoy.Config.Route.V3.HeaderMatcher();
            if (identifierCase_ == IdentifierOneofCase.Header) {
              subBuilder.MergeFrom(Header);
            }
            input.ReadMessage(subBuilder);
            Header = subBuilder;
            break;
          }
          case 58: {
            global::Envoy.Type.Matcher.V3.MetadataMatcher subBuilder = new global::Envoy.Type.Matcher.V3.MetadataMatcher();
            if (identifierCase_ == IdentifierOneofCase.Metadata) {
              subBuilder.MergeFrom(Metadata);
            }
            input.ReadMessage(subBuilder);
            Metadata = subBuilder;
            break;
          }
          case 66: {
            global::Envoy.Config.Rbac.V3.Principal subBuilder = new global::Envoy.Config.Rbac.V3.Principal();
            if (identifierCase_ == IdentifierOneofCase.NotId) {
              subBuilder.MergeFrom(NotId);
            }
            input.ReadMessage(subBuilder);
            NotId = subBuilder;
            break;
          }
          case 74: {
            global::Envoy.Type.Matcher.V3.PathMatcher subBuilder = new global::Envoy.Type.Matcher.V3.PathMatcher();
            if (identifierCase_ == IdentifierOneofCase.UrlPath) {
              subBuilder.MergeFrom(UrlPath);
            }
            input.ReadMessage(subBuilder);
            UrlPath = subBuilder;
            break;
          }
          case 82: {
            global::Envoy.Config.Core.V3.CidrRange subBuilder = new global::Envoy.Config.Core.V3.CidrRange();
            if (identifierCase_ == IdentifierOneofCase.DirectRemoteIp) {
              subBuilder.MergeFrom(DirectRemoteIp);
            }
            input.ReadMessage(subBuilder);
            DirectRemoteIp = subBuilder;
            break;
          }
          case 90: {
            global::Envoy.Config.Core.V3.CidrRange subBuilder = new global::Envoy.Config.Core.V3.CidrRange();
            if (identifierCase_ == IdentifierOneofCase.RemoteIp) {
              subBuilder.MergeFrom(RemoteIp);
            }
            input.ReadMessage(subBuilder);
            RemoteIp = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Envoy.Config.Rbac.V3.Principal.Types.Set subBuilder = new global::Envoy.Config.Rbac.V3.Principal.Types.Set();
            if (identifierCase_ == IdentifierOneofCase.AndIds) {
              subBuilder.MergeFrom(AndIds);
            }
            input.ReadMessage(subBuilder);
            AndIds = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Config.Rbac.V3.Principal.Types.Set subBuilder = new global::Envoy.Config.Rbac.V3.Principal.Types.Set();
            if (identifierCase_ == IdentifierOneofCase.OrIds) {
              subBuilder.MergeFrom(OrIds);
            }
            input.ReadMessage(subBuilder);
            OrIds = subBuilder;
            break;
          }
          case 24: {
            Any = input.ReadBool();
            break;
          }
          case 34: {
            global::Envoy.Config.Rbac.V3.Principal.Types.Authenticated subBuilder = new global::Envoy.Config.Rbac.V3.Principal.Types.Authenticated();
            if (identifierCase_ == IdentifierOneofCase.Authenticated) {
              subBuilder.MergeFrom(Authenticated);
            }
            input.ReadMessage(subBuilder);
            Authenticated = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Config.Core.V3.CidrRange subBuilder = new global::Envoy.Config.Core.V3.CidrRange();
            if (identifierCase_ == IdentifierOneofCase.SourceIp) {
              subBuilder.MergeFrom(SourceIp);
            }
            input.ReadMessage(subBuilder);
            SourceIp = subBuilder;
            break;
          }
          case 50: {
            global::Envoy.Config.Route.V3.HeaderMatcher subBuilder = new global::Envoy.Config.Route.V3.HeaderMatcher();
            if (identifierCase_ == IdentifierOneofCase.Header) {
              subBuilder.MergeFrom(Header);
            }
            input.ReadMessage(subBuilder);
            Header = subBuilder;
            break;
          }
          case 58: {
            global::Envoy.Type.Matcher.V3.MetadataMatcher subBuilder = new global::Envoy.Type.Matcher.V3.MetadataMatcher();
            if (identifierCase_ == IdentifierOneofCase.Metadata) {
              subBuilder.MergeFrom(Metadata);
            }
            input.ReadMessage(subBuilder);
            Metadata = subBuilder;
            break;
          }
          case 66: {
            global::Envoy.Config.Rbac.V3.Principal subBuilder = new global::Envoy.Config.Rbac.V3.Principal();
            if (identifierCase_ == IdentifierOneofCase.NotId) {
              subBuilder.MergeFrom(NotId);
            }
            input.ReadMessage(subBuilder);
            NotId = subBuilder;
            break;
          }
          case 74: {
            global::Envoy.Type.Matcher.V3.PathMatcher subBuilder = new global::Envoy.Type.Matcher.V3.PathMatcher();
            if (identifierCase_ == IdentifierOneofCase.UrlPath) {
              subBuilder.MergeFrom(UrlPath);
            }
            input.ReadMessage(subBuilder);
            UrlPath = subBuilder;
            break;
          }
          case 82: {
            global::Envoy.Config.Core.V3.CidrRange subBuilder = new global::Envoy.Config.Core.V3.CidrRange();
            if (identifierCase_ == IdentifierOneofCase.DirectRemoteIp) {
              subBuilder.MergeFrom(DirectRemoteIp);
            }
            input.ReadMessage(subBuilder);
            DirectRemoteIp = subBuilder;
            break;
          }
          case 90: {
            global::Envoy.Config.Core.V3.CidrRange subBuilder = new global::Envoy.Config.Core.V3.CidrRange();
            if (identifierCase_ == IdentifierOneofCase.RemoteIp) {
              subBuilder.MergeFrom(RemoteIp);
            }
            input.ReadMessage(subBuilder);
            RemoteIp = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Principal message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Used in the `and_ids` and `or_ids` fields in the `identifier` oneof.
      /// Depending on the context, each are applied with the associated behavior.
      /// </summary>
      public sealed partial class Set : pb::IMessage<Set>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Set> _parser = new pb::MessageParser<Set>(() => new Set());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Set> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Rbac.V3.Principal.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Set() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Set(Set other) : this() {
          ids_ = other.ids_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Set Clone() {
          return new Set(this);
        }

        /// <summary>Field number for the "ids" field.</summary>
        public const int IdsFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V3.Principal> _repeated_ids_codec
            = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Rbac.V3.Principal.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V3.Principal> ids_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V3.Principal>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Envoy.Config.Rbac.V3.Principal> Ids {
          get { return ids_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Set);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Set other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!ids_.Equals(other.ids_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= ids_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          ids_.WriteTo(output, _repeated_ids_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          ids_.WriteTo(ref output, _repeated_ids_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          size += ids_.CalculateSize(_repeated_ids_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Set other) {
          if (other == null) {
            return;
          }
          ids_.Add(other.ids_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                ids_.AddEntriesFrom(input, _repeated_ids_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                ids_.AddEntriesFrom(ref input, _repeated_ids_codec);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Authentication attributes for a downstream.
      /// </summary>
      public sealed partial class Authenticated : pb::IMessage<Authenticated>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Authenticated> _parser = new pb::MessageParser<Authenticated>(() => new Authenticated());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Authenticated> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Rbac.V3.Principal.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Authenticated() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Authenticated(Authenticated other) : this() {
          principalName_ = other.principalName_ != null ? other.principalName_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Authenticated Clone() {
          return new Authenticated(this);
        }

        /// <summary>Field number for the "principal_name" field.</summary>
        public const int PrincipalNameFieldNumber = 2;
        private global::Envoy.Type.Matcher.V3.StringMatcher principalName_;
        /// <summary>
        /// The name of the principal. If set, The URI SAN or DNS SAN in that order
        /// is used from the certificate, otherwise the subject field is used. If
        /// unset, it applies to any user that is authenticated.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Type.Matcher.V3.StringMatcher PrincipalName {
          get { return principalName_; }
          set {
            principalName_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Authenticated);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Authenticated other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(PrincipalName, other.PrincipalName)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (principalName_ != null) hash ^= PrincipalName.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (principalName_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(PrincipalName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (principalName_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(PrincipalName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (principalName_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrincipalName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Authenticated other) {
          if (other == null) {
            return;
          }
          if (other.principalName_ != null) {
            if (principalName_ == null) {
              PrincipalName = new global::Envoy.Type.Matcher.V3.StringMatcher();
            }
            PrincipalName.MergeFrom(other.PrincipalName);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 18: {
                if (principalName_ == null) {
                  PrincipalName = new global::Envoy.Type.Matcher.V3.StringMatcher();
                }
                input.ReadMessage(PrincipalName);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 18: {
                if (principalName_ == null) {
                  PrincipalName = new global::Envoy.Type.Matcher.V3.StringMatcher();
                }
                input.ReadMessage(PrincipalName);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
