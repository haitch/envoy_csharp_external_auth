// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/extensions/compression/gzip/compressor/v3/gzip.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Extensions.Compression.Gzip.Compressor.V3 {

  /// <summary>Holder for reflection information generated from envoy/extensions/compression/gzip/compressor/v3/gzip.proto</summary>
  public static partial class GzipReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/extensions/compression/gzip/compressor/v3/gzip.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static GzipReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjplbnZveS9leHRlbnNpb25zL2NvbXByZXNzaW9uL2d6aXAvY29tcHJlc3Nv",
            "ci92My9nemlwLnByb3RvEi9lbnZveS5leHRlbnNpb25zLmNvbXByZXNzaW9u",
            "Lmd6aXAuY29tcHJlc3Nvci52MxoeZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJz",
            "LnByb3RvGh11ZHBhL2Fubm90YXRpb25zL3N0YXR1cy5wcm90bxoXdmFsaWRh",
            "dGUvdmFsaWRhdGUucHJvdG8ivQYKBEd6aXASPQoMbWVtb3J5X2xldmVsGAEg",
            "ASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlQgn6QgYqBBgJKAES",
            "awoRY29tcHJlc3Npb25fbGV2ZWwYAiABKA4yRi5lbnZveS5leHRlbnNpb25z",
            "LmNvbXByZXNzaW9uLmd6aXAuY29tcHJlc3Nvci52My5HemlwLkNvbXByZXNz",
            "aW9uTGV2ZWxCCPpCBYIBAhABEnEKFGNvbXByZXNzaW9uX3N0cmF0ZWd5GAMg",
            "ASgOMkkuZW52b3kuZXh0ZW5zaW9ucy5jb21wcmVzc2lvbi5nemlwLmNvbXBy",
            "ZXNzb3IudjMuR3ppcC5Db21wcmVzc2lvblN0cmF0ZWd5Qgj6QgWCAQIQARI8",
            "Cgt3aW5kb3dfYml0cxgEIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50MzJW",
            "YWx1ZUIJ+kIGKgQYDygJEj4KCmNodW5rX3NpemUYBSABKAsyHC5nb29nbGUu",
            "cHJvdG9idWYuVUludDMyVmFsdWVCDPpCCSoHGICABCiAICJfChNDb21wcmVz",
            "c2lvblN0cmF0ZWd5EhQKEERFRkFVTFRfU1RSQVRFR1kQABIMCghGSUxURVJF",
            "RBABEhAKDEhVRkZNQU5fT05MWRACEgcKA1JMRRADEgkKBUZJWEVEEAQitgIK",
            "EENvbXByZXNzaW9uTGV2ZWwSFwoTREVGQVVMVF9DT01QUkVTU0lPThAAEg4K",
            "CkJFU1RfU1BFRUQQARIXChNDT01QUkVTU0lPTl9MRVZFTF8xEAESFwoTQ09N",
            "UFJFU1NJT05fTEVWRUxfMhACEhcKE0NPTVBSRVNTSU9OX0xFVkVMXzMQAxIX",
            "ChNDT01QUkVTU0lPTl9MRVZFTF80EAQSFwoTQ09NUFJFU1NJT05fTEVWRUxf",
            "NRAFEhcKE0NPTVBSRVNTSU9OX0xFVkVMXzYQBhIXChNDT01QUkVTU0lPTl9M",
            "RVZFTF83EAcSFwoTQ09NUFJFU1NJT05fTEVWRUxfOBAIEhcKE0NPTVBSRVNT",
            "SU9OX0xFVkVMXzkQCRIUChBCRVNUX0NPTVBSRVNTSU9OEAkaAhABQlQKPWlv",
            "LmVudm95cHJveHkuZW52b3kuZXh0ZW5zaW9ucy5jb21wcmVzc2lvbi5nemlw",
            "LmNvbXByZXNzb3IudjNCCUd6aXBQcm90b1ABuoDI0QYCEAJiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip), global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Parser, new[]{ "MemoryLevel", "CompressionLevel", "CompressionStrategy", "WindowBits", "ChunkSize" }, null, new[]{ typeof(global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionStrategy), typeof(global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionLevel) }, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// [#next-free-field: 6]
  /// </summary>
  public sealed partial class Gzip : pb::IMessage<Gzip>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Gzip> _parser = new pb::MessageParser<Gzip>(() => new Gzip());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Gzip> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Compression.Gzip.Compressor.V3.GzipReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Gzip() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Gzip(Gzip other) : this() {
      MemoryLevel = other.MemoryLevel;
      compressionLevel_ = other.compressionLevel_;
      compressionStrategy_ = other.compressionStrategy_;
      WindowBits = other.WindowBits;
      ChunkSize = other.ChunkSize;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Gzip Clone() {
      return new Gzip(this);
    }

    /// <summary>Field number for the "memory_level" field.</summary>
    public const int MemoryLevelFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_memoryLevel_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? memoryLevel_;
    /// <summary>
    /// Value from 1 to 9 that controls the amount of internal memory used by zlib. Higher values
    /// use more memory, but are faster and produce better compression results. The default value is 5.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MemoryLevel {
      get { return memoryLevel_; }
      set {
        memoryLevel_ = value;
      }
    }


    /// <summary>Field number for the "compression_level" field.</summary>
    public const int CompressionLevelFieldNumber = 2;
    private global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionLevel compressionLevel_ = global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionLevel.DefaultCompression;
    /// <summary>
    /// A value used for selecting the zlib compression level. This setting will affect speed and
    /// amount of compression applied to the content. "BEST_COMPRESSION" provides higher compression
    /// at the cost of higher latency and is equal to "COMPRESSION_LEVEL_9". "BEST_SPEED" provides
    /// lower compression with minimum impact on response time, the same as "COMPRESSION_LEVEL_1".
    /// "DEFAULT_COMPRESSION" provides an optimal result between speed and compression. According
    /// to zlib's manual this level gives the same result as "COMPRESSION_LEVEL_6".
    /// This field will be set to "DEFAULT_COMPRESSION" if not specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionLevel CompressionLevel {
      get { return compressionLevel_; }
      set {
        compressionLevel_ = value;
      }
    }

    /// <summary>Field number for the "compression_strategy" field.</summary>
    public const int CompressionStrategyFieldNumber = 3;
    private global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionStrategy compressionStrategy_ = global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionStrategy.DefaultStrategy;
    /// <summary>
    /// A value used for selecting the zlib compression strategy which is directly related to the
    /// characteristics of the content. Most of the time "DEFAULT_STRATEGY" will be the best choice,
    /// which is also the default value for the parameter, though there are situations when
    /// changing this parameter might produce better results. For example, run-length encoding (RLE)
    /// is typically used when the content is known for having sequences which same data occurs many
    /// consecutive times. For more information about each strategy, please refer to zlib manual.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionStrategy CompressionStrategy {
      get { return compressionStrategy_; }
      set {
        compressionStrategy_ = value;
      }
    }

    /// <summary>Field number for the "window_bits" field.</summary>
    public const int WindowBitsFieldNumber = 4;
    private static readonly pb::FieldCodec<uint?> _single_windowBits_codec = pb::FieldCodec.ForStructWrapper<uint>(34);
    private uint? windowBits_;
    /// <summary>
    /// Value from 9 to 15 that represents the base two logarithmic of the compressor's window size.
    /// Larger window results in better compression at the expense of memory usage. The default is 12
    /// which will produce a 4096 bytes window. For more details about this parameter, please refer to
    /// zlib manual > deflateInit2.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? WindowBits {
      get { return windowBits_; }
      set {
        windowBits_ = value;
      }
    }


    /// <summary>Field number for the "chunk_size" field.</summary>
    public const int ChunkSizeFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_chunkSize_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? chunkSize_;
    /// <summary>
    /// Value for Zlib's next output buffer. If not set, defaults to 4096.
    /// See https://www.zlib.net/manual.html for more details. Also see
    /// https://github.com/envoyproxy/envoy/issues/8448 for context on this filter's performance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? ChunkSize {
      get { return chunkSize_; }
      set {
        chunkSize_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Gzip);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Gzip other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MemoryLevel != other.MemoryLevel) return false;
      if (CompressionLevel != other.CompressionLevel) return false;
      if (CompressionStrategy != other.CompressionStrategy) return false;
      if (WindowBits != other.WindowBits) return false;
      if (ChunkSize != other.ChunkSize) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (memoryLevel_ != null) hash ^= MemoryLevel.GetHashCode();
      if (CompressionLevel != global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionLevel.DefaultCompression) hash ^= CompressionLevel.GetHashCode();
      if (CompressionStrategy != global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionStrategy.DefaultStrategy) hash ^= CompressionStrategy.GetHashCode();
      if (windowBits_ != null) hash ^= WindowBits.GetHashCode();
      if (chunkSize_ != null) hash ^= ChunkSize.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (memoryLevel_ != null) {
        _single_memoryLevel_codec.WriteTagAndValue(output, MemoryLevel);
      }
      if (CompressionLevel != global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionLevel.DefaultCompression) {
        output.WriteRawTag(16);
        output.WriteEnum((int) CompressionLevel);
      }
      if (CompressionStrategy != global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionStrategy.DefaultStrategy) {
        output.WriteRawTag(24);
        output.WriteEnum((int) CompressionStrategy);
      }
      if (windowBits_ != null) {
        _single_windowBits_codec.WriteTagAndValue(output, WindowBits);
      }
      if (chunkSize_ != null) {
        _single_chunkSize_codec.WriteTagAndValue(output, ChunkSize);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (memoryLevel_ != null) {
        _single_memoryLevel_codec.WriteTagAndValue(ref output, MemoryLevel);
      }
      if (CompressionLevel != global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionLevel.DefaultCompression) {
        output.WriteRawTag(16);
        output.WriteEnum((int) CompressionLevel);
      }
      if (CompressionStrategy != global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionStrategy.DefaultStrategy) {
        output.WriteRawTag(24);
        output.WriteEnum((int) CompressionStrategy);
      }
      if (windowBits_ != null) {
        _single_windowBits_codec.WriteTagAndValue(ref output, WindowBits);
      }
      if (chunkSize_ != null) {
        _single_chunkSize_codec.WriteTagAndValue(ref output, ChunkSize);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (memoryLevel_ != null) {
        size += _single_memoryLevel_codec.CalculateSizeWithTag(MemoryLevel);
      }
      if (CompressionLevel != global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionLevel.DefaultCompression) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CompressionLevel);
      }
      if (CompressionStrategy != global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionStrategy.DefaultStrategy) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CompressionStrategy);
      }
      if (windowBits_ != null) {
        size += _single_windowBits_codec.CalculateSizeWithTag(WindowBits);
      }
      if (chunkSize_ != null) {
        size += _single_chunkSize_codec.CalculateSizeWithTag(ChunkSize);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Gzip other) {
      if (other == null) {
        return;
      }
      if (other.memoryLevel_ != null) {
        if (memoryLevel_ == null || other.MemoryLevel != 0) {
          MemoryLevel = other.MemoryLevel;
        }
      }
      if (other.CompressionLevel != global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionLevel.DefaultCompression) {
        CompressionLevel = other.CompressionLevel;
      }
      if (other.CompressionStrategy != global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionStrategy.DefaultStrategy) {
        CompressionStrategy = other.CompressionStrategy;
      }
      if (other.windowBits_ != null) {
        if (windowBits_ == null || other.WindowBits != 0) {
          WindowBits = other.WindowBits;
        }
      }
      if (other.chunkSize_ != null) {
        if (chunkSize_ == null || other.ChunkSize != 0) {
          ChunkSize = other.ChunkSize;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_memoryLevel_codec.Read(input);
            if (memoryLevel_ == null || value != 0) {
              MemoryLevel = value;
            }
            break;
          }
          case 16: {
            CompressionLevel = (global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionLevel) input.ReadEnum();
            break;
          }
          case 24: {
            CompressionStrategy = (global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionStrategy) input.ReadEnum();
            break;
          }
          case 34: {
            uint? value = _single_windowBits_codec.Read(input);
            if (windowBits_ == null || value != 0) {
              WindowBits = value;
            }
            break;
          }
          case 42: {
            uint? value = _single_chunkSize_codec.Read(input);
            if (chunkSize_ == null || value != 0) {
              ChunkSize = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            uint? value = _single_memoryLevel_codec.Read(ref input);
            if (memoryLevel_ == null || value != 0) {
              MemoryLevel = value;
            }
            break;
          }
          case 16: {
            CompressionLevel = (global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionLevel) input.ReadEnum();
            break;
          }
          case 24: {
            CompressionStrategy = (global::Envoy.Extensions.Compression.Gzip.Compressor.V3.Gzip.Types.CompressionStrategy) input.ReadEnum();
            break;
          }
          case 34: {
            uint? value = _single_windowBits_codec.Read(ref input);
            if (windowBits_ == null || value != 0) {
              WindowBits = value;
            }
            break;
          }
          case 42: {
            uint? value = _single_chunkSize_codec.Read(ref input);
            if (chunkSize_ == null || value != 0) {
              ChunkSize = value;
            }
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Gzip message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// All the values of this enumeration translate directly to zlib's compression strategies.
      /// For more information about each strategy, please refer to zlib manual.
      /// </summary>
      public enum CompressionStrategy {
        [pbr::OriginalName("DEFAULT_STRATEGY")] DefaultStrategy = 0,
        [pbr::OriginalName("FILTERED")] Filtered = 1,
        [pbr::OriginalName("HUFFMAN_ONLY")] HuffmanOnly = 2,
        [pbr::OriginalName("RLE")] Rle = 3,
        [pbr::OriginalName("FIXED")] Fixed = 4,
      }

      public enum CompressionLevel {
        [pbr::OriginalName("DEFAULT_COMPRESSION")] DefaultCompression = 0,
        [pbr::OriginalName("BEST_SPEED")] BestSpeed = 1,
        [pbr::OriginalName("COMPRESSION_LEVEL_1", PreferredAlias = false)] _1 = 1,
        [pbr::OriginalName("COMPRESSION_LEVEL_2")] _2 = 2,
        [pbr::OriginalName("COMPRESSION_LEVEL_3")] _3 = 3,
        [pbr::OriginalName("COMPRESSION_LEVEL_4")] _4 = 4,
        [pbr::OriginalName("COMPRESSION_LEVEL_5")] _5 = 5,
        [pbr::OriginalName("COMPRESSION_LEVEL_6")] _6 = 6,
        [pbr::OriginalName("COMPRESSION_LEVEL_7")] _7 = 7,
        [pbr::OriginalName("COMPRESSION_LEVEL_8")] _8 = 8,
        [pbr::OriginalName("COMPRESSION_LEVEL_9")] _9 = 9,
        [pbr::OriginalName("BEST_COMPRESSION", PreferredAlias = false)] BestCompression = 9,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
