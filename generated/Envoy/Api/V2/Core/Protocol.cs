// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/api/v2/core/protocol.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2.Core {

  /// <summary>Holder for reflection information generated from envoy/api/v2/core/protocol.proto</summary>
  public static partial class ProtocolReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/api/v2/core/protocol.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ProtocolReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiBlbnZveS9hcGkvdjIvY29yZS9wcm90b2NvbC5wcm90bxIRZW52b3kuYXBp",
            "LnYyLmNvcmUaHmdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90bxoeZ29v",
            "Z2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvGh51ZHBhL2Fubm90YXRpb25z",
            "L21pZ3JhdGUucHJvdG8aHXVkcGEvYW5ub3RhdGlvbnMvc3RhdHVzLnByb3Rv",
            "Ghd2YWxpZGF0ZS92YWxpZGF0ZS5wcm90byIUChJUY3BQcm90b2NvbE9wdGlv",
            "bnMiTAobVXBzdHJlYW1IdHRwUHJvdG9jb2xPcHRpb25zEhAKCGF1dG9fc25p",
            "GAEgASgIEhsKE2F1dG9fc2FuX3ZhbGlkYXRpb24YAiABKAgiugMKE0h0dHBQ",
            "cm90b2NvbE9wdGlvbnMSLwoMaWRsZV90aW1lb3V0GAEgASgLMhkuZ29vZ2xl",
            "LnByb3RvYnVmLkR1cmF0aW9uEjoKF21heF9jb25uZWN0aW9uX2R1cmF0aW9u",
            "GAMgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEkAKEW1heF9oZWFk",
            "ZXJzX2NvdW50GAIgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVl",
            "Qgf6QgQqAigBEjYKE21heF9zdHJlYW1fZHVyYXRpb24YBCABKAsyGS5nb29n",
            "bGUucHJvdG9idWYuRHVyYXRpb24SbAofaGVhZGVyc193aXRoX3VuZGVyc2Nv",
            "cmVzX2FjdGlvbhgFIAEoDjJDLmVudm95LmFwaS52Mi5jb3JlLkh0dHBQcm90",
            "b2NvbE9wdGlvbnMuSGVhZGVyc1dpdGhVbmRlcnNjb3Jlc0FjdGlvbiJOChxI",
            "ZWFkZXJzV2l0aFVuZGVyc2NvcmVzQWN0aW9uEgkKBUFMTE9XEAASEgoOUkVK",
            "RUNUX1JFUVVFU1QQARIPCgtEUk9QX0hFQURFUhACIpgDChRIdHRwMVByb3Rv",
            "Y29sT3B0aW9ucxI2ChJhbGxvd19hYnNvbHV0ZV91cmwYASABKAsyGi5nb29n",
            "bGUucHJvdG9idWYuQm9vbFZhbHVlEhYKDmFjY2VwdF9odHRwXzEwGAIgASgI",
            "EiAKGGRlZmF1bHRfaG9zdF9mb3JfaHR0cF8xMBgDIAEoCRJSChFoZWFkZXJf",
            "a2V5X2Zvcm1hdBgEIAEoCzI3LmVudm95LmFwaS52Mi5jb3JlLkh0dHAxUHJv",
            "dG9jb2xPcHRpb25zLkhlYWRlcktleUZvcm1hdBIXCg9lbmFibGVfdHJhaWxl",
            "cnMYBSABKAgaoAEKD0hlYWRlcktleUZvcm1hdBJkChFwcm9wZXJfY2FzZV93",
            "b3JkcxgBIAEoCzJHLmVudm95LmFwaS52Mi5jb3JlLkh0dHAxUHJvdG9jb2xP",
            "cHRpb25zLkhlYWRlcktleUZvcm1hdC5Qcm9wZXJDYXNlV29yZHNIABoRCg9Q",
            "cm9wZXJDYXNlV29yZHNCFAoNaGVhZGVyX2Zvcm1hdBID+EIBIrMIChRIdHRw",
            "MlByb3RvY29sT3B0aW9ucxI2ChBocGFja190YWJsZV9zaXplGAEgASgLMhwu",
            "Z29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlEksKFm1heF9jb25jdXJyZW50",
            "X3N0cmVhbXMYAiABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVC",
            "DfpCCioIGP////8HKAESUQoaaW5pdGlhbF9zdHJlYW1fd2luZG93X3NpemUY",
            "AyABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVCD/pCDCoKGP//",
            "//8HKP//AxJVCh5pbml0aWFsX2Nvbm5lY3Rpb25fd2luZG93X3NpemUYBCAB",
            "KAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVCD/pCDCoKGP////8H",
            "KP//AxIVCg1hbGxvd19jb25uZWN0GAUgASgIEhYKDmFsbG93X21ldGFkYXRh",
            "GAYgASgIEkIKE21heF9vdXRib3VuZF9mcmFtZXMYByABKAsyHC5nb29nbGUu",
            "cHJvdG9idWYuVUludDMyVmFsdWVCB/pCBCoCKAESSgobbWF4X291dGJvdW5k",
            "X2NvbnRyb2xfZnJhbWVzGAggASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQz",
            "MlZhbHVlQgf6QgQqAigBElcKMW1heF9jb25zZWN1dGl2ZV9pbmJvdW5kX2Zy",
            "YW1lc193aXRoX2VtcHR5X3BheWxvYWQYCSABKAsyHC5nb29nbGUucHJvdG9i",
            "dWYuVUludDMyVmFsdWUSTAombWF4X2luYm91bmRfcHJpb3JpdHlfZnJhbWVz",
            "X3Blcl9zdHJlYW0YCiABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFs",
            "dWUSYwo0bWF4X2luYm91bmRfd2luZG93X3VwZGF0ZV9mcmFtZXNfcGVyX2Rh",
            "dGFfZnJhbWVfc2VudBgLIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50MzJW",
            "YWx1ZUIH+kIEKgIoARIuCiZzdHJlYW1fZXJyb3Jfb25faW52YWxpZF9odHRw",
            "X21lc3NhZ2luZxgMIAEoCBJdChpjdXN0b21fc2V0dGluZ3NfcGFyYW1ldGVy",
            "cxgNIAMoCzI5LmVudm95LmFwaS52Mi5jb3JlLkh0dHAyUHJvdG9jb2xPcHRp",
            "b25zLlNldHRpbmdzUGFyYW1ldGVyGpEBChFTZXR0aW5nc1BhcmFtZXRlchJF",
            "CgppZGVudGlmaWVyGAEgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZh",
            "bHVlQhP6QggqBhiAgAQoAfpCBYoBAhABEjUKBXZhbHVlGAIgASgLMhwuZ29v",
            "Z2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlQgj6QgWKAQIQASJeChNHcnBjUHJv",
            "dG9jb2xPcHRpb25zEkcKFmh0dHAyX3Byb3RvY29sX29wdGlvbnMYASABKAsy",
            "Jy5lbnZveS5hcGkudjIuY29yZS5IdHRwMlByb3RvY29sT3B0aW9uc0JWCh9p",
            "by5lbnZveXByb3h5LmVudm95LmFwaS52Mi5jb3JlQg1Qcm90b2NvbFByb3Rv",
            "UAHymP6PBRYSFGVudm95LmNvbmZpZy5jb3JlLnYzuoDI0QYCEAFiBnByb3Rv",
            "Mw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Udpa.Annotations.MigrateReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.TcpProtocolOptions), global::Envoy.Api.V2.Core.TcpProtocolOptions.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.UpstreamHttpProtocolOptions), global::Envoy.Api.V2.Core.UpstreamHttpProtocolOptions.Parser, new[]{ "AutoSni", "AutoSanValidation" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.HttpProtocolOptions), global::Envoy.Api.V2.Core.HttpProtocolOptions.Parser, new[]{ "IdleTimeout", "MaxConnectionDuration", "MaxHeadersCount", "MaxStreamDuration", "HeadersWithUnderscoresAction" }, null, new[]{ typeof(global::Envoy.Api.V2.Core.HttpProtocolOptions.Types.HeadersWithUnderscoresAction) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.Http1ProtocolOptions), global::Envoy.Api.V2.Core.Http1ProtocolOptions.Parser, new[]{ "AllowAbsoluteUrl", "AcceptHttp10", "DefaultHostForHttp10", "HeaderKeyFormat", "EnableTrailers" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat), global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat.Parser, new[]{ "ProperCaseWords" }, new[]{ "HeaderFormat" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords), global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords.Parser, null, null, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.Http2ProtocolOptions), global::Envoy.Api.V2.Core.Http2ProtocolOptions.Parser, new[]{ "HpackTableSize", "MaxConcurrentStreams", "InitialStreamWindowSize", "InitialConnectionWindowSize", "AllowConnect", "AllowMetadata", "MaxOutboundFrames", "MaxOutboundControlFrames", "MaxConsecutiveInboundFramesWithEmptyPayload", "MaxInboundPriorityFramesPerStream", "MaxInboundWindowUpdateFramesPerDataFrameSent", "StreamErrorOnInvalidHttpMessaging", "CustomSettingsParameters" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.Http2ProtocolOptions.Types.SettingsParameter), global::Envoy.Api.V2.Core.Http2ProtocolOptions.Types.SettingsParameter.Parser, new[]{ "Identifier", "Value" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.GrpcProtocolOptions), global::Envoy.Api.V2.Core.GrpcProtocolOptions.Parser, new[]{ "Http2ProtocolOptions" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// [#not-implemented-hide:]
  /// </summary>
  public sealed partial class TcpProtocolOptions : pb::IMessage<TcpProtocolOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TcpProtocolOptions> _parser = new pb::MessageParser<TcpProtocolOptions>(() => new TcpProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TcpProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TcpProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TcpProtocolOptions(TcpProtocolOptions other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TcpProtocolOptions Clone() {
      return new TcpProtocolOptions(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TcpProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TcpProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TcpProtocolOptions other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  public sealed partial class UpstreamHttpProtocolOptions : pb::IMessage<UpstreamHttpProtocolOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpstreamHttpProtocolOptions> _parser = new pb::MessageParser<UpstreamHttpProtocolOptions>(() => new UpstreamHttpProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UpstreamHttpProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamHttpProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamHttpProtocolOptions(UpstreamHttpProtocolOptions other) : this() {
      autoSni_ = other.autoSni_;
      autoSanValidation_ = other.autoSanValidation_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamHttpProtocolOptions Clone() {
      return new UpstreamHttpProtocolOptions(this);
    }

    /// <summary>Field number for the "auto_sni" field.</summary>
    public const int AutoSniFieldNumber = 1;
    private bool autoSni_;
    /// <summary>
    /// Set transport socket `SNI &lt;https://en.wikipedia.org/wiki/Server_Name_Indication>`_ for new
    /// upstream connections based on the downstream HTTP host/authority header, as seen by the
    /// :ref:`router filter &lt;config_http_filters_router>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AutoSni {
      get { return autoSni_; }
      set {
        autoSni_ = value;
      }
    }

    /// <summary>Field number for the "auto_san_validation" field.</summary>
    public const int AutoSanValidationFieldNumber = 2;
    private bool autoSanValidation_;
    /// <summary>
    /// Automatic validate upstream presented certificate for new upstream connections based on the
    /// downstream HTTP host/authority header, as seen by the
    /// :ref:`router filter &lt;config_http_filters_router>`.
    /// This field is intended to set with `auto_sni` field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AutoSanValidation {
      get { return autoSanValidation_; }
      set {
        autoSanValidation_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UpstreamHttpProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UpstreamHttpProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AutoSni != other.AutoSni) return false;
      if (AutoSanValidation != other.AutoSanValidation) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (AutoSni != false) hash ^= AutoSni.GetHashCode();
      if (AutoSanValidation != false) hash ^= AutoSanValidation.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (AutoSni != false) {
        output.WriteRawTag(8);
        output.WriteBool(AutoSni);
      }
      if (AutoSanValidation != false) {
        output.WriteRawTag(16);
        output.WriteBool(AutoSanValidation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (AutoSni != false) {
        output.WriteRawTag(8);
        output.WriteBool(AutoSni);
      }
      if (AutoSanValidation != false) {
        output.WriteRawTag(16);
        output.WriteBool(AutoSanValidation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (AutoSni != false) {
        size += 1 + 1;
      }
      if (AutoSanValidation != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UpstreamHttpProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.AutoSni != false) {
        AutoSni = other.AutoSni;
      }
      if (other.AutoSanValidation != false) {
        AutoSanValidation = other.AutoSanValidation;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AutoSni = input.ReadBool();
            break;
          }
          case 16: {
            AutoSanValidation = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            AutoSni = input.ReadBool();
            break;
          }
          case 16: {
            AutoSanValidation = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#next-free-field: 6]
  /// </summary>
  public sealed partial class HttpProtocolOptions : pb::IMessage<HttpProtocolOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HttpProtocolOptions> _parser = new pb::MessageParser<HttpProtocolOptions>(() => new HttpProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HttpProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpProtocolOptions(HttpProtocolOptions other) : this() {
      idleTimeout_ = other.idleTimeout_ != null ? other.idleTimeout_.Clone() : null;
      maxConnectionDuration_ = other.maxConnectionDuration_ != null ? other.maxConnectionDuration_.Clone() : null;
      MaxHeadersCount = other.MaxHeadersCount;
      maxStreamDuration_ = other.maxStreamDuration_ != null ? other.maxStreamDuration_.Clone() : null;
      headersWithUnderscoresAction_ = other.headersWithUnderscoresAction_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpProtocolOptions Clone() {
      return new HttpProtocolOptions(this);
    }

    /// <summary>Field number for the "idle_timeout" field.</summary>
    public const int IdleTimeoutFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Duration idleTimeout_;
    /// <summary>
    /// The idle timeout for connections. The idle timeout is defined as the
    /// period in which there are no active requests. When the
    /// idle timeout is reached the connection will be closed. If the connection is an HTTP/2
    /// downstream connection a drain sequence will occur prior to closing the connection, see
    /// :ref:`drain_timeout
    /// &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.drain_timeout>`.
    /// Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive.
    /// If not specified, this defaults to 1 hour. To disable idle timeouts explicitly set this to 0.
    ///
    /// .. warning::
    ///   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
    ///   FIN packets, etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration IdleTimeout {
      get { return idleTimeout_; }
      set {
        idleTimeout_ = value;
      }
    }

    /// <summary>Field number for the "max_connection_duration" field.</summary>
    public const int MaxConnectionDurationFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration maxConnectionDuration_;
    /// <summary>
    /// The maximum duration of a connection. The duration is defined as a period since a connection
    /// was established. If not set, there is no max duration. When max_connection_duration is reached
    /// the connection will be closed. Drain sequence will occur prior to closing the connection if
    /// if's applicable. See :ref:`drain_timeout
    /// &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.drain_timeout>`.
    /// Note: not implemented for upstream connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration MaxConnectionDuration {
      get { return maxConnectionDuration_; }
      set {
        maxConnectionDuration_ = value;
      }
    }

    /// <summary>Field number for the "max_headers_count" field.</summary>
    public const int MaxHeadersCountFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_maxHeadersCount_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? maxHeadersCount_;
    /// <summary>
    /// The maximum number of headers. If unconfigured, the default
    /// maximum number of request headers allowed is 100. Requests that exceed this limit will receive
    /// a 431 response for HTTP/1.x and cause a stream reset for HTTP/2.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxHeadersCount {
      get { return maxHeadersCount_; }
      set {
        maxHeadersCount_ = value;
      }
    }


    /// <summary>Field number for the "max_stream_duration" field.</summary>
    public const int MaxStreamDurationFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration maxStreamDuration_;
    /// <summary>
    /// Total duration to keep alive an HTTP request/response stream. If the time limit is reached the stream will be
    /// reset independent of any other timeouts. If not specified, this value is not set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration MaxStreamDuration {
      get { return maxStreamDuration_; }
      set {
        maxStreamDuration_ = value;
      }
    }

    /// <summary>Field number for the "headers_with_underscores_action" field.</summary>
    public const int HeadersWithUnderscoresActionFieldNumber = 5;
    private global::Envoy.Api.V2.Core.HttpProtocolOptions.Types.HeadersWithUnderscoresAction headersWithUnderscoresAction_ = global::Envoy.Api.V2.Core.HttpProtocolOptions.Types.HeadersWithUnderscoresAction.Allow;
    /// <summary>
    /// Action to take when a client request with a header name containing underscore characters is received.
    /// If this setting is not specified, the value defaults to ALLOW.
    /// Note: upstream responses are not affected by this setting.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.HttpProtocolOptions.Types.HeadersWithUnderscoresAction HeadersWithUnderscoresAction {
      get { return headersWithUnderscoresAction_; }
      set {
        headersWithUnderscoresAction_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HttpProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HttpProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(IdleTimeout, other.IdleTimeout)) return false;
      if (!object.Equals(MaxConnectionDuration, other.MaxConnectionDuration)) return false;
      if (MaxHeadersCount != other.MaxHeadersCount) return false;
      if (!object.Equals(MaxStreamDuration, other.MaxStreamDuration)) return false;
      if (HeadersWithUnderscoresAction != other.HeadersWithUnderscoresAction) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (idleTimeout_ != null) hash ^= IdleTimeout.GetHashCode();
      if (maxConnectionDuration_ != null) hash ^= MaxConnectionDuration.GetHashCode();
      if (maxHeadersCount_ != null) hash ^= MaxHeadersCount.GetHashCode();
      if (maxStreamDuration_ != null) hash ^= MaxStreamDuration.GetHashCode();
      if (HeadersWithUnderscoresAction != global::Envoy.Api.V2.Core.HttpProtocolOptions.Types.HeadersWithUnderscoresAction.Allow) hash ^= HeadersWithUnderscoresAction.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (idleTimeout_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(IdleTimeout);
      }
      if (maxHeadersCount_ != null) {
        _single_maxHeadersCount_codec.WriteTagAndValue(output, MaxHeadersCount);
      }
      if (maxConnectionDuration_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(MaxConnectionDuration);
      }
      if (maxStreamDuration_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(MaxStreamDuration);
      }
      if (HeadersWithUnderscoresAction != global::Envoy.Api.V2.Core.HttpProtocolOptions.Types.HeadersWithUnderscoresAction.Allow) {
        output.WriteRawTag(40);
        output.WriteEnum((int) HeadersWithUnderscoresAction);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (idleTimeout_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(IdleTimeout);
      }
      if (maxHeadersCount_ != null) {
        _single_maxHeadersCount_codec.WriteTagAndValue(ref output, MaxHeadersCount);
      }
      if (maxConnectionDuration_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(MaxConnectionDuration);
      }
      if (maxStreamDuration_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(MaxStreamDuration);
      }
      if (HeadersWithUnderscoresAction != global::Envoy.Api.V2.Core.HttpProtocolOptions.Types.HeadersWithUnderscoresAction.Allow) {
        output.WriteRawTag(40);
        output.WriteEnum((int) HeadersWithUnderscoresAction);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (idleTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(IdleTimeout);
      }
      if (maxConnectionDuration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxConnectionDuration);
      }
      if (maxHeadersCount_ != null) {
        size += _single_maxHeadersCount_codec.CalculateSizeWithTag(MaxHeadersCount);
      }
      if (maxStreamDuration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxStreamDuration);
      }
      if (HeadersWithUnderscoresAction != global::Envoy.Api.V2.Core.HttpProtocolOptions.Types.HeadersWithUnderscoresAction.Allow) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) HeadersWithUnderscoresAction);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HttpProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.idleTimeout_ != null) {
        if (idleTimeout_ == null) {
          IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        IdleTimeout.MergeFrom(other.IdleTimeout);
      }
      if (other.maxConnectionDuration_ != null) {
        if (maxConnectionDuration_ == null) {
          MaxConnectionDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MaxConnectionDuration.MergeFrom(other.MaxConnectionDuration);
      }
      if (other.maxHeadersCount_ != null) {
        if (maxHeadersCount_ == null || other.MaxHeadersCount != 0) {
          MaxHeadersCount = other.MaxHeadersCount;
        }
      }
      if (other.maxStreamDuration_ != null) {
        if (maxStreamDuration_ == null) {
          MaxStreamDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MaxStreamDuration.MergeFrom(other.MaxStreamDuration);
      }
      if (other.HeadersWithUnderscoresAction != global::Envoy.Api.V2.Core.HttpProtocolOptions.Types.HeadersWithUnderscoresAction.Allow) {
        HeadersWithUnderscoresAction = other.HeadersWithUnderscoresAction;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (idleTimeout_ == null) {
              IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(IdleTimeout);
            break;
          }
          case 18: {
            uint? value = _single_maxHeadersCount_codec.Read(input);
            if (maxHeadersCount_ == null || value != 0) {
              MaxHeadersCount = value;
            }
            break;
          }
          case 26: {
            if (maxConnectionDuration_ == null) {
              MaxConnectionDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaxConnectionDuration);
            break;
          }
          case 34: {
            if (maxStreamDuration_ == null) {
              MaxStreamDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaxStreamDuration);
            break;
          }
          case 40: {
            HeadersWithUnderscoresAction = (global::Envoy.Api.V2.Core.HttpProtocolOptions.Types.HeadersWithUnderscoresAction) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (idleTimeout_ == null) {
              IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(IdleTimeout);
            break;
          }
          case 18: {
            uint? value = _single_maxHeadersCount_codec.Read(ref input);
            if (maxHeadersCount_ == null || value != 0) {
              MaxHeadersCount = value;
            }
            break;
          }
          case 26: {
            if (maxConnectionDuration_ == null) {
              MaxConnectionDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaxConnectionDuration);
            break;
          }
          case 34: {
            if (maxStreamDuration_ == null) {
              MaxStreamDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaxStreamDuration);
            break;
          }
          case 40: {
            HeadersWithUnderscoresAction = (global::Envoy.Api.V2.Core.HttpProtocolOptions.Types.HeadersWithUnderscoresAction) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the HttpProtocolOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Action to take when Envoy receives client request with header names containing underscore
      /// characters.
      /// Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented
      /// as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore
      /// characters.
      /// </summary>
      public enum HeadersWithUnderscoresAction {
        /// <summary>
        /// Allow headers with underscores. This is the default behavior.
        /// </summary>
        [pbr::OriginalName("ALLOW")] Allow = 0,
        /// <summary>
        /// Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
        /// end with the stream reset. The "httpN.requests_rejected_with_underscores_in_headers" counter
        /// is incremented for each rejected request.
        /// </summary>
        [pbr::OriginalName("REJECT_REQUEST")] RejectRequest = 1,
        /// <summary>
        /// Drop the header with name containing underscores. The header is dropped before the filter chain is
        /// invoked and as such filters will not see dropped headers. The
        /// "httpN.dropped_headers_with_underscores" is incremented for each dropped header.
        /// </summary>
        [pbr::OriginalName("DROP_HEADER")] DropHeader = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// [#next-free-field: 6]
  /// </summary>
  public sealed partial class Http1ProtocolOptions : pb::IMessage<Http1ProtocolOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Http1ProtocolOptions> _parser = new pb::MessageParser<Http1ProtocolOptions>(() => new Http1ProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Http1ProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http1ProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http1ProtocolOptions(Http1ProtocolOptions other) : this() {
      AllowAbsoluteUrl = other.AllowAbsoluteUrl;
      acceptHttp10_ = other.acceptHttp10_;
      defaultHostForHttp10_ = other.defaultHostForHttp10_;
      headerKeyFormat_ = other.headerKeyFormat_ != null ? other.headerKeyFormat_.Clone() : null;
      enableTrailers_ = other.enableTrailers_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http1ProtocolOptions Clone() {
      return new Http1ProtocolOptions(this);
    }

    /// <summary>Field number for the "allow_absolute_url" field.</summary>
    public const int AllowAbsoluteUrlFieldNumber = 1;
    private static readonly pb::FieldCodec<bool?> _single_allowAbsoluteUrl_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
    private bool? allowAbsoluteUrl_;
    /// <summary>
    /// Handle HTTP requests with absolute URLs in the requests. These requests
    /// are generally sent by clients to forward/explicit proxies. This allows clients to configure
    /// envoy as their HTTP proxy. In Unix, for example, this is typically done by setting the
    /// *http_proxy* environment variable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? AllowAbsoluteUrl {
      get { return allowAbsoluteUrl_; }
      set {
        allowAbsoluteUrl_ = value;
      }
    }


    /// <summary>Field number for the "accept_http_10" field.</summary>
    public const int AcceptHttp10FieldNumber = 2;
    private bool acceptHttp10_;
    /// <summary>
    /// Handle incoming HTTP/1.0 and HTTP 0.9 requests.
    /// This is off by default, and not fully standards compliant. There is support for pre-HTTP/1.1
    /// style connect logic, dechunking, and handling lack of client host iff
    /// *default_host_for_http_10* is configured.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AcceptHttp10 {
      get { return acceptHttp10_; }
      set {
        acceptHttp10_ = value;
      }
    }

    /// <summary>Field number for the "default_host_for_http_10" field.</summary>
    public const int DefaultHostForHttp10FieldNumber = 3;
    private string defaultHostForHttp10_ = "";
    /// <summary>
    /// A default host for HTTP/1.0 requests. This is highly suggested if *accept_http_10* is true as
    /// Envoy does not otherwise support HTTP/1.0 without a Host header.
    /// This is a no-op if *accept_http_10* is not true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DefaultHostForHttp10 {
      get { return defaultHostForHttp10_; }
      set {
        defaultHostForHttp10_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "header_key_format" field.</summary>
    public const int HeaderKeyFormatFieldNumber = 4;
    private global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat headerKeyFormat_;
    /// <summary>
    /// Describes how the keys for response headers should be formatted. By default, all header keys
    /// are lower cased.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat HeaderKeyFormat {
      get { return headerKeyFormat_; }
      set {
        headerKeyFormat_ = value;
      }
    }

    /// <summary>Field number for the "enable_trailers" field.</summary>
    public const int EnableTrailersFieldNumber = 5;
    private bool enableTrailers_;
    /// <summary>
    /// Enables trailers for HTTP/1. By default the HTTP/1 codec drops proxied trailers.
    ///
    /// .. attention::
    ///
    ///   Note that this only happens when Envoy is chunk encoding which occurs when:
    ///   - The request is HTTP/1.1.
    ///   - Is neither a HEAD only request nor a HTTP Upgrade.
    ///   - Not a response to a HEAD request.
    ///   - The content length header is not present.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool EnableTrailers {
      get { return enableTrailers_; }
      set {
        enableTrailers_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Http1ProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Http1ProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AllowAbsoluteUrl != other.AllowAbsoluteUrl) return false;
      if (AcceptHttp10 != other.AcceptHttp10) return false;
      if (DefaultHostForHttp10 != other.DefaultHostForHttp10) return false;
      if (!object.Equals(HeaderKeyFormat, other.HeaderKeyFormat)) return false;
      if (EnableTrailers != other.EnableTrailers) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (allowAbsoluteUrl_ != null) hash ^= AllowAbsoluteUrl.GetHashCode();
      if (AcceptHttp10 != false) hash ^= AcceptHttp10.GetHashCode();
      if (DefaultHostForHttp10.Length != 0) hash ^= DefaultHostForHttp10.GetHashCode();
      if (headerKeyFormat_ != null) hash ^= HeaderKeyFormat.GetHashCode();
      if (EnableTrailers != false) hash ^= EnableTrailers.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (allowAbsoluteUrl_ != null) {
        _single_allowAbsoluteUrl_codec.WriteTagAndValue(output, AllowAbsoluteUrl);
      }
      if (AcceptHttp10 != false) {
        output.WriteRawTag(16);
        output.WriteBool(AcceptHttp10);
      }
      if (DefaultHostForHttp10.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DefaultHostForHttp10);
      }
      if (headerKeyFormat_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(HeaderKeyFormat);
      }
      if (EnableTrailers != false) {
        output.WriteRawTag(40);
        output.WriteBool(EnableTrailers);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (allowAbsoluteUrl_ != null) {
        _single_allowAbsoluteUrl_codec.WriteTagAndValue(ref output, AllowAbsoluteUrl);
      }
      if (AcceptHttp10 != false) {
        output.WriteRawTag(16);
        output.WriteBool(AcceptHttp10);
      }
      if (DefaultHostForHttp10.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DefaultHostForHttp10);
      }
      if (headerKeyFormat_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(HeaderKeyFormat);
      }
      if (EnableTrailers != false) {
        output.WriteRawTag(40);
        output.WriteBool(EnableTrailers);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (allowAbsoluteUrl_ != null) {
        size += _single_allowAbsoluteUrl_codec.CalculateSizeWithTag(AllowAbsoluteUrl);
      }
      if (AcceptHttp10 != false) {
        size += 1 + 1;
      }
      if (DefaultHostForHttp10.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DefaultHostForHttp10);
      }
      if (headerKeyFormat_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HeaderKeyFormat);
      }
      if (EnableTrailers != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Http1ProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.allowAbsoluteUrl_ != null) {
        if (allowAbsoluteUrl_ == null || other.AllowAbsoluteUrl != false) {
          AllowAbsoluteUrl = other.AllowAbsoluteUrl;
        }
      }
      if (other.AcceptHttp10 != false) {
        AcceptHttp10 = other.AcceptHttp10;
      }
      if (other.DefaultHostForHttp10.Length != 0) {
        DefaultHostForHttp10 = other.DefaultHostForHttp10;
      }
      if (other.headerKeyFormat_ != null) {
        if (headerKeyFormat_ == null) {
          HeaderKeyFormat = new global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat();
        }
        HeaderKeyFormat.MergeFrom(other.HeaderKeyFormat);
      }
      if (other.EnableTrailers != false) {
        EnableTrailers = other.EnableTrailers;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            bool? value = _single_allowAbsoluteUrl_codec.Read(input);
            if (allowAbsoluteUrl_ == null || value != false) {
              AllowAbsoluteUrl = value;
            }
            break;
          }
          case 16: {
            AcceptHttp10 = input.ReadBool();
            break;
          }
          case 26: {
            DefaultHostForHttp10 = input.ReadString();
            break;
          }
          case 34: {
            if (headerKeyFormat_ == null) {
              HeaderKeyFormat = new global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat();
            }
            input.ReadMessage(HeaderKeyFormat);
            break;
          }
          case 40: {
            EnableTrailers = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            bool? value = _single_allowAbsoluteUrl_codec.Read(ref input);
            if (allowAbsoluteUrl_ == null || value != false) {
              AllowAbsoluteUrl = value;
            }
            break;
          }
          case 16: {
            AcceptHttp10 = input.ReadBool();
            break;
          }
          case 26: {
            DefaultHostForHttp10 = input.ReadString();
            break;
          }
          case 34: {
            if (headerKeyFormat_ == null) {
              HeaderKeyFormat = new global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat();
            }
            input.ReadMessage(HeaderKeyFormat);
            break;
          }
          case 40: {
            EnableTrailers = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Http1ProtocolOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public sealed partial class HeaderKeyFormat : pb::IMessage<HeaderKeyFormat>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<HeaderKeyFormat> _parser = new pb::MessageParser<HeaderKeyFormat>(() => new HeaderKeyFormat());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<HeaderKeyFormat> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Core.Http1ProtocolOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HeaderKeyFormat() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HeaderKeyFormat(HeaderKeyFormat other) : this() {
          switch (other.HeaderFormatCase) {
            case HeaderFormatOneofCase.ProperCaseWords:
              ProperCaseWords = other.ProperCaseWords.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HeaderKeyFormat Clone() {
          return new HeaderKeyFormat(this);
        }

        /// <summary>Field number for the "proper_case_words" field.</summary>
        public const int ProperCaseWordsFieldNumber = 1;
        /// <summary>
        /// Formats the header by proper casing words: the first character and any character following
        /// a special character will be capitalized if it's an alpha character. For example,
        /// "content-type" becomes "Content-Type", and "foo$b#$are" becomes "Foo$B#$Are".
        /// Note that while this results in most headers following conventional casing, certain headers
        /// are not covered. For example, the "TE" header will be formatted as "Te".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords ProperCaseWords {
          get { return headerFormatCase_ == HeaderFormatOneofCase.ProperCaseWords ? (global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords) headerFormat_ : null; }
          set {
            headerFormat_ = value;
            headerFormatCase_ = value == null ? HeaderFormatOneofCase.None : HeaderFormatOneofCase.ProperCaseWords;
          }
        }

        private object headerFormat_;
        /// <summary>Enum of possible cases for the "header_format" oneof.</summary>
        public enum HeaderFormatOneofCase {
          None = 0,
          ProperCaseWords = 1,
        }
        private HeaderFormatOneofCase headerFormatCase_ = HeaderFormatOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HeaderFormatOneofCase HeaderFormatCase {
          get { return headerFormatCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearHeaderFormat() {
          headerFormatCase_ = HeaderFormatOneofCase.None;
          headerFormat_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as HeaderKeyFormat);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(HeaderKeyFormat other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(ProperCaseWords, other.ProperCaseWords)) return false;
          if (HeaderFormatCase != other.HeaderFormatCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (headerFormatCase_ == HeaderFormatOneofCase.ProperCaseWords) hash ^= ProperCaseWords.GetHashCode();
          hash ^= (int) headerFormatCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (headerFormatCase_ == HeaderFormatOneofCase.ProperCaseWords) {
            output.WriteRawTag(10);
            output.WriteMessage(ProperCaseWords);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (headerFormatCase_ == HeaderFormatOneofCase.ProperCaseWords) {
            output.WriteRawTag(10);
            output.WriteMessage(ProperCaseWords);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (headerFormatCase_ == HeaderFormatOneofCase.ProperCaseWords) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ProperCaseWords);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(HeaderKeyFormat other) {
          if (other == null) {
            return;
          }
          switch (other.HeaderFormatCase) {
            case HeaderFormatOneofCase.ProperCaseWords:
              if (ProperCaseWords == null) {
                ProperCaseWords = new global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords();
              }
              ProperCaseWords.MergeFrom(other.ProperCaseWords);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords subBuilder = new global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords();
                if (headerFormatCase_ == HeaderFormatOneofCase.ProperCaseWords) {
                  subBuilder.MergeFrom(ProperCaseWords);
                }
                input.ReadMessage(subBuilder);
                ProperCaseWords = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords subBuilder = new global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords();
                if (headerFormatCase_ == HeaderFormatOneofCase.ProperCaseWords) {
                  subBuilder.MergeFrom(ProperCaseWords);
                }
                input.ReadMessage(subBuilder);
                ProperCaseWords = subBuilder;
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the HeaderKeyFormat message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          public sealed partial class ProperCaseWords : pb::IMessage<ProperCaseWords>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<ProperCaseWords> _parser = new pb::MessageParser<ProperCaseWords>(() => new ProperCaseWords());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<ProperCaseWords> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Core.Http1ProtocolOptions.Types.HeaderKeyFormat.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ProperCaseWords() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ProperCaseWords(ProperCaseWords other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ProperCaseWords Clone() {
              return new ProperCaseWords(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as ProperCaseWords);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(ProperCaseWords other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(ProperCaseWords other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// [#next-free-field: 14]
  /// </summary>
  public sealed partial class Http2ProtocolOptions : pb::IMessage<Http2ProtocolOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Http2ProtocolOptions> _parser = new pb::MessageParser<Http2ProtocolOptions>(() => new Http2ProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Http2ProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http2ProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http2ProtocolOptions(Http2ProtocolOptions other) : this() {
      HpackTableSize = other.HpackTableSize;
      MaxConcurrentStreams = other.MaxConcurrentStreams;
      InitialStreamWindowSize = other.InitialStreamWindowSize;
      InitialConnectionWindowSize = other.InitialConnectionWindowSize;
      allowConnect_ = other.allowConnect_;
      allowMetadata_ = other.allowMetadata_;
      MaxOutboundFrames = other.MaxOutboundFrames;
      MaxOutboundControlFrames = other.MaxOutboundControlFrames;
      MaxConsecutiveInboundFramesWithEmptyPayload = other.MaxConsecutiveInboundFramesWithEmptyPayload;
      MaxInboundPriorityFramesPerStream = other.MaxInboundPriorityFramesPerStream;
      MaxInboundWindowUpdateFramesPerDataFrameSent = other.MaxInboundWindowUpdateFramesPerDataFrameSent;
      streamErrorOnInvalidHttpMessaging_ = other.streamErrorOnInvalidHttpMessaging_;
      customSettingsParameters_ = other.customSettingsParameters_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http2ProtocolOptions Clone() {
      return new Http2ProtocolOptions(this);
    }

    /// <summary>Field number for the "hpack_table_size" field.</summary>
    public const int HpackTableSizeFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_hpackTableSize_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? hpackTableSize_;
    /// <summary>
    /// `Maximum table size &lt;https://httpwg.org/specs/rfc7541.html#rfc.section.4.2>`_
    /// (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values
    /// range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header
    /// compression.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? HpackTableSize {
      get { return hpackTableSize_; }
      set {
        hpackTableSize_ = value;
      }
    }


    /// <summary>Field number for the "max_concurrent_streams" field.</summary>
    public const int MaxConcurrentStreamsFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_maxConcurrentStreams_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? maxConcurrentStreams_;
    /// <summary>
    /// `Maximum concurrent streams &lt;https://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2>`_
    /// allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1)
    /// and defaults to 2147483647.
    ///
    /// For upstream connections, this also limits how many streams Envoy will initiate concurrently
    /// on a single connection. If the limit is reached, Envoy may queue requests or establish
    /// additional connections (as allowed per circuit breaker limits).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxConcurrentStreams {
      get { return maxConcurrentStreams_; }
      set {
        maxConcurrentStreams_ = value;
      }
    }


    /// <summary>Field number for the "initial_stream_window_size" field.</summary>
    public const int InitialStreamWindowSizeFieldNumber = 3;
    private static readonly pb::FieldCodec<uint?> _single_initialStreamWindowSize_codec = pb::FieldCodec.ForStructWrapper<uint>(26);
    private uint? initialStreamWindowSize_;
    /// <summary>
    /// `Initial stream-level flow-control window
    /// &lt;https://httpwg.org/specs/rfc7540.html#rfc.section.6.9.2>`_ size. Valid values range from 65535
    /// (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum) and defaults to 268435456
    /// (256 * 1024 * 1024).
    ///
    /// NOTE: 65535 is the initial window size from HTTP/2 spec. We only support increasing the default
    /// window size now, so it's also the minimum.
    ///
    /// This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
    /// HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
    /// stop the flow of data to the codec buffers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? InitialStreamWindowSize {
      get { return initialStreamWindowSize_; }
      set {
        initialStreamWindowSize_ = value;
      }
    }


    /// <summary>Field number for the "initial_connection_window_size" field.</summary>
    public const int InitialConnectionWindowSizeFieldNumber = 4;
    private static readonly pb::FieldCodec<uint?> _single_initialConnectionWindowSize_codec = pb::FieldCodec.ForStructWrapper<uint>(34);
    private uint? initialConnectionWindowSize_;
    /// <summary>
    /// Similar to *initial_stream_window_size*, but for connection-level flow-control
    /// window. Currently, this has the same minimum/maximum/default as *initial_stream_window_size*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? InitialConnectionWindowSize {
      get { return initialConnectionWindowSize_; }
      set {
        initialConnectionWindowSize_ = value;
      }
    }


    /// <summary>Field number for the "allow_connect" field.</summary>
    public const int AllowConnectFieldNumber = 5;
    private bool allowConnect_;
    /// <summary>
    /// Allows proxying Websocket and other upgrades over H2 connect.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowConnect {
      get { return allowConnect_; }
      set {
        allowConnect_ = value;
      }
    }

    /// <summary>Field number for the "allow_metadata" field.</summary>
    public const int AllowMetadataFieldNumber = 6;
    private bool allowMetadata_;
    /// <summary>
    /// [#not-implemented-hide:] Hiding until envoy has full metadata support.
    /// Still under implementation. DO NOT USE.
    ///
    /// Allows metadata. See [metadata
    /// docs](https://github.com/envoyproxy/envoy/blob/main/source/docs/h2_metadata.md) for more
    /// information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowMetadata {
      get { return allowMetadata_; }
      set {
        allowMetadata_ = value;
      }
    }

    /// <summary>Field number for the "max_outbound_frames" field.</summary>
    public const int MaxOutboundFramesFieldNumber = 7;
    private static readonly pb::FieldCodec<uint?> _single_maxOutboundFrames_codec = pb::FieldCodec.ForStructWrapper<uint>(58);
    private uint? maxOutboundFrames_;
    /// <summary>
    /// Limit the number of pending outbound downstream frames of all types (frames that are waiting to
    /// be written into the socket). Exceeding this limit triggers flood mitigation and connection is
    /// terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due
    /// to flood mitigation. The default limit is 10000.
    /// [#comment:TODO: implement same limits for upstream outbound frames as well.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxOutboundFrames {
      get { return maxOutboundFrames_; }
      set {
        maxOutboundFrames_ = value;
      }
    }


    /// <summary>Field number for the "max_outbound_control_frames" field.</summary>
    public const int MaxOutboundControlFramesFieldNumber = 8;
    private static readonly pb::FieldCodec<uint?> _single_maxOutboundControlFrames_codec = pb::FieldCodec.ForStructWrapper<uint>(66);
    private uint? maxOutboundControlFrames_;
    /// <summary>
    /// Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
    /// preventing high memory utilization when receiving continuous stream of these frames. Exceeding
    /// this limit triggers flood mitigation and connection is terminated. The
    /// ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood
    /// mitigation. The default limit is 1000.
    /// [#comment:TODO: implement same limits for upstream outbound frames as well.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxOutboundControlFrames {
      get { return maxOutboundControlFrames_; }
      set {
        maxOutboundControlFrames_ = value;
      }
    }


    /// <summary>Field number for the "max_consecutive_inbound_frames_with_empty_payload" field.</summary>
    public const int MaxConsecutiveInboundFramesWithEmptyPayloadFieldNumber = 9;
    private static readonly pb::FieldCodec<uint?> _single_maxConsecutiveInboundFramesWithEmptyPayload_codec = pb::FieldCodec.ForStructWrapper<uint>(74);
    private uint? maxConsecutiveInboundFramesWithEmptyPayload_;
    /// <summary>
    /// Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an
    /// empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but
    /// might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood``
    /// stat tracks the number of connections terminated due to flood mitigation.
    /// Setting this to 0 will terminate connection upon receiving first frame with an empty payload
    /// and no end stream flag. The default limit is 1.
    /// [#comment:TODO: implement same limits for upstream inbound frames as well.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxConsecutiveInboundFramesWithEmptyPayload {
      get { return maxConsecutiveInboundFramesWithEmptyPayload_; }
      set {
        maxConsecutiveInboundFramesWithEmptyPayload_ = value;
      }
    }


    /// <summary>Field number for the "max_inbound_priority_frames_per_stream" field.</summary>
    public const int MaxInboundPriorityFramesPerStreamFieldNumber = 10;
    private static readonly pb::FieldCodec<uint?> _single_maxInboundPriorityFramesPerStream_codec = pb::FieldCodec.ForStructWrapper<uint>(82);
    private uint? maxInboundPriorityFramesPerStream_;
    /// <summary>
    /// Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number
    /// of PRIORITY frames received over the lifetime of connection exceeds the value calculated
    /// using this formula::
    ///
    ///     max_inbound_priority_frames_per_stream * (1 + inbound_streams)
    ///
    /// the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
    /// the number of connections terminated due to flood mitigation. The default limit is 100.
    /// [#comment:TODO: implement same limits for upstream inbound frames as well.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxInboundPriorityFramesPerStream {
      get { return maxInboundPriorityFramesPerStream_; }
      set {
        maxInboundPriorityFramesPerStream_ = value;
      }
    }


    /// <summary>Field number for the "max_inbound_window_update_frames_per_data_frame_sent" field.</summary>
    public const int MaxInboundWindowUpdateFramesPerDataFrameSentFieldNumber = 11;
    private static readonly pb::FieldCodec<uint?> _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec = pb::FieldCodec.ForStructWrapper<uint>(90);
    private uint? maxInboundWindowUpdateFramesPerDataFrameSent_;
    /// <summary>
    /// Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number
    /// of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated
    /// using this formula::
    ///
    ///     1 + 2 * (inbound_streams +
    ///              max_inbound_window_update_frames_per_data_frame_sent * outbound_data_frames)
    ///
    /// the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
    /// the number of connections terminated due to flood mitigation. The default limit is 10.
    /// Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control,
    /// but more complex implementations that try to estimate available bandwidth require at least 2.
    /// [#comment:TODO: implement same limits for upstream inbound frames as well.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxInboundWindowUpdateFramesPerDataFrameSent {
      get { return maxInboundWindowUpdateFramesPerDataFrameSent_; }
      set {
        maxInboundWindowUpdateFramesPerDataFrameSent_ = value;
      }
    }


    /// <summary>Field number for the "stream_error_on_invalid_http_messaging" field.</summary>
    public const int StreamErrorOnInvalidHttpMessagingFieldNumber = 12;
    private bool streamErrorOnInvalidHttpMessaging_;
    /// <summary>
    /// Allows invalid HTTP messaging and headers. When this option is disabled (default), then
    /// the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
    /// when this option is enabled, only the offending stream is terminated.
    ///
    /// See `RFC7540, sec. 8.1 &lt;https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool StreamErrorOnInvalidHttpMessaging {
      get { return streamErrorOnInvalidHttpMessaging_; }
      set {
        streamErrorOnInvalidHttpMessaging_ = value;
      }
    }

    /// <summary>Field number for the "custom_settings_parameters" field.</summary>
    public const int CustomSettingsParametersFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.Http2ProtocolOptions.Types.SettingsParameter> _repeated_customSettingsParameters_codec
        = pb::FieldCodec.ForMessage(106, global::Envoy.Api.V2.Core.Http2ProtocolOptions.Types.SettingsParameter.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.Http2ProtocolOptions.Types.SettingsParameter> customSettingsParameters_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.Http2ProtocolOptions.Types.SettingsParameter>();
    /// <summary>
    /// [#not-implemented-hide:]
    /// Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:
    ///
    /// 1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
    /// Envoy.
    ///
    /// 2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
    /// 'allow_connect'.
    ///
    /// Note that custom parameters specified through this field can not also be set in the
    /// corresponding named parameters:
    ///
    /// .. code-block:: text
    ///
    ///   ID    Field Name
    ///   ----------------
    ///   0x1   hpack_table_size
    ///   0x3   max_concurrent_streams
    ///   0x4   initial_stream_window_size
    ///
    /// Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
    /// between custom parameters with the same identifier will trigger a failure.
    ///
    /// See `IANA HTTP/2 Settings
    /// &lt;https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings>`_ for
    /// standardized identifiers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.Http2ProtocolOptions.Types.SettingsParameter> CustomSettingsParameters {
      get { return customSettingsParameters_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Http2ProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Http2ProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (HpackTableSize != other.HpackTableSize) return false;
      if (MaxConcurrentStreams != other.MaxConcurrentStreams) return false;
      if (InitialStreamWindowSize != other.InitialStreamWindowSize) return false;
      if (InitialConnectionWindowSize != other.InitialConnectionWindowSize) return false;
      if (AllowConnect != other.AllowConnect) return false;
      if (AllowMetadata != other.AllowMetadata) return false;
      if (MaxOutboundFrames != other.MaxOutboundFrames) return false;
      if (MaxOutboundControlFrames != other.MaxOutboundControlFrames) return false;
      if (MaxConsecutiveInboundFramesWithEmptyPayload != other.MaxConsecutiveInboundFramesWithEmptyPayload) return false;
      if (MaxInboundPriorityFramesPerStream != other.MaxInboundPriorityFramesPerStream) return false;
      if (MaxInboundWindowUpdateFramesPerDataFrameSent != other.MaxInboundWindowUpdateFramesPerDataFrameSent) return false;
      if (StreamErrorOnInvalidHttpMessaging != other.StreamErrorOnInvalidHttpMessaging) return false;
      if(!customSettingsParameters_.Equals(other.customSettingsParameters_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (hpackTableSize_ != null) hash ^= HpackTableSize.GetHashCode();
      if (maxConcurrentStreams_ != null) hash ^= MaxConcurrentStreams.GetHashCode();
      if (initialStreamWindowSize_ != null) hash ^= InitialStreamWindowSize.GetHashCode();
      if (initialConnectionWindowSize_ != null) hash ^= InitialConnectionWindowSize.GetHashCode();
      if (AllowConnect != false) hash ^= AllowConnect.GetHashCode();
      if (AllowMetadata != false) hash ^= AllowMetadata.GetHashCode();
      if (maxOutboundFrames_ != null) hash ^= MaxOutboundFrames.GetHashCode();
      if (maxOutboundControlFrames_ != null) hash ^= MaxOutboundControlFrames.GetHashCode();
      if (maxConsecutiveInboundFramesWithEmptyPayload_ != null) hash ^= MaxConsecutiveInboundFramesWithEmptyPayload.GetHashCode();
      if (maxInboundPriorityFramesPerStream_ != null) hash ^= MaxInboundPriorityFramesPerStream.GetHashCode();
      if (maxInboundWindowUpdateFramesPerDataFrameSent_ != null) hash ^= MaxInboundWindowUpdateFramesPerDataFrameSent.GetHashCode();
      if (StreamErrorOnInvalidHttpMessaging != false) hash ^= StreamErrorOnInvalidHttpMessaging.GetHashCode();
      hash ^= customSettingsParameters_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (hpackTableSize_ != null) {
        _single_hpackTableSize_codec.WriteTagAndValue(output, HpackTableSize);
      }
      if (maxConcurrentStreams_ != null) {
        _single_maxConcurrentStreams_codec.WriteTagAndValue(output, MaxConcurrentStreams);
      }
      if (initialStreamWindowSize_ != null) {
        _single_initialStreamWindowSize_codec.WriteTagAndValue(output, InitialStreamWindowSize);
      }
      if (initialConnectionWindowSize_ != null) {
        _single_initialConnectionWindowSize_codec.WriteTagAndValue(output, InitialConnectionWindowSize);
      }
      if (AllowConnect != false) {
        output.WriteRawTag(40);
        output.WriteBool(AllowConnect);
      }
      if (AllowMetadata != false) {
        output.WriteRawTag(48);
        output.WriteBool(AllowMetadata);
      }
      if (maxOutboundFrames_ != null) {
        _single_maxOutboundFrames_codec.WriteTagAndValue(output, MaxOutboundFrames);
      }
      if (maxOutboundControlFrames_ != null) {
        _single_maxOutboundControlFrames_codec.WriteTagAndValue(output, MaxOutboundControlFrames);
      }
      if (maxConsecutiveInboundFramesWithEmptyPayload_ != null) {
        _single_maxConsecutiveInboundFramesWithEmptyPayload_codec.WriteTagAndValue(output, MaxConsecutiveInboundFramesWithEmptyPayload);
      }
      if (maxInboundPriorityFramesPerStream_ != null) {
        _single_maxInboundPriorityFramesPerStream_codec.WriteTagAndValue(output, MaxInboundPriorityFramesPerStream);
      }
      if (maxInboundWindowUpdateFramesPerDataFrameSent_ != null) {
        _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec.WriteTagAndValue(output, MaxInboundWindowUpdateFramesPerDataFrameSent);
      }
      if (StreamErrorOnInvalidHttpMessaging != false) {
        output.WriteRawTag(96);
        output.WriteBool(StreamErrorOnInvalidHttpMessaging);
      }
      customSettingsParameters_.WriteTo(output, _repeated_customSettingsParameters_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (hpackTableSize_ != null) {
        _single_hpackTableSize_codec.WriteTagAndValue(ref output, HpackTableSize);
      }
      if (maxConcurrentStreams_ != null) {
        _single_maxConcurrentStreams_codec.WriteTagAndValue(ref output, MaxConcurrentStreams);
      }
      if (initialStreamWindowSize_ != null) {
        _single_initialStreamWindowSize_codec.WriteTagAndValue(ref output, InitialStreamWindowSize);
      }
      if (initialConnectionWindowSize_ != null) {
        _single_initialConnectionWindowSize_codec.WriteTagAndValue(ref output, InitialConnectionWindowSize);
      }
      if (AllowConnect != false) {
        output.WriteRawTag(40);
        output.WriteBool(AllowConnect);
      }
      if (AllowMetadata != false) {
        output.WriteRawTag(48);
        output.WriteBool(AllowMetadata);
      }
      if (maxOutboundFrames_ != null) {
        _single_maxOutboundFrames_codec.WriteTagAndValue(ref output, MaxOutboundFrames);
      }
      if (maxOutboundControlFrames_ != null) {
        _single_maxOutboundControlFrames_codec.WriteTagAndValue(ref output, MaxOutboundControlFrames);
      }
      if (maxConsecutiveInboundFramesWithEmptyPayload_ != null) {
        _single_maxConsecutiveInboundFramesWithEmptyPayload_codec.WriteTagAndValue(ref output, MaxConsecutiveInboundFramesWithEmptyPayload);
      }
      if (maxInboundPriorityFramesPerStream_ != null) {
        _single_maxInboundPriorityFramesPerStream_codec.WriteTagAndValue(ref output, MaxInboundPriorityFramesPerStream);
      }
      if (maxInboundWindowUpdateFramesPerDataFrameSent_ != null) {
        _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec.WriteTagAndValue(ref output, MaxInboundWindowUpdateFramesPerDataFrameSent);
      }
      if (StreamErrorOnInvalidHttpMessaging != false) {
        output.WriteRawTag(96);
        output.WriteBool(StreamErrorOnInvalidHttpMessaging);
      }
      customSettingsParameters_.WriteTo(ref output, _repeated_customSettingsParameters_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (hpackTableSize_ != null) {
        size += _single_hpackTableSize_codec.CalculateSizeWithTag(HpackTableSize);
      }
      if (maxConcurrentStreams_ != null) {
        size += _single_maxConcurrentStreams_codec.CalculateSizeWithTag(MaxConcurrentStreams);
      }
      if (initialStreamWindowSize_ != null) {
        size += _single_initialStreamWindowSize_codec.CalculateSizeWithTag(InitialStreamWindowSize);
      }
      if (initialConnectionWindowSize_ != null) {
        size += _single_initialConnectionWindowSize_codec.CalculateSizeWithTag(InitialConnectionWindowSize);
      }
      if (AllowConnect != false) {
        size += 1 + 1;
      }
      if (AllowMetadata != false) {
        size += 1 + 1;
      }
      if (maxOutboundFrames_ != null) {
        size += _single_maxOutboundFrames_codec.CalculateSizeWithTag(MaxOutboundFrames);
      }
      if (maxOutboundControlFrames_ != null) {
        size += _single_maxOutboundControlFrames_codec.CalculateSizeWithTag(MaxOutboundControlFrames);
      }
      if (maxConsecutiveInboundFramesWithEmptyPayload_ != null) {
        size += _single_maxConsecutiveInboundFramesWithEmptyPayload_codec.CalculateSizeWithTag(MaxConsecutiveInboundFramesWithEmptyPayload);
      }
      if (maxInboundPriorityFramesPerStream_ != null) {
        size += _single_maxInboundPriorityFramesPerStream_codec.CalculateSizeWithTag(MaxInboundPriorityFramesPerStream);
      }
      if (maxInboundWindowUpdateFramesPerDataFrameSent_ != null) {
        size += _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec.CalculateSizeWithTag(MaxInboundWindowUpdateFramesPerDataFrameSent);
      }
      if (StreamErrorOnInvalidHttpMessaging != false) {
        size += 1 + 1;
      }
      size += customSettingsParameters_.CalculateSize(_repeated_customSettingsParameters_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Http2ProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.hpackTableSize_ != null) {
        if (hpackTableSize_ == null || other.HpackTableSize != 0) {
          HpackTableSize = other.HpackTableSize;
        }
      }
      if (other.maxConcurrentStreams_ != null) {
        if (maxConcurrentStreams_ == null || other.MaxConcurrentStreams != 0) {
          MaxConcurrentStreams = other.MaxConcurrentStreams;
        }
      }
      if (other.initialStreamWindowSize_ != null) {
        if (initialStreamWindowSize_ == null || other.InitialStreamWindowSize != 0) {
          InitialStreamWindowSize = other.InitialStreamWindowSize;
        }
      }
      if (other.initialConnectionWindowSize_ != null) {
        if (initialConnectionWindowSize_ == null || other.InitialConnectionWindowSize != 0) {
          InitialConnectionWindowSize = other.InitialConnectionWindowSize;
        }
      }
      if (other.AllowConnect != false) {
        AllowConnect = other.AllowConnect;
      }
      if (other.AllowMetadata != false) {
        AllowMetadata = other.AllowMetadata;
      }
      if (other.maxOutboundFrames_ != null) {
        if (maxOutboundFrames_ == null || other.MaxOutboundFrames != 0) {
          MaxOutboundFrames = other.MaxOutboundFrames;
        }
      }
      if (other.maxOutboundControlFrames_ != null) {
        if (maxOutboundControlFrames_ == null || other.MaxOutboundControlFrames != 0) {
          MaxOutboundControlFrames = other.MaxOutboundControlFrames;
        }
      }
      if (other.maxConsecutiveInboundFramesWithEmptyPayload_ != null) {
        if (maxConsecutiveInboundFramesWithEmptyPayload_ == null || other.MaxConsecutiveInboundFramesWithEmptyPayload != 0) {
          MaxConsecutiveInboundFramesWithEmptyPayload = other.MaxConsecutiveInboundFramesWithEmptyPayload;
        }
      }
      if (other.maxInboundPriorityFramesPerStream_ != null) {
        if (maxInboundPriorityFramesPerStream_ == null || other.MaxInboundPriorityFramesPerStream != 0) {
          MaxInboundPriorityFramesPerStream = other.MaxInboundPriorityFramesPerStream;
        }
      }
      if (other.maxInboundWindowUpdateFramesPerDataFrameSent_ != null) {
        if (maxInboundWindowUpdateFramesPerDataFrameSent_ == null || other.MaxInboundWindowUpdateFramesPerDataFrameSent != 0) {
          MaxInboundWindowUpdateFramesPerDataFrameSent = other.MaxInboundWindowUpdateFramesPerDataFrameSent;
        }
      }
      if (other.StreamErrorOnInvalidHttpMessaging != false) {
        StreamErrorOnInvalidHttpMessaging = other.StreamErrorOnInvalidHttpMessaging;
      }
      customSettingsParameters_.Add(other.customSettingsParameters_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_hpackTableSize_codec.Read(input);
            if (hpackTableSize_ == null || value != 0) {
              HpackTableSize = value;
            }
            break;
          }
          case 18: {
            uint? value = _single_maxConcurrentStreams_codec.Read(input);
            if (maxConcurrentStreams_ == null || value != 0) {
              MaxConcurrentStreams = value;
            }
            break;
          }
          case 26: {
            uint? value = _single_initialStreamWindowSize_codec.Read(input);
            if (initialStreamWindowSize_ == null || value != 0) {
              InitialStreamWindowSize = value;
            }
            break;
          }
          case 34: {
            uint? value = _single_initialConnectionWindowSize_codec.Read(input);
            if (initialConnectionWindowSize_ == null || value != 0) {
              InitialConnectionWindowSize = value;
            }
            break;
          }
          case 40: {
            AllowConnect = input.ReadBool();
            break;
          }
          case 48: {
            AllowMetadata = input.ReadBool();
            break;
          }
          case 58: {
            uint? value = _single_maxOutboundFrames_codec.Read(input);
            if (maxOutboundFrames_ == null || value != 0) {
              MaxOutboundFrames = value;
            }
            break;
          }
          case 66: {
            uint? value = _single_maxOutboundControlFrames_codec.Read(input);
            if (maxOutboundControlFrames_ == null || value != 0) {
              MaxOutboundControlFrames = value;
            }
            break;
          }
          case 74: {
            uint? value = _single_maxConsecutiveInboundFramesWithEmptyPayload_codec.Read(input);
            if (maxConsecutiveInboundFramesWithEmptyPayload_ == null || value != 0) {
              MaxConsecutiveInboundFramesWithEmptyPayload = value;
            }
            break;
          }
          case 82: {
            uint? value = _single_maxInboundPriorityFramesPerStream_codec.Read(input);
            if (maxInboundPriorityFramesPerStream_ == null || value != 0) {
              MaxInboundPriorityFramesPerStream = value;
            }
            break;
          }
          case 90: {
            uint? value = _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec.Read(input);
            if (maxInboundWindowUpdateFramesPerDataFrameSent_ == null || value != 0) {
              MaxInboundWindowUpdateFramesPerDataFrameSent = value;
            }
            break;
          }
          case 96: {
            StreamErrorOnInvalidHttpMessaging = input.ReadBool();
            break;
          }
          case 106: {
            customSettingsParameters_.AddEntriesFrom(input, _repeated_customSettingsParameters_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            uint? value = _single_hpackTableSize_codec.Read(ref input);
            if (hpackTableSize_ == null || value != 0) {
              HpackTableSize = value;
            }
            break;
          }
          case 18: {
            uint? value = _single_maxConcurrentStreams_codec.Read(ref input);
            if (maxConcurrentStreams_ == null || value != 0) {
              MaxConcurrentStreams = value;
            }
            break;
          }
          case 26: {
            uint? value = _single_initialStreamWindowSize_codec.Read(ref input);
            if (initialStreamWindowSize_ == null || value != 0) {
              InitialStreamWindowSize = value;
            }
            break;
          }
          case 34: {
            uint? value = _single_initialConnectionWindowSize_codec.Read(ref input);
            if (initialConnectionWindowSize_ == null || value != 0) {
              InitialConnectionWindowSize = value;
            }
            break;
          }
          case 40: {
            AllowConnect = input.ReadBool();
            break;
          }
          case 48: {
            AllowMetadata = input.ReadBool();
            break;
          }
          case 58: {
            uint? value = _single_maxOutboundFrames_codec.Read(ref input);
            if (maxOutboundFrames_ == null || value != 0) {
              MaxOutboundFrames = value;
            }
            break;
          }
          case 66: {
            uint? value = _single_maxOutboundControlFrames_codec.Read(ref input);
            if (maxOutboundControlFrames_ == null || value != 0) {
              MaxOutboundControlFrames = value;
            }
            break;
          }
          case 74: {
            uint? value = _single_maxConsecutiveInboundFramesWithEmptyPayload_codec.Read(ref input);
            if (maxConsecutiveInboundFramesWithEmptyPayload_ == null || value != 0) {
              MaxConsecutiveInboundFramesWithEmptyPayload = value;
            }
            break;
          }
          case 82: {
            uint? value = _single_maxInboundPriorityFramesPerStream_codec.Read(ref input);
            if (maxInboundPriorityFramesPerStream_ == null || value != 0) {
              MaxInboundPriorityFramesPerStream = value;
            }
            break;
          }
          case 90: {
            uint? value = _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec.Read(ref input);
            if (maxInboundWindowUpdateFramesPerDataFrameSent_ == null || value != 0) {
              MaxInboundWindowUpdateFramesPerDataFrameSent = value;
            }
            break;
          }
          case 96: {
            StreamErrorOnInvalidHttpMessaging = input.ReadBool();
            break;
          }
          case 106: {
            customSettingsParameters_.AddEntriesFrom(ref input, _repeated_customSettingsParameters_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Http2ProtocolOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Defines a parameter to be sent in the SETTINGS frame.
      /// See `RFC7540, sec. 6.5.1 &lt;https://tools.ietf.org/html/rfc7540#section-6.5.1>`_ for details.
      /// </summary>
      public sealed partial class SettingsParameter : pb::IMessage<SettingsParameter>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SettingsParameter> _parser = new pb::MessageParser<SettingsParameter>(() => new SettingsParameter());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<SettingsParameter> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Core.Http2ProtocolOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SettingsParameter() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SettingsParameter(SettingsParameter other) : this() {
          Identifier = other.Identifier;
          Value = other.Value;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SettingsParameter Clone() {
          return new SettingsParameter(this);
        }

        /// <summary>Field number for the "identifier" field.</summary>
        public const int IdentifierFieldNumber = 1;
        private static readonly pb::FieldCodec<uint?> _single_identifier_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
        private uint? identifier_;
        /// <summary>
        /// The 16 bit parameter identifier.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint? Identifier {
          get { return identifier_; }
          set {
            identifier_ = value;
          }
        }


        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 2;
        private static readonly pb::FieldCodec<uint?> _single_value_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
        private uint? value_;
        /// <summary>
        /// The 32 bit parameter value.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint? Value {
          get { return value_; }
          set {
            value_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as SettingsParameter);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(SettingsParameter other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Identifier != other.Identifier) return false;
          if (Value != other.Value) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (identifier_ != null) hash ^= Identifier.GetHashCode();
          if (value_ != null) hash ^= Value.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (identifier_ != null) {
            _single_identifier_codec.WriteTagAndValue(output, Identifier);
          }
          if (value_ != null) {
            _single_value_codec.WriteTagAndValue(output, Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (identifier_ != null) {
            _single_identifier_codec.WriteTagAndValue(ref output, Identifier);
          }
          if (value_ != null) {
            _single_value_codec.WriteTagAndValue(ref output, Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (identifier_ != null) {
            size += _single_identifier_codec.CalculateSizeWithTag(Identifier);
          }
          if (value_ != null) {
            size += _single_value_codec.CalculateSizeWithTag(Value);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(SettingsParameter other) {
          if (other == null) {
            return;
          }
          if (other.identifier_ != null) {
            if (identifier_ == null || other.Identifier != 0) {
              Identifier = other.Identifier;
            }
          }
          if (other.value_ != null) {
            if (value_ == null || other.Value != 0) {
              Value = other.Value;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                uint? value = _single_identifier_codec.Read(input);
                if (identifier_ == null || value != 0) {
                  Identifier = value;
                }
                break;
              }
              case 18: {
                uint? value = _single_value_codec.Read(input);
                if (value_ == null || value != 0) {
                  Value = value;
                }
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                uint? value = _single_identifier_codec.Read(ref input);
                if (identifier_ == null || value != 0) {
                  Identifier = value;
                }
                break;
              }
              case 18: {
                uint? value = _single_value_codec.Read(ref input);
                if (value_ == null || value != 0) {
                  Value = value;
                }
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// [#not-implemented-hide:]
  /// </summary>
  public sealed partial class GrpcProtocolOptions : pb::IMessage<GrpcProtocolOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GrpcProtocolOptions> _parser = new pb::MessageParser<GrpcProtocolOptions>(() => new GrpcProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<GrpcProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GrpcProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GrpcProtocolOptions(GrpcProtocolOptions other) : this() {
      http2ProtocolOptions_ = other.http2ProtocolOptions_ != null ? other.http2ProtocolOptions_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GrpcProtocolOptions Clone() {
      return new GrpcProtocolOptions(this);
    }

    /// <summary>Field number for the "http2_protocol_options" field.</summary>
    public const int Http2ProtocolOptionsFieldNumber = 1;
    private global::Envoy.Api.V2.Core.Http2ProtocolOptions http2ProtocolOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.Http2ProtocolOptions Http2ProtocolOptions {
      get { return http2ProtocolOptions_; }
      set {
        http2ProtocolOptions_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as GrpcProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(GrpcProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Http2ProtocolOptions, other.Http2ProtocolOptions)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (http2ProtocolOptions_ != null) hash ^= Http2ProtocolOptions.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (http2ProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Http2ProtocolOptions);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(GrpcProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.http2ProtocolOptions_ != null) {
        if (http2ProtocolOptions_ == null) {
          Http2ProtocolOptions = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
        }
        Http2ProtocolOptions.MergeFrom(other.Http2ProtocolOptions);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (http2ProtocolOptions_ == null) {
              Http2ProtocolOptions = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
            }
            input.ReadMessage(Http2ProtocolOptions);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (http2ProtocolOptions_ == null) {
              Http2ProtocolOptions = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
            }
            input.ReadMessage(Http2ProtocolOptions);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
