// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Extensions.Common.DynamicForwardProxy.V3 {

  /// <summary>Holder for reflection information generated from envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto</summary>
  public static partial class DnsCacheReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static DnsCacheReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CkBlbnZveS9leHRlbnNpb25zL2NvbW1vbi9keW5hbWljX2ZvcndhcmRfcHJv",
            "eHkvdjMvZG5zX2NhY2hlLnByb3RvEjBlbnZveS5leHRlbnNpb25zLmNvbW1v",
            "bi5keW5hbWljX2ZvcndhcmRfcHJveHkudjMaJWVudm95L2NvbmZpZy9jbHVz",
            "dGVyL3YzL2NsdXN0ZXIucHJvdG8aLWVudm95L2NvbmZpZy9jb21tb24va2V5",
            "X3ZhbHVlL3YzL2NvbmZpZy5wcm90bxoiZW52b3kvY29uZmlnL2NvcmUvdjMv",
            "YWRkcmVzcy5wcm90bxokZW52b3kvY29uZmlnL2NvcmUvdjMvZXh0ZW5zaW9u",
            "LnByb3RvGiNlbnZveS9jb25maWcvY29yZS92My9yZXNvbHZlci5wcm90bxoe",
            "Z29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvGh5nb29nbGUvcHJvdG9i",
            "dWYvd3JhcHBlcnMucHJvdG8aI2Vudm95L2Fubm90YXRpb25zL2RlcHJlY2F0",
            "aW9uLnByb3RvGh11ZHBhL2Fubm90YXRpb25zL3N0YXR1cy5wcm90bxohdWRw",
            "YS9hbm5vdGF0aW9ucy92ZXJzaW9uaW5nLnByb3RvGhd2YWxpZGF0ZS92YWxp",
            "ZGF0ZS5wcm90byJVChdEbnNDYWNoZUNpcmN1aXRCcmVha2VycxI6ChRtYXhf",
            "cGVuZGluZ19yZXF1ZXN0cxgBIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50",
            "MzJWYWx1ZSLUBwoORG5zQ2FjaGVDb25maWcSFQoEbmFtZRgBIAEoCUIH+kIE",
            "cgIQARJVChFkbnNfbG9va3VwX2ZhbWlseRgCIAEoDjIwLmVudm95LmNvbmZp",
            "Zy5jbHVzdGVyLnYzLkNsdXN0ZXIuRG5zTG9va3VwRmFtaWx5Qgj6QgWCAQIQ",
            "ARJBChBkbnNfcmVmcmVzaF9yYXRlGAMgASgLMhkuZ29vZ2xlLnByb3RvYnVm",
            "LkR1cmF0aW9uQgz6QgmqAQYyBBDAhD0SNQoIaG9zdF90dGwYBCABKAsyGS5n",
            "b29nbGUucHJvdG9idWYuRHVyYXRpb25CCPpCBaoBAioAEjgKCW1heF9ob3N0",
            "cxgFIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZUIH+kIEKgIg",
            "ABJOChhkbnNfZmFpbHVyZV9yZWZyZXNoX3JhdGUYBiABKAsyLC5lbnZveS5j",
            "b25maWcuY2x1c3Rlci52My5DbHVzdGVyLlJlZnJlc2hSYXRlEmwKGWRuc19j",
            "YWNoZV9jaXJjdWl0X2JyZWFrZXIYByABKAsySS5lbnZveS5leHRlbnNpb25z",
            "LmNvbW1vbi5keW5hbWljX2ZvcndhcmRfcHJveHkudjMuRG5zQ2FjaGVDaXJj",
            "dWl0QnJlYWtlcnMSLAoXdXNlX3RjcF9mb3JfZG5zX2xvb2t1cHMYCCABKAhC",
            "CxgBkseG2AQDMy4wEkgKFWRuc19yZXNvbHV0aW9uX2NvbmZpZxgJIAEoCzIp",
            "LmVudm95LmNvbmZpZy5jb3JlLnYzLkRuc1Jlc29sdXRpb25Db25maWcSTQoZ",
            "dHlwZWRfZG5zX3Jlc29sdmVyX2NvbmZpZxgMIAEoCzIqLmVudm95LmNvbmZp",
            "Zy5jb3JlLnYzLlR5cGVkRXh0ZW5zaW9uQ29uZmlnEkEKFHByZXJlc29sdmVf",
            "aG9zdG5hbWVzGAogAygLMiMuZW52b3kuY29uZmlnLmNvcmUudjMuU29ja2V0",
            "QWRkcmVzcxI+ChFkbnNfcXVlcnlfdGltZW91dBgLIAEoCzIZLmdvb2dsZS5w",
            "cm90b2J1Zi5EdXJhdGlvbkII+kIFqgECKgASTwoQa2V5X3ZhbHVlX2NvbmZp",
            "ZxgNIAEoCzI1LmVudm95LmNvbmZpZy5jb21tb24ua2V5X3ZhbHVlLnYzLktl",
            "eVZhbHVlU3RvcmVDb25maWc6R5rFiB5CCkBlbnZveS5jb25maWcuY29tbW9u",
            "LmR5bmFtaWNfZm9yd2FyZF9wcm94eS52MmFscGhhLkRuc0NhY2hlQ29uZmln",
            "QlkKPmlvLmVudm95cHJveHkuZW52b3kuZXh0ZW5zaW9ucy5jb21tb24uZHlu",
            "YW1pY19mb3J3YXJkX3Byb3h5LnYzQg1EbnNDYWNoZVByb3RvUAG6gMjRBgIQ",
            "AmIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Cluster.V3.ClusterReflection.Descriptor, global::Envoy.Config.Common.KeyValue.V3.ConfigReflection.Descriptor, global::Envoy.Config.Core.V3.AddressReflection.Descriptor, global::Envoy.Config.Core.V3.ExtensionReflection.Descriptor, global::Envoy.Config.Core.V3.ResolverReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Envoy.Annotations.DeprecationReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Common.DynamicForwardProxy.V3.DnsCacheCircuitBreakers), global::Envoy.Extensions.Common.DynamicForwardProxy.V3.DnsCacheCircuitBreakers.Parser, new[]{ "MaxPendingRequests" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Common.DynamicForwardProxy.V3.DnsCacheConfig), global::Envoy.Extensions.Common.DynamicForwardProxy.V3.DnsCacheConfig.Parser, new[]{ "Name", "DnsLookupFamily", "DnsRefreshRate", "HostTtl", "MaxHosts", "DnsFailureRefreshRate", "DnsCacheCircuitBreaker", "UseTcpForDnsLookups", "DnsResolutionConfig", "TypedDnsResolverConfig", "PreresolveHostnames", "DnsQueryTimeout", "KeyValueConfig" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration of circuit breakers for resolver.
  /// </summary>
  public sealed partial class DnsCacheCircuitBreakers : pb::IMessage<DnsCacheCircuitBreakers>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DnsCacheCircuitBreakers> _parser = new pb::MessageParser<DnsCacheCircuitBreakers>(() => new DnsCacheCircuitBreakers());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DnsCacheCircuitBreakers> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Common.DynamicForwardProxy.V3.DnsCacheReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DnsCacheCircuitBreakers() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DnsCacheCircuitBreakers(DnsCacheCircuitBreakers other) : this() {
      MaxPendingRequests = other.MaxPendingRequests;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DnsCacheCircuitBreakers Clone() {
      return new DnsCacheCircuitBreakers(this);
    }

    /// <summary>Field number for the "max_pending_requests" field.</summary>
    public const int MaxPendingRequestsFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_maxPendingRequests_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? maxPendingRequests_;
    /// <summary>
    /// The maximum number of pending requests that Envoy will allow to the
    /// resolver. If not specified, the default is 1024.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxPendingRequests {
      get { return maxPendingRequests_; }
      set {
        maxPendingRequests_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DnsCacheCircuitBreakers);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DnsCacheCircuitBreakers other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MaxPendingRequests != other.MaxPendingRequests) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (maxPendingRequests_ != null) hash ^= MaxPendingRequests.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (maxPendingRequests_ != null) {
        _single_maxPendingRequests_codec.WriteTagAndValue(output, MaxPendingRequests);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (maxPendingRequests_ != null) {
        _single_maxPendingRequests_codec.WriteTagAndValue(ref output, MaxPendingRequests);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (maxPendingRequests_ != null) {
        size += _single_maxPendingRequests_codec.CalculateSizeWithTag(MaxPendingRequests);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DnsCacheCircuitBreakers other) {
      if (other == null) {
        return;
      }
      if (other.maxPendingRequests_ != null) {
        if (maxPendingRequests_ == null || other.MaxPendingRequests != 0) {
          MaxPendingRequests = other.MaxPendingRequests;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_maxPendingRequests_codec.Read(input);
            if (maxPendingRequests_ == null || value != 0) {
              MaxPendingRequests = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            uint? value = _single_maxPendingRequests_codec.Read(ref input);
            if (maxPendingRequests_ == null || value != 0) {
              MaxPendingRequests = value;
            }
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configuration for the dynamic forward proxy DNS cache. See the :ref:`architecture overview
  /// &lt;arch_overview_http_dynamic_forward_proxy>` for more information.
  /// [#next-free-field: 14]
  /// </summary>
  public sealed partial class DnsCacheConfig : pb::IMessage<DnsCacheConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DnsCacheConfig> _parser = new pb::MessageParser<DnsCacheConfig>(() => new DnsCacheConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DnsCacheConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Common.DynamicForwardProxy.V3.DnsCacheReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DnsCacheConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DnsCacheConfig(DnsCacheConfig other) : this() {
      name_ = other.name_;
      dnsLookupFamily_ = other.dnsLookupFamily_;
      dnsRefreshRate_ = other.dnsRefreshRate_ != null ? other.dnsRefreshRate_.Clone() : null;
      hostTtl_ = other.hostTtl_ != null ? other.hostTtl_.Clone() : null;
      MaxHosts = other.MaxHosts;
      dnsFailureRefreshRate_ = other.dnsFailureRefreshRate_ != null ? other.dnsFailureRefreshRate_.Clone() : null;
      dnsCacheCircuitBreaker_ = other.dnsCacheCircuitBreaker_ != null ? other.dnsCacheCircuitBreaker_.Clone() : null;
      useTcpForDnsLookups_ = other.useTcpForDnsLookups_;
      dnsResolutionConfig_ = other.dnsResolutionConfig_ != null ? other.dnsResolutionConfig_.Clone() : null;
      typedDnsResolverConfig_ = other.typedDnsResolverConfig_ != null ? other.typedDnsResolverConfig_.Clone() : null;
      preresolveHostnames_ = other.preresolveHostnames_.Clone();
      dnsQueryTimeout_ = other.dnsQueryTimeout_ != null ? other.dnsQueryTimeout_.Clone() : null;
      keyValueConfig_ = other.keyValueConfig_ != null ? other.keyValueConfig_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DnsCacheConfig Clone() {
      return new DnsCacheConfig(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the cache. Multiple named caches allow independent dynamic forward proxy
    /// configurations to operate within a single Envoy process using different configurations. All
    /// configurations with the same name *must* otherwise have the same settings when referenced
    /// from different configuration components. Configuration will fail to load if this is not
    /// the case.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "dns_lookup_family" field.</summary>
    public const int DnsLookupFamilyFieldNumber = 2;
    private global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily dnsLookupFamily_ = global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily.Auto;
    /// <summary>
    /// The DNS lookup family to use during resolution.
    ///
    /// [#comment:TODO(mattklein123): Figure out how to support IPv4/IPv6 "happy eyeballs" mode. The
    /// way this might work is a new lookup family which returns both IPv4 and IPv6 addresses, and
    /// then configures a host to have a primary and fall back address. With this, we could very
    /// likely build a "happy eyeballs" connection pool which would race the primary / fall back
    /// address and return the one that wins. This same method could potentially also be used for
    /// QUIC to TCP fall back.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily DnsLookupFamily {
      get { return dnsLookupFamily_; }
      set {
        dnsLookupFamily_ = value;
      }
    }

    /// <summary>Field number for the "dns_refresh_rate" field.</summary>
    public const int DnsRefreshRateFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration dnsRefreshRate_;
    /// <summary>
    /// The DNS refresh rate for currently cached DNS hosts. If not specified defaults to 60s.
    ///
    /// .. note:
    ///
    ///  The returned DNS TTL is not currently used to alter the refresh rate. This feature will be
    ///  added in a future change.
    ///
    /// .. note:
    ///
    /// The refresh rate is rounded to the closest millisecond, and must be at least 1ms.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration DnsRefreshRate {
      get { return dnsRefreshRate_; }
      set {
        dnsRefreshRate_ = value;
      }
    }

    /// <summary>Field number for the "host_ttl" field.</summary>
    public const int HostTtlFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration hostTtl_;
    /// <summary>
    /// The TTL for hosts that are unused. Hosts that have not been used in the configured time
    /// interval will be purged. If not specified defaults to 5m.
    ///
    /// .. note:
    ///
    ///   The TTL is only checked at the time of DNS refresh, as specified by *dns_refresh_rate*. This
    ///   means that if the configured TTL is shorter than the refresh rate the host may not be removed
    ///   immediately.
    ///
    ///  .. note:
    ///
    ///   The TTL has no relation to DNS TTL and is only used to control Envoy's resource usage.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration HostTtl {
      get { return hostTtl_; }
      set {
        hostTtl_ = value;
      }
    }

    /// <summary>Field number for the "max_hosts" field.</summary>
    public const int MaxHostsFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_maxHosts_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? maxHosts_;
    /// <summary>
    /// The maximum number of hosts that the cache will hold. If not specified defaults to 1024.
    ///
    /// .. note:
    ///
    ///   The implementation is approximate and enforced independently on each worker thread, thus
    ///   it is possible for the maximum hosts in the cache to go slightly above the configured
    ///   value depending on timing. This is similar to how other circuit breakers work.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxHosts {
      get { return maxHosts_; }
      set {
        maxHosts_ = value;
      }
    }


    /// <summary>Field number for the "dns_failure_refresh_rate" field.</summary>
    public const int DnsFailureRefreshRateFieldNumber = 6;
    private global::Envoy.Config.Cluster.V3.Cluster.Types.RefreshRate dnsFailureRefreshRate_;
    /// <summary>
    /// If the DNS failure refresh rate is specified,
    /// this is used as the cache's DNS refresh rate when DNS requests are failing. If this setting is
    /// not specified, the failure refresh rate defaults to the dns_refresh_rate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.RefreshRate DnsFailureRefreshRate {
      get { return dnsFailureRefreshRate_; }
      set {
        dnsFailureRefreshRate_ = value;
      }
    }

    /// <summary>Field number for the "dns_cache_circuit_breaker" field.</summary>
    public const int DnsCacheCircuitBreakerFieldNumber = 7;
    private global::Envoy.Extensions.Common.DynamicForwardProxy.V3.DnsCacheCircuitBreakers dnsCacheCircuitBreaker_;
    /// <summary>
    /// The config of circuit breakers for resolver. It provides a configurable threshold.
    /// Envoy will use dns cache circuit breakers with default settings even if this value is not set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Common.DynamicForwardProxy.V3.DnsCacheCircuitBreakers DnsCacheCircuitBreaker {
      get { return dnsCacheCircuitBreaker_; }
      set {
        dnsCacheCircuitBreaker_ = value;
      }
    }

    /// <summary>Field number for the "use_tcp_for_dns_lookups" field.</summary>
    public const int UseTcpForDnsLookupsFieldNumber = 8;
    private bool useTcpForDnsLookups_;
    /// <summary>
    /// Always use TCP queries instead of UDP queries for DNS lookups.
    /// Setting this value causes failure if the
    /// ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
    /// server startup. Apple' API only uses UDP for DNS resolution.
    /// This field is deprecated in favor of *dns_resolution_config*
    /// which aggregates all of the DNS resolver configuration in a single message.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UseTcpForDnsLookups {
      get { return useTcpForDnsLookups_; }
      set {
        useTcpForDnsLookups_ = value;
      }
    }

    /// <summary>Field number for the "dns_resolution_config" field.</summary>
    public const int DnsResolutionConfigFieldNumber = 9;
    private global::Envoy.Config.Core.V3.DnsResolutionConfig dnsResolutionConfig_;
    /// <summary>
    /// DNS resolution configuration which includes the underlying dns resolver addresses and options.
    /// *dns_resolution_config* will be deprecated once
    /// :ref:'typed_dns_resolver_config &lt;envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.typed_dns_resolver_config>'
    /// is fully supported.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.DnsResolutionConfig DnsResolutionConfig {
      get { return dnsResolutionConfig_; }
      set {
        dnsResolutionConfig_ = value;
      }
    }

    /// <summary>Field number for the "typed_dns_resolver_config" field.</summary>
    public const int TypedDnsResolverConfigFieldNumber = 12;
    private global::Envoy.Config.Core.V3.TypedExtensionConfig typedDnsResolverConfig_;
    /// <summary>
    /// DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
    /// or any other DNS resolver types and the related parameters.
    /// For example, an object of :ref:`DnsResolutionConfig &lt;envoy_v3_api_msg_config.core.v3.DnsResolutionConfig>`
    /// can be packed into this *typed_dns_resolver_config*. This configuration will replace the
    /// :ref:'dns_resolution_config &lt;envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_resolution_config>'
    /// configuration eventually.
    /// TODO(yanjunxiang): Investigate the deprecation plan for *dns_resolution_config*.
    /// During the transition period when both *dns_resolution_config* and *typed_dns_resolver_config* exists,
    /// this configuration is optional.
    /// When *typed_dns_resolver_config* is in place, Envoy will use it and ignore *dns_resolution_config*.
    /// When *typed_dns_resolver_config* is missing, the default behavior is in place.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TypedExtensionConfig TypedDnsResolverConfig {
      get { return typedDnsResolverConfig_; }
      set {
        typedDnsResolverConfig_ = value;
      }
    }

    /// <summary>Field number for the "preresolve_hostnames" field.</summary>
    public const int PreresolveHostnamesFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.SocketAddress> _repeated_preresolveHostnames_codec
        = pb::FieldCodec.ForMessage(82, global::Envoy.Config.Core.V3.SocketAddress.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.SocketAddress> preresolveHostnames_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.SocketAddress>();
    /// <summary>
    /// Hostnames that should be preresolved into the cache upon creation. This might provide a
    /// performance improvement, in the form of cache hits, for hostnames that are going to be
    /// resolved during steady state and are known at config load time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.SocketAddress> PreresolveHostnames {
      get { return preresolveHostnames_; }
    }

    /// <summary>Field number for the "dns_query_timeout" field.</summary>
    public const int DnsQueryTimeoutFieldNumber = 11;
    private global::Google.Protobuf.WellKnownTypes.Duration dnsQueryTimeout_;
    /// <summary>
    /// The timeout used for DNS queries. This timeout is independent of any timeout and retry policy
    /// used by the underlying DNS implementation (e.g., c-areas and Apple DNS) which are opaque.
    /// Setting this timeout will ensure that queries succeed or fail within the specified time frame
    /// and are then retried using the standard refresh rates. Defaults to 5s if not set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration DnsQueryTimeout {
      get { return dnsQueryTimeout_; }
      set {
        dnsQueryTimeout_ = value;
      }
    }

    /// <summary>Field number for the "key_value_config" field.</summary>
    public const int KeyValueConfigFieldNumber = 13;
    private global::Envoy.Config.Common.KeyValue.V3.KeyValueStoreConfig keyValueConfig_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// Configuration to flush the DNS cache to long term storage.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Common.KeyValue.V3.KeyValueStoreConfig KeyValueConfig {
      get { return keyValueConfig_; }
      set {
        keyValueConfig_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DnsCacheConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DnsCacheConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DnsLookupFamily != other.DnsLookupFamily) return false;
      if (!object.Equals(DnsRefreshRate, other.DnsRefreshRate)) return false;
      if (!object.Equals(HostTtl, other.HostTtl)) return false;
      if (MaxHosts != other.MaxHosts) return false;
      if (!object.Equals(DnsFailureRefreshRate, other.DnsFailureRefreshRate)) return false;
      if (!object.Equals(DnsCacheCircuitBreaker, other.DnsCacheCircuitBreaker)) return false;
      if (UseTcpForDnsLookups != other.UseTcpForDnsLookups) return false;
      if (!object.Equals(DnsResolutionConfig, other.DnsResolutionConfig)) return false;
      if (!object.Equals(TypedDnsResolverConfig, other.TypedDnsResolverConfig)) return false;
      if(!preresolveHostnames_.Equals(other.preresolveHostnames_)) return false;
      if (!object.Equals(DnsQueryTimeout, other.DnsQueryTimeout)) return false;
      if (!object.Equals(KeyValueConfig, other.KeyValueConfig)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DnsLookupFamily != global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily.Auto) hash ^= DnsLookupFamily.GetHashCode();
      if (dnsRefreshRate_ != null) hash ^= DnsRefreshRate.GetHashCode();
      if (hostTtl_ != null) hash ^= HostTtl.GetHashCode();
      if (maxHosts_ != null) hash ^= MaxHosts.GetHashCode();
      if (dnsFailureRefreshRate_ != null) hash ^= DnsFailureRefreshRate.GetHashCode();
      if (dnsCacheCircuitBreaker_ != null) hash ^= DnsCacheCircuitBreaker.GetHashCode();
      if (UseTcpForDnsLookups != false) hash ^= UseTcpForDnsLookups.GetHashCode();
      if (dnsResolutionConfig_ != null) hash ^= DnsResolutionConfig.GetHashCode();
      if (typedDnsResolverConfig_ != null) hash ^= TypedDnsResolverConfig.GetHashCode();
      hash ^= preresolveHostnames_.GetHashCode();
      if (dnsQueryTimeout_ != null) hash ^= DnsQueryTimeout.GetHashCode();
      if (keyValueConfig_ != null) hash ^= KeyValueConfig.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DnsLookupFamily != global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily.Auto) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DnsLookupFamily);
      }
      if (dnsRefreshRate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(DnsRefreshRate);
      }
      if (hostTtl_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(HostTtl);
      }
      if (maxHosts_ != null) {
        _single_maxHosts_codec.WriteTagAndValue(output, MaxHosts);
      }
      if (dnsFailureRefreshRate_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(DnsFailureRefreshRate);
      }
      if (dnsCacheCircuitBreaker_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DnsCacheCircuitBreaker);
      }
      if (UseTcpForDnsLookups != false) {
        output.WriteRawTag(64);
        output.WriteBool(UseTcpForDnsLookups);
      }
      if (dnsResolutionConfig_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(DnsResolutionConfig);
      }
      preresolveHostnames_.WriteTo(output, _repeated_preresolveHostnames_codec);
      if (dnsQueryTimeout_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(DnsQueryTimeout);
      }
      if (typedDnsResolverConfig_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(TypedDnsResolverConfig);
      }
      if (keyValueConfig_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(KeyValueConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DnsLookupFamily != global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily.Auto) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DnsLookupFamily);
      }
      if (dnsRefreshRate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(DnsRefreshRate);
      }
      if (hostTtl_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(HostTtl);
      }
      if (maxHosts_ != null) {
        _single_maxHosts_codec.WriteTagAndValue(ref output, MaxHosts);
      }
      if (dnsFailureRefreshRate_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(DnsFailureRefreshRate);
      }
      if (dnsCacheCircuitBreaker_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DnsCacheCircuitBreaker);
      }
      if (UseTcpForDnsLookups != false) {
        output.WriteRawTag(64);
        output.WriteBool(UseTcpForDnsLookups);
      }
      if (dnsResolutionConfig_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(DnsResolutionConfig);
      }
      preresolveHostnames_.WriteTo(ref output, _repeated_preresolveHostnames_codec);
      if (dnsQueryTimeout_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(DnsQueryTimeout);
      }
      if (typedDnsResolverConfig_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(TypedDnsResolverConfig);
      }
      if (keyValueConfig_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(KeyValueConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DnsLookupFamily != global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily.Auto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DnsLookupFamily);
      }
      if (dnsRefreshRate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DnsRefreshRate);
      }
      if (hostTtl_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HostTtl);
      }
      if (maxHosts_ != null) {
        size += _single_maxHosts_codec.CalculateSizeWithTag(MaxHosts);
      }
      if (dnsFailureRefreshRate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DnsFailureRefreshRate);
      }
      if (dnsCacheCircuitBreaker_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DnsCacheCircuitBreaker);
      }
      if (UseTcpForDnsLookups != false) {
        size += 1 + 1;
      }
      if (dnsResolutionConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DnsResolutionConfig);
      }
      if (typedDnsResolverConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedDnsResolverConfig);
      }
      size += preresolveHostnames_.CalculateSize(_repeated_preresolveHostnames_codec);
      if (dnsQueryTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DnsQueryTimeout);
      }
      if (keyValueConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeyValueConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DnsCacheConfig other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DnsLookupFamily != global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily.Auto) {
        DnsLookupFamily = other.DnsLookupFamily;
      }
      if (other.dnsRefreshRate_ != null) {
        if (dnsRefreshRate_ == null) {
          DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DnsRefreshRate.MergeFrom(other.DnsRefreshRate);
      }
      if (other.hostTtl_ != null) {
        if (hostTtl_ == null) {
          HostTtl = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        HostTtl.MergeFrom(other.HostTtl);
      }
      if (other.maxHosts_ != null) {
        if (maxHosts_ == null || other.MaxHosts != 0) {
          MaxHosts = other.MaxHosts;
        }
      }
      if (other.dnsFailureRefreshRate_ != null) {
        if (dnsFailureRefreshRate_ == null) {
          DnsFailureRefreshRate = new global::Envoy.Config.Cluster.V3.Cluster.Types.RefreshRate();
        }
        DnsFailureRefreshRate.MergeFrom(other.DnsFailureRefreshRate);
      }
      if (other.dnsCacheCircuitBreaker_ != null) {
        if (dnsCacheCircuitBreaker_ == null) {
          DnsCacheCircuitBreaker = new global::Envoy.Extensions.Common.DynamicForwardProxy.V3.DnsCacheCircuitBreakers();
        }
        DnsCacheCircuitBreaker.MergeFrom(other.DnsCacheCircuitBreaker);
      }
      if (other.UseTcpForDnsLookups != false) {
        UseTcpForDnsLookups = other.UseTcpForDnsLookups;
      }
      if (other.dnsResolutionConfig_ != null) {
        if (dnsResolutionConfig_ == null) {
          DnsResolutionConfig = new global::Envoy.Config.Core.V3.DnsResolutionConfig();
        }
        DnsResolutionConfig.MergeFrom(other.DnsResolutionConfig);
      }
      if (other.typedDnsResolverConfig_ != null) {
        if (typedDnsResolverConfig_ == null) {
          TypedDnsResolverConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
        }
        TypedDnsResolverConfig.MergeFrom(other.TypedDnsResolverConfig);
      }
      preresolveHostnames_.Add(other.preresolveHostnames_);
      if (other.dnsQueryTimeout_ != null) {
        if (dnsQueryTimeout_ == null) {
          DnsQueryTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DnsQueryTimeout.MergeFrom(other.DnsQueryTimeout);
      }
      if (other.keyValueConfig_ != null) {
        if (keyValueConfig_ == null) {
          KeyValueConfig = new global::Envoy.Config.Common.KeyValue.V3.KeyValueStoreConfig();
        }
        KeyValueConfig.MergeFrom(other.KeyValueConfig);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            DnsLookupFamily = (global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily) input.ReadEnum();
            break;
          }
          case 26: {
            if (dnsRefreshRate_ == null) {
              DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DnsRefreshRate);
            break;
          }
          case 34: {
            if (hostTtl_ == null) {
              HostTtl = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(HostTtl);
            break;
          }
          case 42: {
            uint? value = _single_maxHosts_codec.Read(input);
            if (maxHosts_ == null || value != 0) {
              MaxHosts = value;
            }
            break;
          }
          case 50: {
            if (dnsFailureRefreshRate_ == null) {
              DnsFailureRefreshRate = new global::Envoy.Config.Cluster.V3.Cluster.Types.RefreshRate();
            }
            input.ReadMessage(DnsFailureRefreshRate);
            break;
          }
          case 58: {
            if (dnsCacheCircuitBreaker_ == null) {
              DnsCacheCircuitBreaker = new global::Envoy.Extensions.Common.DynamicForwardProxy.V3.DnsCacheCircuitBreakers();
            }
            input.ReadMessage(DnsCacheCircuitBreaker);
            break;
          }
          case 64: {
            UseTcpForDnsLookups = input.ReadBool();
            break;
          }
          case 74: {
            if (dnsResolutionConfig_ == null) {
              DnsResolutionConfig = new global::Envoy.Config.Core.V3.DnsResolutionConfig();
            }
            input.ReadMessage(DnsResolutionConfig);
            break;
          }
          case 82: {
            preresolveHostnames_.AddEntriesFrom(input, _repeated_preresolveHostnames_codec);
            break;
          }
          case 90: {
            if (dnsQueryTimeout_ == null) {
              DnsQueryTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DnsQueryTimeout);
            break;
          }
          case 98: {
            if (typedDnsResolverConfig_ == null) {
              TypedDnsResolverConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(TypedDnsResolverConfig);
            break;
          }
          case 106: {
            if (keyValueConfig_ == null) {
              KeyValueConfig = new global::Envoy.Config.Common.KeyValue.V3.KeyValueStoreConfig();
            }
            input.ReadMessage(KeyValueConfig);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            DnsLookupFamily = (global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily) input.ReadEnum();
            break;
          }
          case 26: {
            if (dnsRefreshRate_ == null) {
              DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DnsRefreshRate);
            break;
          }
          case 34: {
            if (hostTtl_ == null) {
              HostTtl = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(HostTtl);
            break;
          }
          case 42: {
            uint? value = _single_maxHosts_codec.Read(ref input);
            if (maxHosts_ == null || value != 0) {
              MaxHosts = value;
            }
            break;
          }
          case 50: {
            if (dnsFailureRefreshRate_ == null) {
              DnsFailureRefreshRate = new global::Envoy.Config.Cluster.V3.Cluster.Types.RefreshRate();
            }
            input.ReadMessage(DnsFailureRefreshRate);
            break;
          }
          case 58: {
            if (dnsCacheCircuitBreaker_ == null) {
              DnsCacheCircuitBreaker = new global::Envoy.Extensions.Common.DynamicForwardProxy.V3.DnsCacheCircuitBreakers();
            }
            input.ReadMessage(DnsCacheCircuitBreaker);
            break;
          }
          case 64: {
            UseTcpForDnsLookups = input.ReadBool();
            break;
          }
          case 74: {
            if (dnsResolutionConfig_ == null) {
              DnsResolutionConfig = new global::Envoy.Config.Core.V3.DnsResolutionConfig();
            }
            input.ReadMessage(DnsResolutionConfig);
            break;
          }
          case 82: {
            preresolveHostnames_.AddEntriesFrom(ref input, _repeated_preresolveHostnames_codec);
            break;
          }
          case 90: {
            if (dnsQueryTimeout_ == null) {
              DnsQueryTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DnsQueryTimeout);
            break;
          }
          case 98: {
            if (typedDnsResolverConfig_ == null) {
              TypedDnsResolverConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(TypedDnsResolverConfig);
            break;
          }
          case 106: {
            if (keyValueConfig_ == null) {
              KeyValueConfig = new global::Envoy.Config.Common.KeyValue.V3.KeyValueStoreConfig();
            }
            input.ReadMessage(KeyValueConfig);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
