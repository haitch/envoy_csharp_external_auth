// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/extensions/wasm/v3/wasm.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Extensions.Wasm.V3 {

  /// <summary>Holder for reflection information generated from envoy/extensions/wasm/v3/wasm.proto</summary>
  public static partial class WasmReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/extensions/wasm/v3/wasm.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static WasmReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiNlbnZveS9leHRlbnNpb25zL3dhc20vdjMvd2FzbS5wcm90bxIYZW52b3ku",
            "ZXh0ZW5zaW9ucy53YXNtLnYzGh9lbnZveS9jb25maWcvY29yZS92My9iYXNl",
            "LnByb3RvGhlnb29nbGUvcHJvdG9idWYvYW55LnByb3RvGh11ZHBhL2Fubm90",
            "YXRpb25zL3N0YXR1cy5wcm90bxoXdmFsaWRhdGUvdmFsaWRhdGUucHJvdG8i",
            "9QEKG0NhcGFiaWxpdHlSZXN0cmljdGlvbkNvbmZpZxJsChRhbGxvd2VkX2Nh",
            "cGFiaWxpdGllcxgBIAMoCzJOLmVudm95LmV4dGVuc2lvbnMud2FzbS52My5D",
            "YXBhYmlsaXR5UmVzdHJpY3Rpb25Db25maWcuQWxsb3dlZENhcGFiaWxpdGll",
            "c0VudHJ5GmgKGEFsbG93ZWRDYXBhYmlsaXRpZXNFbnRyeRILCgNrZXkYASAB",
            "KAkSOwoFdmFsdWUYAiABKAsyLC5lbnZveS5leHRlbnNpb25zLndhc20udjMu",
            "U2FuaXRpemF0aW9uQ29uZmlnOgI4ASIUChJTYW5pdGl6YXRpb25Db25maWci",
            "oAIKCFZtQ29uZmlnEg0KBXZtX2lkGAEgASgJEhgKB3J1bnRpbWUYAiABKAlC",
            "B/pCBHICEAESMwoEY29kZRgDIAEoCzIlLmVudm95LmNvbmZpZy5jb3JlLnYz",
            "LkFzeW5jRGF0YVNvdXJjZRIrCg1jb25maWd1cmF0aW9uGAQgASgLMhQuZ29v",
            "Z2xlLnByb3RvYnVmLkFueRIZChFhbGxvd19wcmVjb21waWxlZBgFIAEoCBIf",
            "ChduYWNrX29uX2NvZGVfY2FjaGVfbWlzcxgGIAEoCBJNChVlbnZpcm9ubWVu",
            "dF92YXJpYWJsZXMYByABKAsyLi5lbnZveS5leHRlbnNpb25zLndhc20udjMu",
            "RW52aXJvbm1lbnRWYXJpYWJsZXMisgEKFEVudmlyb25tZW50VmFyaWFibGVz",
            "EhUKDWhvc3RfZW52X2tleXMYASADKAkSUQoKa2V5X3ZhbHVlcxgCIAMoCzI9",
            "LmVudm95LmV4dGVuc2lvbnMud2FzbS52My5FbnZpcm9ubWVudFZhcmlhYmxl",
            "cy5LZXlWYWx1ZXNFbnRyeRowCg5LZXlWYWx1ZXNFbnRyeRILCgNrZXkYASAB",
            "KAkSDQoFdmFsdWUYAiABKAk6AjgBIooCCgxQbHVnaW5Db25maWcSDAoEbmFt",
            "ZRgBIAEoCRIPCgdyb290X2lkGAIgASgJEjcKCXZtX2NvbmZpZxgDIAEoCzIi",
            "LmVudm95LmV4dGVuc2lvbnMud2FzbS52My5WbUNvbmZpZ0gAEisKDWNvbmZp",
            "Z3VyYXRpb24YBCABKAsyFC5nb29nbGUucHJvdG9idWYuQW55EhEKCWZhaWxf",
            "b3BlbhgFIAEoCBJcCh1jYXBhYmlsaXR5X3Jlc3RyaWN0aW9uX2NvbmZpZxgG",
            "IAEoCzI1LmVudm95LmV4dGVuc2lvbnMud2FzbS52My5DYXBhYmlsaXR5UmVz",
            "dHJpY3Rpb25Db25maWdCBAoCdm0iWAoLV2FzbVNlcnZpY2USNgoGY29uZmln",
            "GAEgASgLMiYuZW52b3kuZXh0ZW5zaW9ucy53YXNtLnYzLlBsdWdpbkNvbmZp",
            "ZxIRCglzaW5nbGV0b24YAiABKAhCPQomaW8uZW52b3lwcm94eS5lbnZveS5l",
            "eHRlbnNpb25zLndhc20udjNCCVdhc21Qcm90b1ABuoDI0QYCEAJiBnByb3Rv",
            "Mw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Core.V3.BaseReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Wasm.V3.CapabilityRestrictionConfig), global::Envoy.Extensions.Wasm.V3.CapabilityRestrictionConfig.Parser, new[]{ "AllowedCapabilities" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Wasm.V3.SanitizationConfig), global::Envoy.Extensions.Wasm.V3.SanitizationConfig.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Wasm.V3.VmConfig), global::Envoy.Extensions.Wasm.V3.VmConfig.Parser, new[]{ "VmId", "Runtime", "Code", "Configuration", "AllowPrecompiled", "NackOnCodeCacheMiss", "EnvironmentVariables" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Wasm.V3.EnvironmentVariables), global::Envoy.Extensions.Wasm.V3.EnvironmentVariables.Parser, new[]{ "HostEnvKeys", "KeyValues" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Wasm.V3.PluginConfig), global::Envoy.Extensions.Wasm.V3.PluginConfig.Parser, new[]{ "Name", "RootId", "VmConfig", "Configuration", "FailOpen", "CapabilityRestrictionConfig" }, new[]{ "Vm" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Wasm.V3.WasmService), global::Envoy.Extensions.Wasm.V3.WasmService.Parser, new[]{ "Config", "Singleton" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration for restricting Proxy-Wasm capabilities available to modules.
  /// </summary>
  public sealed partial class CapabilityRestrictionConfig : pb::IMessage<CapabilityRestrictionConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CapabilityRestrictionConfig> _parser = new pb::MessageParser<CapabilityRestrictionConfig>(() => new CapabilityRestrictionConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CapabilityRestrictionConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Wasm.V3.WasmReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CapabilityRestrictionConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CapabilityRestrictionConfig(CapabilityRestrictionConfig other) : this() {
      allowedCapabilities_ = other.allowedCapabilities_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CapabilityRestrictionConfig Clone() {
      return new CapabilityRestrictionConfig(this);
    }

    /// <summary>Field number for the "allowed_capabilities" field.</summary>
    public const int AllowedCapabilitiesFieldNumber = 1;
    private static readonly pbc::MapField<string, global::Envoy.Extensions.Wasm.V3.SanitizationConfig>.Codec _map_allowedCapabilities_codec
        = new pbc::MapField<string, global::Envoy.Extensions.Wasm.V3.SanitizationConfig>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Envoy.Extensions.Wasm.V3.SanitizationConfig.Parser), 10);
    private readonly pbc::MapField<string, global::Envoy.Extensions.Wasm.V3.SanitizationConfig> allowedCapabilities_ = new pbc::MapField<string, global::Envoy.Extensions.Wasm.V3.SanitizationConfig>();
    /// <summary>
    /// The Proxy-Wasm capabilities which will be allowed. Capabilities are mapped by
    /// name. The *SanitizationConfig* which each capability maps to is currently unimplemented and ignored,
    /// and so should be left empty.
    ///
    /// The capability names are given in the
    /// `Proxy-Wasm ABI &lt;https://github.com/proxy-wasm/spec/tree/master/abi-versions/vNEXT>`_.
    /// Additionally, the following WASI capabilities from
    /// `this list &lt;https://github.com/WebAssembly/WASI/blob/master/phases/snapshot/docs.md#modules>`_
    /// are implemented and can be allowed:
    /// *fd_write*, *fd_read*, *fd_seek*, *fd_close*, *fd_fdstat_get*, *environ_get*, *environ_sizes_get*,
    /// *args_get*, *args_sizes_get*, *proc_exit*, *clock_time_get*, *random_get*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Envoy.Extensions.Wasm.V3.SanitizationConfig> AllowedCapabilities {
      get { return allowedCapabilities_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CapabilityRestrictionConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CapabilityRestrictionConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!AllowedCapabilities.Equals(other.AllowedCapabilities)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= AllowedCapabilities.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      allowedCapabilities_.WriteTo(output, _map_allowedCapabilities_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      allowedCapabilities_.WriteTo(ref output, _map_allowedCapabilities_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += allowedCapabilities_.CalculateSize(_map_allowedCapabilities_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CapabilityRestrictionConfig other) {
      if (other == null) {
        return;
      }
      allowedCapabilities_.Add(other.allowedCapabilities_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            allowedCapabilities_.AddEntriesFrom(input, _map_allowedCapabilities_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            allowedCapabilities_.AddEntriesFrom(ref input, _map_allowedCapabilities_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configuration for sanitization of inputs to an allowed capability.
  ///
  /// NOTE: This is currently unimplemented.
  /// </summary>
  public sealed partial class SanitizationConfig : pb::IMessage<SanitizationConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SanitizationConfig> _parser = new pb::MessageParser<SanitizationConfig>(() => new SanitizationConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SanitizationConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Wasm.V3.WasmReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SanitizationConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SanitizationConfig(SanitizationConfig other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SanitizationConfig Clone() {
      return new SanitizationConfig(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SanitizationConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SanitizationConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SanitizationConfig other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configuration for a Wasm VM.
  /// [#next-free-field: 8]
  /// </summary>
  public sealed partial class VmConfig : pb::IMessage<VmConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VmConfig> _parser = new pb::MessageParser<VmConfig>(() => new VmConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VmConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Wasm.V3.WasmReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VmConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VmConfig(VmConfig other) : this() {
      vmId_ = other.vmId_;
      runtime_ = other.runtime_;
      code_ = other.code_ != null ? other.code_.Clone() : null;
      configuration_ = other.configuration_ != null ? other.configuration_.Clone() : null;
      allowPrecompiled_ = other.allowPrecompiled_;
      nackOnCodeCacheMiss_ = other.nackOnCodeCacheMiss_;
      environmentVariables_ = other.environmentVariables_ != null ? other.environmentVariables_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VmConfig Clone() {
      return new VmConfig(this);
    }

    /// <summary>Field number for the "vm_id" field.</summary>
    public const int VmIdFieldNumber = 1;
    private string vmId_ = "";
    /// <summary>
    /// An ID which will be used along with a hash of the wasm code (or the name of the registered Null
    /// VM plugin) to determine which VM will be used for the plugin. All plugins which use the same
    /// *vm_id* and code will use the same VM. May be left blank. Sharing a VM between plugins can
    /// reduce memory utilization and make sharing of data easier which may have security implications.
    /// [#comment: TODO: add ref for details.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VmId {
      get { return vmId_; }
      set {
        vmId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "runtime" field.</summary>
    public const int RuntimeFieldNumber = 2;
    private string runtime_ = "";
    /// <summary>
    /// The Wasm runtime type.
    /// Available Wasm runtime types are registered as extensions. The following runtimes are included
    /// in Envoy code base:
    ///
    /// .. _extension_envoy.wasm.runtime.null:
    ///
    /// **envoy.wasm.runtime.null**: Null sandbox, the Wasm module must be compiled and linked into the
    /// Envoy binary. The registered name is given in the *code* field as *inline_string*.
    ///
    /// .. _extension_envoy.wasm.runtime.v8:
    ///
    /// **envoy.wasm.runtime.v8**: `V8 &lt;https://v8.dev/>`_-based WebAssembly runtime.
    ///
    /// .. _extension_envoy.wasm.runtime.wamr:
    ///
    /// **envoy.wasm.runtime.wamr**: `WAMR &lt;https://github.com/bytecodealliance/wasm-micro-runtime/>`_-based WebAssembly runtime.
    /// This runtime is not enabled in the official build.
    ///
    /// .. _extension_envoy.wasm.runtime.wavm:
    ///
    /// **envoy.wasm.runtime.wavm**: `WAVM &lt;https://wavm.github.io/>`_-based WebAssembly runtime.
    /// This runtime is not enabled in the official build.
    ///
    /// .. _extension_envoy.wasm.runtime.wasmtime:
    ///
    /// **envoy.wasm.runtime.wasmtime**: `Wasmtime &lt;https://wasmtime.dev/>`_-based WebAssembly runtime.
    /// This runtime is not enabled in the official build.
    ///
    /// [#extension-category: envoy.wasm.runtime]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Runtime {
      get { return runtime_; }
      set {
        runtime_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "code" field.</summary>
    public const int CodeFieldNumber = 3;
    private global::Envoy.Config.Core.V3.AsyncDataSource code_;
    /// <summary>
    /// The Wasm code that Envoy will execute.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.AsyncDataSource Code {
      get { return code_; }
      set {
        code_ = value;
      }
    }

    /// <summary>Field number for the "configuration" field.</summary>
    public const int ConfigurationFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Any configuration_;
    /// <summary>
    /// The Wasm configuration used in initialization of a new VM
    /// (proxy_on_start). `google.protobuf.Struct` is serialized as JSON before
    /// passing it to the plugin. `google.protobuf.BytesValue` and
    /// `google.protobuf.StringValue` are passed directly without the wrapper.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Any Configuration {
      get { return configuration_; }
      set {
        configuration_ = value;
      }
    }

    /// <summary>Field number for the "allow_precompiled" field.</summary>
    public const int AllowPrecompiledFieldNumber = 5;
    private bool allowPrecompiled_;
    /// <summary>
    /// Allow the wasm file to include pre-compiled code on VMs which support it.
    /// Warning: this should only be enable for trusted sources as the precompiled code is not
    /// verified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowPrecompiled {
      get { return allowPrecompiled_; }
      set {
        allowPrecompiled_ = value;
      }
    }

    /// <summary>Field number for the "nack_on_code_cache_miss" field.</summary>
    public const int NackOnCodeCacheMissFieldNumber = 6;
    private bool nackOnCodeCacheMiss_;
    /// <summary>
    /// If true and the code needs to be remotely fetched and it is not in the cache then NACK the configuration
    /// update and do a background fetch to fill the cache, otherwise fetch the code asynchronously and enter
    /// warming state.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool NackOnCodeCacheMiss {
      get { return nackOnCodeCacheMiss_; }
      set {
        nackOnCodeCacheMiss_ = value;
      }
    }

    /// <summary>Field number for the "environment_variables" field.</summary>
    public const int EnvironmentVariablesFieldNumber = 7;
    private global::Envoy.Extensions.Wasm.V3.EnvironmentVariables environmentVariables_;
    /// <summary>
    /// Specifies environment variables to be injected to this VM which will be available through
    /// WASI's ``environ_get`` and ``environ_get_sizes`` system calls. Note that these functions are mostly implicitly
    /// called in your language's standard library, so you do not need to call them directly and you can access to env
    /// vars just like when you do on native platforms.
    /// Warning: Envoy rejects the configuration if there's conflict of key space.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Wasm.V3.EnvironmentVariables EnvironmentVariables {
      get { return environmentVariables_; }
      set {
        environmentVariables_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VmConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VmConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VmId != other.VmId) return false;
      if (Runtime != other.Runtime) return false;
      if (!object.Equals(Code, other.Code)) return false;
      if (!object.Equals(Configuration, other.Configuration)) return false;
      if (AllowPrecompiled != other.AllowPrecompiled) return false;
      if (NackOnCodeCacheMiss != other.NackOnCodeCacheMiss) return false;
      if (!object.Equals(EnvironmentVariables, other.EnvironmentVariables)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (VmId.Length != 0) hash ^= VmId.GetHashCode();
      if (Runtime.Length != 0) hash ^= Runtime.GetHashCode();
      if (code_ != null) hash ^= Code.GetHashCode();
      if (configuration_ != null) hash ^= Configuration.GetHashCode();
      if (AllowPrecompiled != false) hash ^= AllowPrecompiled.GetHashCode();
      if (NackOnCodeCacheMiss != false) hash ^= NackOnCodeCacheMiss.GetHashCode();
      if (environmentVariables_ != null) hash ^= EnvironmentVariables.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (VmId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(VmId);
      }
      if (Runtime.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Runtime);
      }
      if (code_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Code);
      }
      if (configuration_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Configuration);
      }
      if (AllowPrecompiled != false) {
        output.WriteRawTag(40);
        output.WriteBool(AllowPrecompiled);
      }
      if (NackOnCodeCacheMiss != false) {
        output.WriteRawTag(48);
        output.WriteBool(NackOnCodeCacheMiss);
      }
      if (environmentVariables_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(EnvironmentVariables);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (VmId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(VmId);
      }
      if (Runtime.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Runtime);
      }
      if (code_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Code);
      }
      if (configuration_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Configuration);
      }
      if (AllowPrecompiled != false) {
        output.WriteRawTag(40);
        output.WriteBool(AllowPrecompiled);
      }
      if (NackOnCodeCacheMiss != false) {
        output.WriteRawTag(48);
        output.WriteBool(NackOnCodeCacheMiss);
      }
      if (environmentVariables_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(EnvironmentVariables);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (VmId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VmId);
      }
      if (Runtime.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Runtime);
      }
      if (code_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Code);
      }
      if (configuration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Configuration);
      }
      if (AllowPrecompiled != false) {
        size += 1 + 1;
      }
      if (NackOnCodeCacheMiss != false) {
        size += 1 + 1;
      }
      if (environmentVariables_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EnvironmentVariables);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VmConfig other) {
      if (other == null) {
        return;
      }
      if (other.VmId.Length != 0) {
        VmId = other.VmId;
      }
      if (other.Runtime.Length != 0) {
        Runtime = other.Runtime;
      }
      if (other.code_ != null) {
        if (code_ == null) {
          Code = new global::Envoy.Config.Core.V3.AsyncDataSource();
        }
        Code.MergeFrom(other.Code);
      }
      if (other.configuration_ != null) {
        if (configuration_ == null) {
          Configuration = new global::Google.Protobuf.WellKnownTypes.Any();
        }
        Configuration.MergeFrom(other.Configuration);
      }
      if (other.AllowPrecompiled != false) {
        AllowPrecompiled = other.AllowPrecompiled;
      }
      if (other.NackOnCodeCacheMiss != false) {
        NackOnCodeCacheMiss = other.NackOnCodeCacheMiss;
      }
      if (other.environmentVariables_ != null) {
        if (environmentVariables_ == null) {
          EnvironmentVariables = new global::Envoy.Extensions.Wasm.V3.EnvironmentVariables();
        }
        EnvironmentVariables.MergeFrom(other.EnvironmentVariables);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VmId = input.ReadString();
            break;
          }
          case 18: {
            Runtime = input.ReadString();
            break;
          }
          case 26: {
            if (code_ == null) {
              Code = new global::Envoy.Config.Core.V3.AsyncDataSource();
            }
            input.ReadMessage(Code);
            break;
          }
          case 34: {
            if (configuration_ == null) {
              Configuration = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(Configuration);
            break;
          }
          case 40: {
            AllowPrecompiled = input.ReadBool();
            break;
          }
          case 48: {
            NackOnCodeCacheMiss = input.ReadBool();
            break;
          }
          case 58: {
            if (environmentVariables_ == null) {
              EnvironmentVariables = new global::Envoy.Extensions.Wasm.V3.EnvironmentVariables();
            }
            input.ReadMessage(EnvironmentVariables);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            VmId = input.ReadString();
            break;
          }
          case 18: {
            Runtime = input.ReadString();
            break;
          }
          case 26: {
            if (code_ == null) {
              Code = new global::Envoy.Config.Core.V3.AsyncDataSource();
            }
            input.ReadMessage(Code);
            break;
          }
          case 34: {
            if (configuration_ == null) {
              Configuration = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(Configuration);
            break;
          }
          case 40: {
            AllowPrecompiled = input.ReadBool();
            break;
          }
          case 48: {
            NackOnCodeCacheMiss = input.ReadBool();
            break;
          }
          case 58: {
            if (environmentVariables_ == null) {
              EnvironmentVariables = new global::Envoy.Extensions.Wasm.V3.EnvironmentVariables();
            }
            input.ReadMessage(EnvironmentVariables);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class EnvironmentVariables : pb::IMessage<EnvironmentVariables>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EnvironmentVariables> _parser = new pb::MessageParser<EnvironmentVariables>(() => new EnvironmentVariables());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EnvironmentVariables> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Wasm.V3.WasmReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvironmentVariables() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvironmentVariables(EnvironmentVariables other) : this() {
      hostEnvKeys_ = other.hostEnvKeys_.Clone();
      keyValues_ = other.keyValues_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvironmentVariables Clone() {
      return new EnvironmentVariables(this);
    }

    /// <summary>Field number for the "host_env_keys" field.</summary>
    public const int HostEnvKeysFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_hostEnvKeys_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> hostEnvKeys_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// The keys of *Envoy's* environment variables exposed to this VM. In other words, if a key exists in Envoy's environment
    /// variables, then that key-value pair will be injected. Note that if a key does not exist, it will be ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> HostEnvKeys {
      get { return hostEnvKeys_; }
    }

    /// <summary>Field number for the "key_values" field.</summary>
    public const int KeyValuesFieldNumber = 2;
    private static readonly pbc::MapField<string, string>.Codec _map_keyValues_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 18);
    private readonly pbc::MapField<string, string> keyValues_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Explicitly given key-value pairs to be injected to this VM in the form of "KEY=VALUE".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> KeyValues {
      get { return keyValues_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EnvironmentVariables);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EnvironmentVariables other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!hostEnvKeys_.Equals(other.hostEnvKeys_)) return false;
      if (!KeyValues.Equals(other.KeyValues)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= hostEnvKeys_.GetHashCode();
      hash ^= KeyValues.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      hostEnvKeys_.WriteTo(output, _repeated_hostEnvKeys_codec);
      keyValues_.WriteTo(output, _map_keyValues_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      hostEnvKeys_.WriteTo(ref output, _repeated_hostEnvKeys_codec);
      keyValues_.WriteTo(ref output, _map_keyValues_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += hostEnvKeys_.CalculateSize(_repeated_hostEnvKeys_codec);
      size += keyValues_.CalculateSize(_map_keyValues_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EnvironmentVariables other) {
      if (other == null) {
        return;
      }
      hostEnvKeys_.Add(other.hostEnvKeys_);
      keyValues_.Add(other.keyValues_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            hostEnvKeys_.AddEntriesFrom(input, _repeated_hostEnvKeys_codec);
            break;
          }
          case 18: {
            keyValues_.AddEntriesFrom(input, _map_keyValues_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            hostEnvKeys_.AddEntriesFrom(ref input, _repeated_hostEnvKeys_codec);
            break;
          }
          case 18: {
            keyValues_.AddEntriesFrom(ref input, _map_keyValues_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Base Configuration for Wasm Plugins e.g. filters and services.
  /// [#next-free-field: 7]
  /// </summary>
  public sealed partial class PluginConfig : pb::IMessage<PluginConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PluginConfig> _parser = new pb::MessageParser<PluginConfig>(() => new PluginConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PluginConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Wasm.V3.WasmReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PluginConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PluginConfig(PluginConfig other) : this() {
      name_ = other.name_;
      rootId_ = other.rootId_;
      configuration_ = other.configuration_ != null ? other.configuration_.Clone() : null;
      failOpen_ = other.failOpen_;
      capabilityRestrictionConfig_ = other.capabilityRestrictionConfig_ != null ? other.capabilityRestrictionConfig_.Clone() : null;
      switch (other.VmCase) {
        case VmOneofCase.VmConfig:
          VmConfig = other.VmConfig.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PluginConfig Clone() {
      return new PluginConfig(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// A unique name for a filters/services in a VM for use in identifying the filter/service if
    /// multiple filters/services are handled by the same *vm_id* and *root_id* and for
    /// logging/debugging.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "root_id" field.</summary>
    public const int RootIdFieldNumber = 2;
    private string rootId_ = "";
    /// <summary>
    /// A unique ID for a set of filters/services in a VM which will share a RootContext and Contexts
    /// if applicable (e.g. an Wasm HttpFilter and an Wasm AccessLog). If left blank, all
    /// filters/services with a blank root_id with the same *vm_id* will share Context(s).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RootId {
      get { return rootId_; }
      set {
        rootId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "vm_config" field.</summary>
    public const int VmConfigFieldNumber = 3;
    /// <summary>
    /// TODO: add referential VM configurations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Wasm.V3.VmConfig VmConfig {
      get { return vmCase_ == VmOneofCase.VmConfig ? (global::Envoy.Extensions.Wasm.V3.VmConfig) vm_ : null; }
      set {
        vm_ = value;
        vmCase_ = value == null ? VmOneofCase.None : VmOneofCase.VmConfig;
      }
    }

    /// <summary>Field number for the "configuration" field.</summary>
    public const int ConfigurationFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Any configuration_;
    /// <summary>
    /// Filter/service configuration used to configure or reconfigure a plugin
    /// (proxy_on_configuration).
    /// `google.protobuf.Struct` is serialized as JSON before
    /// passing it to the plugin. `google.protobuf.BytesValue` and
    /// `google.protobuf.StringValue` are passed directly without the wrapper.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Any Configuration {
      get { return configuration_; }
      set {
        configuration_ = value;
      }
    }

    /// <summary>Field number for the "fail_open" field.</summary>
    public const int FailOpenFieldNumber = 5;
    private bool failOpen_;
    /// <summary>
    /// If there is a fatal error on the VM (e.g. exception, abort(), on_start or on_configure return false),
    /// then all plugins associated with the VM will either fail closed (by default), e.g. by returning an HTTP 503 error,
    /// or fail open (if 'fail_open' is set to true) by bypassing the filter. Note: when on_start or on_configure return false
    /// during xDS updates the xDS configuration will be rejected and when on_start or on_configuration return false on initial
    /// startup the proxy will not start.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FailOpen {
      get { return failOpen_; }
      set {
        failOpen_ = value;
      }
    }

    /// <summary>Field number for the "capability_restriction_config" field.</summary>
    public const int CapabilityRestrictionConfigFieldNumber = 6;
    private global::Envoy.Extensions.Wasm.V3.CapabilityRestrictionConfig capabilityRestrictionConfig_;
    /// <summary>
    /// Configuration for restricting Proxy-Wasm capabilities available to modules.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Wasm.V3.CapabilityRestrictionConfig CapabilityRestrictionConfig {
      get { return capabilityRestrictionConfig_; }
      set {
        capabilityRestrictionConfig_ = value;
      }
    }

    private object vm_;
    /// <summary>Enum of possible cases for the "vm" oneof.</summary>
    public enum VmOneofCase {
      None = 0,
      VmConfig = 3,
    }
    private VmOneofCase vmCase_ = VmOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VmOneofCase VmCase {
      get { return vmCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVm() {
      vmCase_ = VmOneofCase.None;
      vm_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PluginConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PluginConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (RootId != other.RootId) return false;
      if (!object.Equals(VmConfig, other.VmConfig)) return false;
      if (!object.Equals(Configuration, other.Configuration)) return false;
      if (FailOpen != other.FailOpen) return false;
      if (!object.Equals(CapabilityRestrictionConfig, other.CapabilityRestrictionConfig)) return false;
      if (VmCase != other.VmCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (RootId.Length != 0) hash ^= RootId.GetHashCode();
      if (vmCase_ == VmOneofCase.VmConfig) hash ^= VmConfig.GetHashCode();
      if (configuration_ != null) hash ^= Configuration.GetHashCode();
      if (FailOpen != false) hash ^= FailOpen.GetHashCode();
      if (capabilityRestrictionConfig_ != null) hash ^= CapabilityRestrictionConfig.GetHashCode();
      hash ^= (int) vmCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (RootId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RootId);
      }
      if (vmCase_ == VmOneofCase.VmConfig) {
        output.WriteRawTag(26);
        output.WriteMessage(VmConfig);
      }
      if (configuration_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Configuration);
      }
      if (FailOpen != false) {
        output.WriteRawTag(40);
        output.WriteBool(FailOpen);
      }
      if (capabilityRestrictionConfig_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(CapabilityRestrictionConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (RootId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RootId);
      }
      if (vmCase_ == VmOneofCase.VmConfig) {
        output.WriteRawTag(26);
        output.WriteMessage(VmConfig);
      }
      if (configuration_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Configuration);
      }
      if (FailOpen != false) {
        output.WriteRawTag(40);
        output.WriteBool(FailOpen);
      }
      if (capabilityRestrictionConfig_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(CapabilityRestrictionConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (RootId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RootId);
      }
      if (vmCase_ == VmOneofCase.VmConfig) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VmConfig);
      }
      if (configuration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Configuration);
      }
      if (FailOpen != false) {
        size += 1 + 1;
      }
      if (capabilityRestrictionConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CapabilityRestrictionConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PluginConfig other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.RootId.Length != 0) {
        RootId = other.RootId;
      }
      if (other.configuration_ != null) {
        if (configuration_ == null) {
          Configuration = new global::Google.Protobuf.WellKnownTypes.Any();
        }
        Configuration.MergeFrom(other.Configuration);
      }
      if (other.FailOpen != false) {
        FailOpen = other.FailOpen;
      }
      if (other.capabilityRestrictionConfig_ != null) {
        if (capabilityRestrictionConfig_ == null) {
          CapabilityRestrictionConfig = new global::Envoy.Extensions.Wasm.V3.CapabilityRestrictionConfig();
        }
        CapabilityRestrictionConfig.MergeFrom(other.CapabilityRestrictionConfig);
      }
      switch (other.VmCase) {
        case VmOneofCase.VmConfig:
          if (VmConfig == null) {
            VmConfig = new global::Envoy.Extensions.Wasm.V3.VmConfig();
          }
          VmConfig.MergeFrom(other.VmConfig);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            RootId = input.ReadString();
            break;
          }
          case 26: {
            global::Envoy.Extensions.Wasm.V3.VmConfig subBuilder = new global::Envoy.Extensions.Wasm.V3.VmConfig();
            if (vmCase_ == VmOneofCase.VmConfig) {
              subBuilder.MergeFrom(VmConfig);
            }
            input.ReadMessage(subBuilder);
            VmConfig = subBuilder;
            break;
          }
          case 34: {
            if (configuration_ == null) {
              Configuration = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(Configuration);
            break;
          }
          case 40: {
            FailOpen = input.ReadBool();
            break;
          }
          case 50: {
            if (capabilityRestrictionConfig_ == null) {
              CapabilityRestrictionConfig = new global::Envoy.Extensions.Wasm.V3.CapabilityRestrictionConfig();
            }
            input.ReadMessage(CapabilityRestrictionConfig);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            RootId = input.ReadString();
            break;
          }
          case 26: {
            global::Envoy.Extensions.Wasm.V3.VmConfig subBuilder = new global::Envoy.Extensions.Wasm.V3.VmConfig();
            if (vmCase_ == VmOneofCase.VmConfig) {
              subBuilder.MergeFrom(VmConfig);
            }
            input.ReadMessage(subBuilder);
            VmConfig = subBuilder;
            break;
          }
          case 34: {
            if (configuration_ == null) {
              Configuration = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(Configuration);
            break;
          }
          case 40: {
            FailOpen = input.ReadBool();
            break;
          }
          case 50: {
            if (capabilityRestrictionConfig_ == null) {
              CapabilityRestrictionConfig = new global::Envoy.Extensions.Wasm.V3.CapabilityRestrictionConfig();
            }
            input.ReadMessage(CapabilityRestrictionConfig);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// WasmService is configured as a built-in *envoy.wasm_service* :ref:`WasmService
  /// &lt;config_wasm_service>` This opaque configuration will be used to create a Wasm Service.
  /// </summary>
  public sealed partial class WasmService : pb::IMessage<WasmService>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<WasmService> _parser = new pb::MessageParser<WasmService>(() => new WasmService());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<WasmService> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Wasm.V3.WasmReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WasmService() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WasmService(WasmService other) : this() {
      config_ = other.config_ != null ? other.config_.Clone() : null;
      singleton_ = other.singleton_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WasmService Clone() {
      return new WasmService(this);
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 1;
    private global::Envoy.Extensions.Wasm.V3.PluginConfig config_;
    /// <summary>
    /// General plugin configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Wasm.V3.PluginConfig Config {
      get { return config_; }
      set {
        config_ = value;
      }
    }

    /// <summary>Field number for the "singleton" field.</summary>
    public const int SingletonFieldNumber = 2;
    private bool singleton_;
    /// <summary>
    /// If true, create a single VM rather than creating one VM per worker. Such a singleton can
    /// not be used with filters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Singleton {
      get { return singleton_; }
      set {
        singleton_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as WasmService);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(WasmService other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Config, other.Config)) return false;
      if (Singleton != other.Singleton) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (config_ != null) hash ^= Config.GetHashCode();
      if (Singleton != false) hash ^= Singleton.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (config_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Config);
      }
      if (Singleton != false) {
        output.WriteRawTag(16);
        output.WriteBool(Singleton);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (config_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Config);
      }
      if (Singleton != false) {
        output.WriteRawTag(16);
        output.WriteBool(Singleton);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (Singleton != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(WasmService other) {
      if (other == null) {
        return;
      }
      if (other.config_ != null) {
        if (config_ == null) {
          Config = new global::Envoy.Extensions.Wasm.V3.PluginConfig();
        }
        Config.MergeFrom(other.Config);
      }
      if (other.Singleton != false) {
        Singleton = other.Singleton;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (config_ == null) {
              Config = new global::Envoy.Extensions.Wasm.V3.PluginConfig();
            }
            input.ReadMessage(Config);
            break;
          }
          case 16: {
            Singleton = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (config_ == null) {
              Config = new global::Envoy.Extensions.Wasm.V3.PluginConfig();
            }
            input.ReadMessage(Config);
            break;
          }
          case 16: {
            Singleton = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
