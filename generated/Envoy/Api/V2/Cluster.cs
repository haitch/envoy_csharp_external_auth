// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/api/v2/cluster.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2 {

  /// <summary>Holder for reflection information generated from envoy/api/v2/cluster.proto</summary>
  public static partial class ClusterReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/api/v2/cluster.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ClusterReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChplbnZveS9hcGkvdjIvY2x1c3Rlci5wcm90bxIMZW52b3kuYXBpLnYyGhtl",
            "bnZveS9hcGkvdjIvYXV0aC90bHMucHJvdG8aKmVudm95L2FwaS92Mi9jbHVz",
            "dGVyL2NpcmN1aXRfYnJlYWtlci5wcm90bxohZW52b3kvYXBpL3YyL2NsdXN0",
            "ZXIvZmlsdGVyLnByb3RvGixlbnZveS9hcGkvdjIvY2x1c3Rlci9vdXRsaWVy",
            "X2RldGVjdGlvbi5wcm90bxofZW52b3kvYXBpL3YyL2NvcmUvYWRkcmVzcy5w",
            "cm90bxocZW52b3kvYXBpL3YyL2NvcmUvYmFzZS5wcm90bxolZW52b3kvYXBp",
            "L3YyL2NvcmUvY29uZmlnX3NvdXJjZS5wcm90bxokZW52b3kvYXBpL3YyL2Nv",
            "cmUvaGVhbHRoX2NoZWNrLnByb3RvGiBlbnZveS9hcGkvdjIvY29yZS9wcm90",
            "b2NvbC5wcm90bxobZW52b3kvYXBpL3YyL2VuZHBvaW50LnByb3RvGhhlbnZv",
            "eS90eXBlL3BlcmNlbnQucHJvdG8aGWdvb2dsZS9wcm90b2J1Zi9hbnkucHJv",
            "dG8aHmdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90bxocZ29vZ2xlL3By",
            "b3RvYnVmL3N0cnVjdC5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJz",
            "LnByb3RvGiNlbnZveS9hbm5vdGF0aW9ucy9kZXByZWNhdGlvbi5wcm90bxoe",
            "dWRwYS9hbm5vdGF0aW9ucy9taWdyYXRlLnByb3RvGh11ZHBhL2Fubm90YXRp",
            "b25zL3N0YXR1cy5wcm90bxoXdmFsaWRhdGUvdmFsaWRhdGUucHJvdG8irS4K",
            "B0NsdXN0ZXISTAoYdHJhbnNwb3J0X3NvY2tldF9tYXRjaGVzGCsgAygLMiou",
            "ZW52b3kuYXBpLnYyLkNsdXN0ZXIuVHJhbnNwb3J0U29ja2V0TWF0Y2gSFQoE",
            "bmFtZRgBIAEoCUIH+kIEcgIgARIVCg1hbHRfc3RhdF9uYW1lGBwgASgJEj0K",
            "BHR5cGUYAiABKA4yIy5lbnZveS5hcGkudjIuQ2x1c3Rlci5EaXNjb3ZlcnlU",
            "eXBlQgj6QgWCAQIQAUgAEj8KDGNsdXN0ZXJfdHlwZRgmIAEoCzInLmVudm95",
            "LmFwaS52Mi5DbHVzdGVyLkN1c3RvbUNsdXN0ZXJUeXBlSAASQgoSZWRzX2Ns",
            "dXN0ZXJfY29uZmlnGAMgASgLMiYuZW52b3kuYXBpLnYyLkNsdXN0ZXIuRWRz",
            "Q2x1c3RlckNvbmZpZxI8Cg9jb25uZWN0X3RpbWVvdXQYBCABKAsyGS5nb29n",
            "bGUucHJvdG9idWYuRHVyYXRpb25CCPpCBaoBAioAEkcKIXBlcl9jb25uZWN0",
            "aW9uX2J1ZmZlcl9saW1pdF9ieXRlcxgFIAEoCzIcLmdvb2dsZS5wcm90b2J1",
            "Zi5VSW50MzJWYWx1ZRI7CglsYl9wb2xpY3kYBiABKA4yHi5lbnZveS5hcGku",
            "djIuQ2x1c3Rlci5MYlBvbGljeUII+kIFggECEAESLQoFaG9zdHMYByADKAsy",
            "Gi5lbnZveS5hcGkudjIuY29yZS5BZGRyZXNzQgIYARI8Cg9sb2FkX2Fzc2ln",
            "bm1lbnQYISABKAsyIy5lbnZveS5hcGkudjIuQ2x1c3RlckxvYWRBc3NpZ25t",
            "ZW50EjUKDWhlYWx0aF9jaGVja3MYCCADKAsyHi5lbnZveS5hcGkudjIuY29y",
            "ZS5IZWFsdGhDaGVjaxJBChttYXhfcmVxdWVzdHNfcGVyX2Nvbm5lY3Rpb24Y",
            "CSABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWUSPwoQY2lyY3Vp",
            "dF9icmVha2VycxgKIAEoCzIlLmVudm95LmFwaS52Mi5jbHVzdGVyLkNpcmN1",
            "aXRCcmVha2VycxJECgt0bHNfY29udGV4dBgLIAEoCzIlLmVudm95LmFwaS52",
            "Mi5hdXRoLlVwc3RyZWFtVGxzQ29udGV4dEIIGAG47vLSBQESVgoedXBzdHJl",
            "YW1faHR0cF9wcm90b2NvbF9vcHRpb25zGC4gASgLMi4uZW52b3kuYXBpLnYy",
            "LmNvcmUuVXBzdHJlYW1IdHRwUHJvdG9jb2xPcHRpb25zEkwKHGNvbW1vbl9o",
            "dHRwX3Byb3RvY29sX29wdGlvbnMYHSABKAsyJi5lbnZveS5hcGkudjIuY29y",
            "ZS5IdHRwUHJvdG9jb2xPcHRpb25zEkYKFWh0dHBfcHJvdG9jb2xfb3B0aW9u",
            "cxgNIAEoCzInLmVudm95LmFwaS52Mi5jb3JlLkh0dHAxUHJvdG9jb2xPcHRp",
            "b25zEkcKFmh0dHAyX3Byb3RvY29sX29wdGlvbnMYDiABKAsyJy5lbnZveS5h",
            "cGkudjIuY29yZS5IdHRwMlByb3RvY29sT3B0aW9ucxJhChpleHRlbnNpb25f",
            "cHJvdG9jb2xfb3B0aW9ucxgjIAMoCzIzLmVudm95LmFwaS52Mi5DbHVzdGVy",
            "LkV4dGVuc2lvblByb3RvY29sT3B0aW9uc0VudHJ5QggYAbju8tIFARJiCiB0",
            "eXBlZF9leHRlbnNpb25fcHJvdG9jb2xfb3B0aW9ucxgkIAMoCzI4LmVudm95",
            "LmFwaS52Mi5DbHVzdGVyLlR5cGVkRXh0ZW5zaW9uUHJvdG9jb2xPcHRpb25z",
            "RW50cnkSQQoQZG5zX3JlZnJlc2hfcmF0ZRgQIAEoCzIZLmdvb2dsZS5wcm90",
            "b2J1Zi5EdXJhdGlvbkIM+kIJqgEGKgQQwIQ9EkMKGGRuc19mYWlsdXJlX3Jl",
            "ZnJlc2hfcmF0ZRgsIAEoCzIhLmVudm95LmFwaS52Mi5DbHVzdGVyLlJlZnJl",
            "c2hSYXRlEhcKD3Jlc3BlY3RfZG5zX3R0bBgnIAEoCBJKChFkbnNfbG9va3Vw",
            "X2ZhbWlseRgRIAEoDjIlLmVudm95LmFwaS52Mi5DbHVzdGVyLkRuc0xvb2t1",
            "cEZhbWlseUII+kIFggECEAESMQoNZG5zX3Jlc29sdmVycxgSIAMoCzIaLmVu",
            "dm95LmFwaS52Mi5jb3JlLkFkZHJlc3MSHwoXdXNlX3RjcF9mb3JfZG5zX2xv",
            "b2t1cHMYLSABKAgSQQoRb3V0bGllcl9kZXRlY3Rpb24YEyABKAsyJi5lbnZv",
            "eS5hcGkudjIuY2x1c3Rlci5PdXRsaWVyRGV0ZWN0aW9uEj0KEGNsZWFudXBf",
            "aW50ZXJ2YWwYFCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CCPpC",
            "BaoBAioAEjsKFHVwc3RyZWFtX2JpbmRfY29uZmlnGBUgASgLMh0uZW52b3ku",
            "YXBpLnYyLmNvcmUuQmluZENvbmZpZxI+ChBsYl9zdWJzZXRfY29uZmlnGBYg",
            "ASgLMiQuZW52b3kuYXBpLnYyLkNsdXN0ZXIuTGJTdWJzZXRDb25maWcSRQoT",
            "cmluZ19oYXNoX2xiX2NvbmZpZxgXIAEoCzImLmVudm95LmFwaS52Mi5DbHVz",
            "dGVyLlJpbmdIYXNoTGJDb25maWdIARJLChZvcmlnaW5hbF9kc3RfbGJfY29u",
            "ZmlnGCIgASgLMikuZW52b3kuYXBpLnYyLkNsdXN0ZXIuT3JpZ2luYWxEc3RM",
            "YkNvbmZpZ0gBEk0KF2xlYXN0X3JlcXVlc3RfbGJfY29uZmlnGCUgASgLMiou",
            "ZW52b3kuYXBpLnYyLkNsdXN0ZXIuTGVhc3RSZXF1ZXN0TGJDb25maWdIARI+",
            "ChBjb21tb25fbGJfY29uZmlnGBsgASgLMiQuZW52b3kuYXBpLnYyLkNsdXN0",
            "ZXIuQ29tbW9uTGJDb25maWcSPAoQdHJhbnNwb3J0X3NvY2tldBgYIAEoCzIi",
            "LmVudm95LmFwaS52Mi5jb3JlLlRyYW5zcG9ydFNvY2tldBItCghtZXRhZGF0",
            "YRgZIAEoCzIbLmVudm95LmFwaS52Mi5jb3JlLk1ldGFkYXRhEkoKEnByb3Rv",
            "Y29sX3NlbGVjdGlvbhgaIAEoDjIuLmVudm95LmFwaS52Mi5DbHVzdGVyLkNs",
            "dXN0ZXJQcm90b2NvbFNlbGVjdGlvbhJMCht1cHN0cmVhbV9jb25uZWN0aW9u",
            "X29wdGlvbnMYHiABKAsyJy5lbnZveS5hcGkudjIuVXBzdHJlYW1Db25uZWN0",
            "aW9uT3B0aW9ucxIwCihjbG9zZV9jb25uZWN0aW9uc19vbl9ob3N0X2hlYWx0",
            "aF9mYWlsdXJlGB8gASgIElAKIWRyYWluX2Nvbm5lY3Rpb25zX29uX2hvc3Rf",
            "cmVtb3ZhbBggIAEoCEIl8pj+jwUfCh1pZ25vcmVfaGVhbHRoX29uX2hvc3Rf",
            "cmVtb3ZhbBItCgdmaWx0ZXJzGCggAygLMhwuZW52b3kuYXBpLnYyLmNsdXN0",
            "ZXIuRmlsdGVyEkAKFWxvYWRfYmFsYW5jaW5nX3BvbGljeRgpIAEoCzIhLmVu",
            "dm95LmFwaS52Mi5Mb2FkQmFsYW5jaW5nUG9saWN5EjMKCmxyc19zZXJ2ZXIY",
            "KiABKAsyHy5lbnZveS5hcGkudjIuY29yZS5Db25maWdTb3VyY2USHQoVdHJh",
            "Y2tfdGltZW91dF9idWRnZXRzGC8gASgIGpMBChRUcmFuc3BvcnRTb2NrZXRN",
            "YXRjaBIVCgRuYW1lGAEgASgJQgf6QgRyAhABEiYKBW1hdGNoGAIgASgLMhcu",
            "Z29vZ2xlLnByb3RvYnVmLlN0cnVjdBI8ChB0cmFuc3BvcnRfc29ja2V0GAMg",
            "ASgLMiIuZW52b3kuYXBpLnYyLmNvcmUuVHJhbnNwb3J0U29ja2V0GlYKEUN1",
            "c3RvbUNsdXN0ZXJUeXBlEhUKBG5hbWUYASABKAlCB/pCBHICIAESKgoMdHlw",
            "ZWRfY29uZmlnGAIgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueRpdChBFZHND",
            "bHVzdGVyQ29uZmlnEjMKCmVkc19jb25maWcYASABKAsyHy5lbnZveS5hcGku",
            "djIuY29yZS5Db25maWdTb3VyY2USFAoMc2VydmljZV9uYW1lGAIgASgJGuMF",
            "Cg5MYlN1YnNldENvbmZpZxJeCg9mYWxsYmFja19wb2xpY3kYASABKA4yOy5l",
            "bnZveS5hcGkudjIuQ2x1c3Rlci5MYlN1YnNldENvbmZpZy5MYlN1YnNldEZh",
            "bGxiYWNrUG9saWN5Qgj6QgWCAQIQARIvCg5kZWZhdWx0X3N1YnNldBgCIAEo",
            "CzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QSTwoQc3Vic2V0X3NlbGVjdG9y",
            "cxgDIAMoCzI1LmVudm95LmFwaS52Mi5DbHVzdGVyLkxiU3Vic2V0Q29uZmln",
            "LkxiU3Vic2V0U2VsZWN0b3ISHQoVbG9jYWxpdHlfd2VpZ2h0X2F3YXJlGAQg",
            "ASgIEh0KFXNjYWxlX2xvY2FsaXR5X3dlaWdodBgFIAEoCBIWCg5wYW5pY19t",
            "b2RlX2FueRgGIAEoCBITCgtsaXN0X2FzX2FueRgHIAEoCBqyAgoQTGJTdWJz",
            "ZXRTZWxlY3RvchIMCgRrZXlzGAEgAygJEncKD2ZhbGxiYWNrX3BvbGljeRgC",
            "IAEoDjJULmVudm95LmFwaS52Mi5DbHVzdGVyLkxiU3Vic2V0Q29uZmlnLkxi",
            "U3Vic2V0U2VsZWN0b3IuTGJTdWJzZXRTZWxlY3RvckZhbGxiYWNrUG9saWN5",
            "Qgj6QgWCAQIQARIcChRmYWxsYmFja19rZXlzX3N1YnNldBgDIAMoCSJ5Ch5M",
            "YlN1YnNldFNlbGVjdG9yRmFsbGJhY2tQb2xpY3kSDwoLTk9UX0RFRklORUQQ",
            "ABIPCgtOT19GQUxMQkFDSxABEhAKDEFOWV9FTkRQT0lOVBACEhIKDkRFRkFV",
            "TFRfU1VCU0VUEAMSDwoLS0VZU19TVUJTRVQQBCJPChZMYlN1YnNldEZhbGxi",
            "YWNrUG9saWN5Eg8KC05PX0ZBTExCQUNLEAASEAoMQU5ZX0VORFBPSU5UEAES",
            "EgoOREVGQVVMVF9TVUJTRVQQAhpTChRMZWFzdFJlcXVlc3RMYkNvbmZpZxI7",
            "CgxjaG9pY2VfY291bnQYASABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMy",
            "VmFsdWVCB/pCBCoCKAIaqAIKEFJpbmdIYXNoTGJDb25maWcSQwoRbWluaW11",
            "bV9yaW5nX3NpemUYASABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDY0VmFs",
            "dWVCCvpCBzIFGICAgAQSVAoNaGFzaF9mdW5jdGlvbhgDIAEoDjIzLmVudm95",
            "LmFwaS52Mi5DbHVzdGVyLlJpbmdIYXNoTGJDb25maWcuSGFzaEZ1bmN0aW9u",
            "Qgj6QgWCAQIQARJDChFtYXhpbXVtX3Jpbmdfc2l6ZRgEIAEoCzIcLmdvb2ds",
            "ZS5wcm90b2J1Zi5VSW50NjRWYWx1ZUIK+kIHMgUYgICABCIuCgxIYXNoRnVu",
            "Y3Rpb24SCwoHWFhfSEFTSBAAEhEKDU1VUk1VUl9IQVNIXzIQAUoECAIQAxou",
            "ChNPcmlnaW5hbERzdExiQ29uZmlnEhcKD3VzZV9odHRwX2hlYWRlchgBIAEo",
            "CBqMBgoOQ29tbW9uTGJDb25maWcSNAoXaGVhbHRoeV9wYW5pY190aHJlc2hv",
            "bGQYASABKAsyEy5lbnZveS50eXBlLlBlcmNlbnQSVgoUem9uZV9hd2FyZV9s",
            "Yl9jb25maWcYAiABKAsyNi5lbnZveS5hcGkudjIuQ2x1c3Rlci5Db21tb25M",
            "YkNvbmZpZy5ab25lQXdhcmVMYkNvbmZpZ0gAEmQKG2xvY2FsaXR5X3dlaWdo",
            "dGVkX2xiX2NvbmZpZxgDIAEoCzI9LmVudm95LmFwaS52Mi5DbHVzdGVyLkNv",
            "bW1vbkxiQ29uZmlnLkxvY2FsaXR5V2VpZ2h0ZWRMYkNvbmZpZ0gAEjYKE3Vw",
            "ZGF0ZV9tZXJnZV93aW5kb3cYBCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVy",
            "YXRpb24SJwofaWdub3JlX25ld19ob3N0c191bnRpbF9maXJzdF9oYxgFIAEo",
            "CBIsCiRjbG9zZV9jb25uZWN0aW9uc19vbl9ob3N0X3NldF9jaGFuZ2UYBiAB",
            "KAgSZAocY29uc2lzdGVudF9oYXNoaW5nX2xiX2NvbmZpZxgHIAEoCzI+LmVu",
            "dm95LmFwaS52Mi5DbHVzdGVyLkNvbW1vbkxiQ29uZmlnLkNvbnNpc3RlbnRI",
            "YXNoaW5nTGJDb25maWcamAEKEVpvbmVBd2FyZUxiQ29uZmlnEiwKD3JvdXRp",
            "bmdfZW5hYmxlZBgBIAEoCzITLmVudm95LnR5cGUuUGVyY2VudBI2ChBtaW5f",
            "Y2x1c3Rlcl9zaXplGAIgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQ2NFZh",
            "bHVlEh0KFWZhaWxfdHJhZmZpY19vbl9wYW5pYxgDIAEoCBoaChhMb2NhbGl0",
            "eVdlaWdodGVkTGJDb25maWcaPQoZQ29uc2lzdGVudEhhc2hpbmdMYkNvbmZp",
            "ZxIgChh1c2VfaG9zdG5hbWVfZm9yX2hhc2hpbmcYASABKAhCGwoZbG9jYWxp",
            "dHlfY29uZmlnX3NwZWNpZmllchqOAQoLUmVmcmVzaFJhdGUSQAoNYmFzZV9p",
            "bnRlcnZhbBgBIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkIO+kIL",
            "qgEICAEqBBDAhD0SPQoMbWF4X2ludGVydmFsGAIgASgLMhkuZ29vZ2xlLnBy",
            "b3RvYnVmLkR1cmF0aW9uQgz6QgmqAQYqBBDAhD0aWAodRXh0ZW5zaW9uUHJv",
            "dG9jb2xPcHRpb25zRW50cnkSCwoDa2V5GAEgASgJEiYKBXZhbHVlGAIgASgL",
            "MhcuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdDoCOAEaWgoiVHlwZWRFeHRlbnNp",
            "b25Qcm90b2NvbE9wdGlvbnNFbnRyeRILCgNrZXkYASABKAkSIwoFdmFsdWUY",
            "AiABKAsyFC5nb29nbGUucHJvdG9idWYuQW55OgI4ASJXCg1EaXNjb3ZlcnlU",
            "eXBlEgoKBlNUQVRJQxAAEg4KClNUUklDVF9ETlMQARIPCgtMT0dJQ0FMX0RO",
            "UxACEgcKA0VEUxADEhAKDE9SSUdJTkFMX0RTVBAEIqwBCghMYlBvbGljeRIP",
            "CgtST1VORF9ST0JJThAAEhEKDUxFQVNUX1JFUVVFU1QQARINCglSSU5HX0hB",
            "U0gQAhIKCgZSQU5ET00QAxIdCg9PUklHSU5BTF9EU1RfTEIQBBoICAGo97SL",
            "AgESCgoGTUFHTEVWEAUSFAoQQ0xVU1RFUl9QUk9WSURFRBAGEiAKHExPQURf",
            "QkFMQU5DSU5HX1BPTElDWV9DT05GSUcQByI1Cg9EbnNMb29rdXBGYW1pbHkS",
            "CAoEQVVUTxAAEgsKB1Y0X09OTFkQARILCgdWNl9PTkxZEAIiVAoYQ2x1c3Rl",
            "clByb3RvY29sU2VsZWN0aW9uEhsKF1VTRV9DT05GSUdVUkVEX1BST1RPQ09M",
            "EAASGwoXVVNFX0RPV05TVFJFQU1fUFJPVE9DT0wQAUIYChZjbHVzdGVyX2Rp",
            "c2NvdmVyeV90eXBlQgsKCWxiX2NvbmZpZ0oECAwQDUoECA8QECLCAQoTTG9h",
            "ZEJhbGFuY2luZ1BvbGljeRI6Cghwb2xpY2llcxgBIAMoCzIoLmVudm95LmFw",
            "aS52Mi5Mb2FkQmFsYW5jaW5nUG9saWN5LlBvbGljeRpvCgZQb2xpY3kSDAoE",
            "bmFtZRgBIAEoCRIrCgZjb25maWcYAiABKAsyFy5nb29nbGUucHJvdG9idWYu",
            "U3RydWN0QgIYARIqCgx0eXBlZF9jb25maWcYAyABKAsyFC5nb29nbGUucHJv",
            "dG9idWYuQW55IkgKElVwc3RyZWFtQmluZENvbmZpZxIyCg5zb3VyY2VfYWRk",
            "cmVzcxgBIAEoCzIaLmVudm95LmFwaS52Mi5jb3JlLkFkZHJlc3MiUwoZVXBz",
            "dHJlYW1Db25uZWN0aW9uT3B0aW9ucxI2Cg10Y3Bfa2VlcGFsaXZlGAEgASgL",
            "Mh8uZW52b3kuYXBpLnYyLmNvcmUuVGNwS2VlcGFsaXZlQlMKGmlvLmVudm95",
            "cHJveHkuZW52b3kuYXBpLnYyQgxDbHVzdGVyUHJvdG9QAfKY/o8FGRIXZW52",
            "b3kuY29uZmlnLmNsdXN0ZXIudjO6gMjRBgIQAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Auth.TlsReflection.Descriptor, global::Envoy.Api.V2.ClusterNS.CircuitBreakerReflection.Descriptor, global::Envoy.Api.V2.ClusterNS.FilterReflection.Descriptor, global::Envoy.Api.V2.ClusterNS.OutlierDetectionReflection.Descriptor, global::Envoy.Api.V2.Core.AddressReflection.Descriptor, global::Envoy.Api.V2.Core.BaseReflection.Descriptor, global::Envoy.Api.V2.Core.ConfigSourceReflection.Descriptor, global::Envoy.Api.V2.Core.HealthCheckReflection.Descriptor, global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor, global::Envoy.Api.V2.EndpointReflection.Descriptor, global::Envoy.Type.PercentReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.StructReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Envoy.Annotations.DeprecationReflection.Descriptor, global::Udpa.Annotations.MigrateReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster), global::Envoy.Api.V2.Cluster.Parser, new[]{ "TransportSocketMatches", "Name", "AltStatName", "Type", "ClusterType", "EdsClusterConfig", "ConnectTimeout", "PerConnectionBufferLimitBytes", "LbPolicy", "Hosts", "LoadAssignment", "HealthChecks", "MaxRequestsPerConnection", "CircuitBreakers", "TlsContext", "UpstreamHttpProtocolOptions", "CommonHttpProtocolOptions", "HttpProtocolOptions", "Http2ProtocolOptions", "ExtensionProtocolOptions", "TypedExtensionProtocolOptions", "DnsRefreshRate", "DnsFailureRefreshRate", "RespectDnsTtl", "DnsLookupFamily", "DnsResolvers", "UseTcpForDnsLookups", "OutlierDetection", "CleanupInterval", "UpstreamBindConfig", "LbSubsetConfig", "RingHashLbConfig", "OriginalDstLbConfig", "LeastRequestLbConfig", "CommonLbConfig", "TransportSocket", "Metadata", "ProtocolSelection", "UpstreamConnectionOptions", "CloseConnectionsOnHostHealthFailure", "DrainConnectionsOnHostRemoval", "Filters", "LoadBalancingPolicy", "LrsServer", "TrackTimeoutBudgets" }, new[]{ "ClusterDiscoveryType", "LbConfig" }, new[]{ typeof(global::Envoy.Api.V2.Cluster.Types.DiscoveryType), typeof(global::Envoy.Api.V2.Cluster.Types.LbPolicy), typeof(global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily), typeof(global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.TransportSocketMatch), global::Envoy.Api.V2.Cluster.Types.TransportSocketMatch.Parser, new[]{ "Name", "Match", "TransportSocket" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.CustomClusterType), global::Envoy.Api.V2.Cluster.Types.CustomClusterType.Parser, new[]{ "Name", "TypedConfig" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig), global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig.Parser, new[]{ "EdsConfig", "ServiceName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig), global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Parser, new[]{ "FallbackPolicy", "DefaultSubset", "SubsetSelectors", "LocalityWeightAware", "ScaleLocalityWeight", "PanicModeAny", "ListAsAny" }, null, new[]{ typeof(global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector), global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Parser, new[]{ "Keys", "FallbackPolicy", "FallbackKeysSubset" }, null, new[]{ typeof(global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy) }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig), global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig.Parser, new[]{ "ChoiceCount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig), global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Parser, new[]{ "MinimumRingSize", "HashFunction", "MaximumRingSize" }, null, new[]{ typeof(global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig), global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig.Parser, new[]{ "UseHttpHeader" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.CommonLbConfig), global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Parser, new[]{ "HealthyPanicThreshold", "ZoneAwareLbConfig", "LocalityWeightedLbConfig", "UpdateMergeWindow", "IgnoreNewHostsUntilFirstHc", "CloseConnectionsOnHostSetChange", "ConsistentHashingLbConfig" }, new[]{ "LocalityConfigSpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig), global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig.Parser, new[]{ "RoutingEnabled", "MinClusterSize", "FailTrafficOnPanic" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig), global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ConsistentHashingLbConfig), global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ConsistentHashingLbConfig.Parser, new[]{ "UseHostnameForHashing" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.RefreshRate), global::Envoy.Api.V2.Cluster.Types.RefreshRate.Parser, new[]{ "BaseInterval", "MaxInterval" }, null, null, null, null),
            null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.LoadBalancingPolicy), global::Envoy.Api.V2.LoadBalancingPolicy.Parser, new[]{ "Policies" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.LoadBalancingPolicy.Types.Policy), global::Envoy.Api.V2.LoadBalancingPolicy.Types.Policy.Parser, new[]{ "Name", "Config", "TypedConfig" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.UpstreamBindConfig), global::Envoy.Api.V2.UpstreamBindConfig.Parser, new[]{ "SourceAddress" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.UpstreamConnectionOptions), global::Envoy.Api.V2.UpstreamConnectionOptions.Parser, new[]{ "TcpKeepalive" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration for a single upstream cluster.
  /// [#next-free-field: 48]
  /// </summary>
  public sealed partial class Cluster : pb::IMessage<Cluster>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Cluster> _parser = new pb::MessageParser<Cluster>(() => new Cluster());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Cluster> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.ClusterReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Cluster() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Cluster(Cluster other) : this() {
      transportSocketMatches_ = other.transportSocketMatches_.Clone();
      name_ = other.name_;
      altStatName_ = other.altStatName_;
      edsClusterConfig_ = other.edsClusterConfig_ != null ? other.edsClusterConfig_.Clone() : null;
      connectTimeout_ = other.connectTimeout_ != null ? other.connectTimeout_.Clone() : null;
      PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
      lbPolicy_ = other.lbPolicy_;
      hosts_ = other.hosts_.Clone();
      loadAssignment_ = other.loadAssignment_ != null ? other.loadAssignment_.Clone() : null;
      healthChecks_ = other.healthChecks_.Clone();
      MaxRequestsPerConnection = other.MaxRequestsPerConnection;
      circuitBreakers_ = other.circuitBreakers_ != null ? other.circuitBreakers_.Clone() : null;
      tlsContext_ = other.tlsContext_ != null ? other.tlsContext_.Clone() : null;
      upstreamHttpProtocolOptions_ = other.upstreamHttpProtocolOptions_ != null ? other.upstreamHttpProtocolOptions_.Clone() : null;
      commonHttpProtocolOptions_ = other.commonHttpProtocolOptions_ != null ? other.commonHttpProtocolOptions_.Clone() : null;
      httpProtocolOptions_ = other.httpProtocolOptions_ != null ? other.httpProtocolOptions_.Clone() : null;
      http2ProtocolOptions_ = other.http2ProtocolOptions_ != null ? other.http2ProtocolOptions_.Clone() : null;
      extensionProtocolOptions_ = other.extensionProtocolOptions_.Clone();
      typedExtensionProtocolOptions_ = other.typedExtensionProtocolOptions_.Clone();
      dnsRefreshRate_ = other.dnsRefreshRate_ != null ? other.dnsRefreshRate_.Clone() : null;
      dnsFailureRefreshRate_ = other.dnsFailureRefreshRate_ != null ? other.dnsFailureRefreshRate_.Clone() : null;
      respectDnsTtl_ = other.respectDnsTtl_;
      dnsLookupFamily_ = other.dnsLookupFamily_;
      dnsResolvers_ = other.dnsResolvers_.Clone();
      useTcpForDnsLookups_ = other.useTcpForDnsLookups_;
      outlierDetection_ = other.outlierDetection_ != null ? other.outlierDetection_.Clone() : null;
      cleanupInterval_ = other.cleanupInterval_ != null ? other.cleanupInterval_.Clone() : null;
      upstreamBindConfig_ = other.upstreamBindConfig_ != null ? other.upstreamBindConfig_.Clone() : null;
      lbSubsetConfig_ = other.lbSubsetConfig_ != null ? other.lbSubsetConfig_.Clone() : null;
      commonLbConfig_ = other.commonLbConfig_ != null ? other.commonLbConfig_.Clone() : null;
      transportSocket_ = other.transportSocket_ != null ? other.transportSocket_.Clone() : null;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      protocolSelection_ = other.protocolSelection_;
      upstreamConnectionOptions_ = other.upstreamConnectionOptions_ != null ? other.upstreamConnectionOptions_.Clone() : null;
      closeConnectionsOnHostHealthFailure_ = other.closeConnectionsOnHostHealthFailure_;
      drainConnectionsOnHostRemoval_ = other.drainConnectionsOnHostRemoval_;
      filters_ = other.filters_.Clone();
      loadBalancingPolicy_ = other.loadBalancingPolicy_ != null ? other.loadBalancingPolicy_.Clone() : null;
      lrsServer_ = other.lrsServer_ != null ? other.lrsServer_.Clone() : null;
      trackTimeoutBudgets_ = other.trackTimeoutBudgets_;
      switch (other.ClusterDiscoveryTypeCase) {
        case ClusterDiscoveryTypeOneofCase.Type:
          Type = other.Type;
          break;
        case ClusterDiscoveryTypeOneofCase.ClusterType:
          ClusterType = other.ClusterType.Clone();
          break;
      }

      switch (other.LbConfigCase) {
        case LbConfigOneofCase.RingHashLbConfig:
          RingHashLbConfig = other.RingHashLbConfig.Clone();
          break;
        case LbConfigOneofCase.OriginalDstLbConfig:
          OriginalDstLbConfig = other.OriginalDstLbConfig.Clone();
          break;
        case LbConfigOneofCase.LeastRequestLbConfig:
          LeastRequestLbConfig = other.LeastRequestLbConfig.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Cluster Clone() {
      return new Cluster(this);
    }

    /// <summary>Field number for the "transport_socket_matches" field.</summary>
    public const int TransportSocketMatchesFieldNumber = 43;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Cluster.Types.TransportSocketMatch> _repeated_transportSocketMatches_codec
        = pb::FieldCodec.ForMessage(346, global::Envoy.Api.V2.Cluster.Types.TransportSocketMatch.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.TransportSocketMatch> transportSocketMatches_ = new pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.TransportSocketMatch>();
    /// <summary>
    /// Configuration to use different transport sockets for different endpoints.
    /// The entry of *envoy.transport_socket_match* in the
    /// :ref:`LbEndpoint.Metadata &lt;envoy_api_field_endpoint.LbEndpoint.metadata>`
    /// is used to match against the transport sockets as they appear in the list. The first
    /// :ref:`match &lt;envoy_api_msg_Cluster.TransportSocketMatch>` is used.
    /// For example, with the following match
    ///
    /// .. code-block:: yaml
    ///
    ///  transport_socket_matches:
    ///  - name: "enableMTLS"
    ///    match:
    ///      acceptMTLS: true
    ///    transport_socket:
    ///      name: envoy.transport_sockets.tls
    ///      config: { ... } # tls socket configuration
    ///  - name: "defaultToPlaintext"
    ///    match: {}
    ///    transport_socket:
    ///      name: envoy.transport_sockets.raw_buffer
    ///
    /// Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
    /// having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
    ///
    /// If a :ref:`socket match &lt;envoy_api_msg_Cluster.TransportSocketMatch>` with empty match
    /// criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
    /// socket match in case above.
    ///
    /// If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
    /// *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
    /// *transport_socket* specified in this cluster.
    ///
    /// This field allows gradual and flexible transport socket configuration changes.
    ///
    /// The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
    /// an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
    /// "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
    /// has "acceptPlaintext": "true" metadata information.
    ///
    /// Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
    /// traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
    /// *TransportSocketMatch* in this field. Other client Envoys receive CDS without
    /// *transport_socket_match* set, and still send plain text traffic to the same cluster.
    ///
    /// [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.TransportSocketMatch> TransportSocketMatches {
      get { return transportSocketMatches_; }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Supplies the name of the cluster which must be unique across all clusters.
    /// The cluster name is used when emitting
    /// :ref:`statistics &lt;config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
    /// &lt;envoy_api_field_Cluster.alt_stat_name>` is not provided.
    /// Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "alt_stat_name" field.</summary>
    public const int AltStatNameFieldNumber = 28;
    private string altStatName_ = "";
    /// <summary>
    /// An optional alternative to the cluster name to be used while emitting stats.
    /// Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
    /// confused with :ref:`Router Filter Header
    /// &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AltStatName {
      get { return altStatName_; }
      set {
        altStatName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    /// <summary>
    /// The :ref:`service discovery type &lt;arch_overview_service_discovery_types>`
    /// to use for resolving the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Cluster.Types.DiscoveryType Type {
      get { return clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.Type ? (global::Envoy.Api.V2.Cluster.Types.DiscoveryType) clusterDiscoveryType_ : global::Envoy.Api.V2.Cluster.Types.DiscoveryType.Static; }
      set {
        clusterDiscoveryType_ = value;
        clusterDiscoveryTypeCase_ = ClusterDiscoveryTypeOneofCase.Type;
      }
    }

    /// <summary>Field number for the "cluster_type" field.</summary>
    public const int ClusterTypeFieldNumber = 38;
    /// <summary>
    /// The custom cluster type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Cluster.Types.CustomClusterType ClusterType {
      get { return clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType ? (global::Envoy.Api.V2.Cluster.Types.CustomClusterType) clusterDiscoveryType_ : null; }
      set {
        clusterDiscoveryType_ = value;
        clusterDiscoveryTypeCase_ = value == null ? ClusterDiscoveryTypeOneofCase.None : ClusterDiscoveryTypeOneofCase.ClusterType;
      }
    }

    /// <summary>Field number for the "eds_cluster_config" field.</summary>
    public const int EdsClusterConfigFieldNumber = 3;
    private global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig edsClusterConfig_;
    /// <summary>
    /// Configuration to use for EDS updates for the Cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig EdsClusterConfig {
      get { return edsClusterConfig_; }
      set {
        edsClusterConfig_ = value;
      }
    }

    /// <summary>Field number for the "connect_timeout" field.</summary>
    public const int ConnectTimeoutFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration connectTimeout_;
    /// <summary>
    /// The timeout for new network connections to hosts in the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration ConnectTimeout {
      get { return connectTimeout_; }
      set {
        connectTimeout_ = value;
      }
    }

    /// <summary>Field number for the "per_connection_buffer_limit_bytes" field.</summary>
    public const int PerConnectionBufferLimitBytesFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_perConnectionBufferLimitBytes_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? perConnectionBufferLimitBytes_;
    /// <summary>
    /// Soft limit on size of the cluster’s connections read and write buffers. If
    /// unspecified, an implementation defined default is applied (1MiB).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? PerConnectionBufferLimitBytes {
      get { return perConnectionBufferLimitBytes_; }
      set {
        perConnectionBufferLimitBytes_ = value;
      }
    }


    /// <summary>Field number for the "lb_policy" field.</summary>
    public const int LbPolicyFieldNumber = 6;
    private global::Envoy.Api.V2.Cluster.Types.LbPolicy lbPolicy_ = global::Envoy.Api.V2.Cluster.Types.LbPolicy.RoundRobin;
    /// <summary>
    /// The :ref:`load balancer type &lt;arch_overview_load_balancing_types>` to use
    /// when picking a host in the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Cluster.Types.LbPolicy LbPolicy {
      get { return lbPolicy_; }
      set {
        lbPolicy_ = value;
      }
    }

    /// <summary>Field number for the "hosts" field.</summary>
    public const int HostsFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.Address> _repeated_hosts_codec
        = pb::FieldCodec.ForMessage(58, global::Envoy.Api.V2.Core.Address.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> hosts_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.Address>();
    /// <summary>
    /// If the service discovery type is
    /// :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC>`,
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// then hosts is required.
    ///
    /// .. attention::
    ///
    ///   **This field is deprecated**. Set the
    ///   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment>` field instead.
    ///
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> Hosts {
      get { return hosts_; }
    }

    /// <summary>Field number for the "load_assignment" field.</summary>
    public const int LoadAssignmentFieldNumber = 33;
    private global::Envoy.Api.V2.ClusterLoadAssignment loadAssignment_;
    /// <summary>
    /// Setting this is required for specifying members of
    /// :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC>`,
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>` clusters.
    /// This field supersedes the *hosts* field in the v2 API.
    ///
    /// .. attention::
    ///
    ///   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
    ///   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment>`.
    ///
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.ClusterLoadAssignment LoadAssignment {
      get { return loadAssignment_; }
      set {
        loadAssignment_ = value;
      }
    }

    /// <summary>Field number for the "health_checks" field.</summary>
    public const int HealthChecksFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HealthCheck> _repeated_healthChecks_codec
        = pb::FieldCodec.ForMessage(66, global::Envoy.Api.V2.Core.HealthCheck.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HealthCheck> healthChecks_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HealthCheck>();
    /// <summary>
    /// Optional :ref:`active health checking &lt;arch_overview_health_checking>`
    /// configuration for the cluster. If no
    /// configuration is specified no health checking will be done and all cluster
    /// members will be considered healthy at all times.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.HealthCheck> HealthChecks {
      get { return healthChecks_; }
    }

    /// <summary>Field number for the "max_requests_per_connection" field.</summary>
    public const int MaxRequestsPerConnectionFieldNumber = 9;
    private static readonly pb::FieldCodec<uint?> _single_maxRequestsPerConnection_codec = pb::FieldCodec.ForStructWrapper<uint>(74);
    private uint? maxRequestsPerConnection_;
    /// <summary>
    /// Optional maximum requests for a single upstream connection. This parameter
    /// is respected by both the HTTP/1.1 and HTTP/2 connection pool
    /// implementations. If not specified, there is no limit. Setting this
    /// parameter to 1 will effectively disable keep alive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxRequestsPerConnection {
      get { return maxRequestsPerConnection_; }
      set {
        maxRequestsPerConnection_ = value;
      }
    }


    /// <summary>Field number for the "circuit_breakers" field.</summary>
    public const int CircuitBreakersFieldNumber = 10;
    private global::Envoy.Api.V2.ClusterNS.CircuitBreakers circuitBreakers_;
    /// <summary>
    /// Optional :ref:`circuit breaking &lt;arch_overview_circuit_break>` for the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.ClusterNS.CircuitBreakers CircuitBreakers {
      get { return circuitBreakers_; }
      set {
        circuitBreakers_ = value;
      }
    }

    /// <summary>Field number for the "tls_context" field.</summary>
    public const int TlsContextFieldNumber = 11;
    private global::Envoy.Api.V2.Auth.UpstreamTlsContext tlsContext_;
    /// <summary>
    /// The TLS configuration for connections to the upstream cluster.
    ///
    /// .. attention::
    ///
    ///   **This field is deprecated**. Use `transport_socket` with name `tls` instead. If both are
    ///   set, `transport_socket` takes priority.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Auth.UpstreamTlsContext TlsContext {
      get { return tlsContext_; }
      set {
        tlsContext_ = value;
      }
    }

    /// <summary>Field number for the "upstream_http_protocol_options" field.</summary>
    public const int UpstreamHttpProtocolOptionsFieldNumber = 46;
    private global::Envoy.Api.V2.Core.UpstreamHttpProtocolOptions upstreamHttpProtocolOptions_;
    /// <summary>
    /// HTTP protocol options that are applied only to upstream HTTP connections.
    /// These options apply to all HTTP versions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.UpstreamHttpProtocolOptions UpstreamHttpProtocolOptions {
      get { return upstreamHttpProtocolOptions_; }
      set {
        upstreamHttpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "common_http_protocol_options" field.</summary>
    public const int CommonHttpProtocolOptionsFieldNumber = 29;
    private global::Envoy.Api.V2.Core.HttpProtocolOptions commonHttpProtocolOptions_;
    /// <summary>
    /// Additional options when handling HTTP requests upstream. These options will be applicable to
    /// both HTTP1 and HTTP2 requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.HttpProtocolOptions CommonHttpProtocolOptions {
      get { return commonHttpProtocolOptions_; }
      set {
        commonHttpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "http_protocol_options" field.</summary>
    public const int HttpProtocolOptionsFieldNumber = 13;
    private global::Envoy.Api.V2.Core.Http1ProtocolOptions httpProtocolOptions_;
    /// <summary>
    /// Additional options when handling HTTP1 requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.Http1ProtocolOptions HttpProtocolOptions {
      get { return httpProtocolOptions_; }
      set {
        httpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "http2_protocol_options" field.</summary>
    public const int Http2ProtocolOptionsFieldNumber = 14;
    private global::Envoy.Api.V2.Core.Http2ProtocolOptions http2ProtocolOptions_;
    /// <summary>
    /// Even if default HTTP2 protocol options are desired, this field must be
    /// set so that Envoy will assume that the upstream supports HTTP/2 when
    /// making new HTTP connection pool connections. Currently, Envoy only
    /// supports prior knowledge for upstream connections. Even if TLS is used
    /// with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
    /// connections to happen over plain text.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.Http2ProtocolOptions Http2ProtocolOptions {
      get { return http2ProtocolOptions_; }
      set {
        http2ProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "extension_protocol_options" field.</summary>
    public const int ExtensionProtocolOptionsFieldNumber = 35;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec _map_extensionProtocolOptions_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Struct.Parser), 282);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> extensionProtocolOptions_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>();
    /// <summary>
    /// The extension_protocol_options field is used to provide extension-specific protocol options
    /// for upstream connections. The key should match the extension filter name, such as
    /// "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
    /// specific options.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> ExtensionProtocolOptions {
      get { return extensionProtocolOptions_; }
    }

    /// <summary>Field number for the "typed_extension_protocol_options" field.</summary>
    public const int TypedExtensionProtocolOptionsFieldNumber = 36;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec _map_typedExtensionProtocolOptions_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Any.Parser), 290);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> typedExtensionProtocolOptions_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>();
    /// <summary>
    /// The extension_protocol_options field is used to provide extension-specific protocol options
    /// for upstream connections. The key should match the extension filter name, such as
    /// "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
    /// specific options.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> TypedExtensionProtocolOptions {
      get { return typedExtensionProtocolOptions_; }
    }

    /// <summary>Field number for the "dns_refresh_rate" field.</summary>
    public const int DnsRefreshRateFieldNumber = 16;
    private global::Google.Protobuf.WellKnownTypes.Duration dnsRefreshRate_;
    /// <summary>
    /// If the DNS refresh rate is specified and the cluster type is either
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// this value is used as the cluster’s DNS refresh
    /// rate. The value configured must be at least 1ms. If this setting is not specified, the
    /// value defaults to 5000ms. For cluster types other than
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`
    /// this setting is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration DnsRefreshRate {
      get { return dnsRefreshRate_; }
      set {
        dnsRefreshRate_ = value;
      }
    }

    /// <summary>Field number for the "dns_failure_refresh_rate" field.</summary>
    public const int DnsFailureRefreshRateFieldNumber = 44;
    private global::Envoy.Api.V2.Cluster.Types.RefreshRate dnsFailureRefreshRate_;
    /// <summary>
    /// If the DNS failure refresh rate is specified and the cluster type is either
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
    /// not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
    /// other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>` and
    /// :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>` this setting is
    /// ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Cluster.Types.RefreshRate DnsFailureRefreshRate {
      get { return dnsFailureRefreshRate_; }
      set {
        dnsFailureRefreshRate_ = value;
      }
    }

    /// <summary>Field number for the "respect_dns_ttl" field.</summary>
    public const int RespectDnsTtlFieldNumber = 39;
    private bool respectDnsTtl_;
    /// <summary>
    /// Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
    /// cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
    /// resolution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool RespectDnsTtl {
      get { return respectDnsTtl_; }
      set {
        respectDnsTtl_ = value;
      }
    }

    /// <summary>Field number for the "dns_lookup_family" field.</summary>
    public const int DnsLookupFamilyFieldNumber = 17;
    private global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily dnsLookupFamily_ = global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto;
    /// <summary>
    /// The DNS IP address resolution policy. If this setting is not specified, the
    /// value defaults to
    /// :ref:`AUTO&lt;envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily DnsLookupFamily {
      get { return dnsLookupFamily_; }
      set {
        dnsLookupFamily_ = value;
      }
    }

    /// <summary>Field number for the "dns_resolvers" field.</summary>
    public const int DnsResolversFieldNumber = 18;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.Address> _repeated_dnsResolvers_codec
        = pb::FieldCodec.ForMessage(146, global::Envoy.Api.V2.Core.Address.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> dnsResolvers_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.Address>();
    /// <summary>
    /// If DNS resolvers are specified and the cluster type is either
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// this value is used to specify the cluster’s dns resolvers.
    /// If this setting is not specified, the value defaults to the default
    /// resolver, which uses /etc/resolv.conf for configuration. For cluster types
    /// other than
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`
    /// this setting is ignored.
    /// Setting this value causes failure if the
    /// ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
    /// server startup. Apple's API only allows overriding DNS resolvers via system settings.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> DnsResolvers {
      get { return dnsResolvers_; }
    }

    /// <summary>Field number for the "use_tcp_for_dns_lookups" field.</summary>
    public const int UseTcpForDnsLookupsFieldNumber = 45;
    private bool useTcpForDnsLookups_;
    /// <summary>
    /// [#next-major-version: Reconcile DNS options in a single message.]
    /// Always use TCP queries instead of UDP queries for DNS lookups.
    /// Setting this value causes failure if the
    /// ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
    /// server startup. Apple' API only uses UDP for DNS resolution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UseTcpForDnsLookups {
      get { return useTcpForDnsLookups_; }
      set {
        useTcpForDnsLookups_ = value;
      }
    }

    /// <summary>Field number for the "outlier_detection" field.</summary>
    public const int OutlierDetectionFieldNumber = 19;
    private global::Envoy.Api.V2.ClusterNS.OutlierDetection outlierDetection_;
    /// <summary>
    /// If specified, outlier detection will be enabled for this upstream cluster.
    /// Each of the configuration values can be overridden via
    /// :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.ClusterNS.OutlierDetection OutlierDetection {
      get { return outlierDetection_; }
      set {
        outlierDetection_ = value;
      }
    }

    /// <summary>Field number for the "cleanup_interval" field.</summary>
    public const int CleanupIntervalFieldNumber = 20;
    private global::Google.Protobuf.WellKnownTypes.Duration cleanupInterval_;
    /// <summary>
    /// The interval for removing stale hosts from a cluster type
    /// :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST>`.
    /// Hosts are considered stale if they have not been used
    /// as upstream destinations during this interval. New hosts are added
    /// to original destination clusters on demand as new connections are
    /// redirected to Envoy, causing the number of hosts in the cluster to
    /// grow over time. Hosts that are not stale (they are actively used as
    /// destinations) are kept in the cluster, which allows connections to
    /// them remain open, saving the latency that would otherwise be spent
    /// on opening new connections. If this setting is not specified, the
    /// value defaults to 5000ms. For cluster types other than
    /// :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST>`
    /// this setting is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration CleanupInterval {
      get { return cleanupInterval_; }
      set {
        cleanupInterval_ = value;
      }
    }

    /// <summary>Field number for the "upstream_bind_config" field.</summary>
    public const int UpstreamBindConfigFieldNumber = 21;
    private global::Envoy.Api.V2.Core.BindConfig upstreamBindConfig_;
    /// <summary>
    /// Optional configuration used to bind newly established upstream connections.
    /// This overrides any bind_config specified in the bootstrap proto.
    /// If the address and port are empty, no bind will be performed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.BindConfig UpstreamBindConfig {
      get { return upstreamBindConfig_; }
      set {
        upstreamBindConfig_ = value;
      }
    }

    /// <summary>Field number for the "lb_subset_config" field.</summary>
    public const int LbSubsetConfigFieldNumber = 22;
    private global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig lbSubsetConfig_;
    /// <summary>
    /// Configuration for load balancing subsetting.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig LbSubsetConfig {
      get { return lbSubsetConfig_; }
      set {
        lbSubsetConfig_ = value;
      }
    }

    /// <summary>Field number for the "ring_hash_lb_config" field.</summary>
    public const int RingHashLbConfigFieldNumber = 23;
    /// <summary>
    /// Optional configuration for the Ring Hash load balancing policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig RingHashLbConfig {
      get { return lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig ? (global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig) lbConfig_ : null; }
      set {
        lbConfig_ = value;
        lbConfigCase_ = value == null ? LbConfigOneofCase.None : LbConfigOneofCase.RingHashLbConfig;
      }
    }

    /// <summary>Field number for the "original_dst_lb_config" field.</summary>
    public const int OriginalDstLbConfigFieldNumber = 34;
    /// <summary>
    /// Optional configuration for the Original Destination load balancing policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig OriginalDstLbConfig {
      get { return lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig ? (global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig) lbConfig_ : null; }
      set {
        lbConfig_ = value;
        lbConfigCase_ = value == null ? LbConfigOneofCase.None : LbConfigOneofCase.OriginalDstLbConfig;
      }
    }

    /// <summary>Field number for the "least_request_lb_config" field.</summary>
    public const int LeastRequestLbConfigFieldNumber = 37;
    /// <summary>
    /// Optional configuration for the LeastRequest load balancing policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig LeastRequestLbConfig {
      get { return lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig ? (global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig) lbConfig_ : null; }
      set {
        lbConfig_ = value;
        lbConfigCase_ = value == null ? LbConfigOneofCase.None : LbConfigOneofCase.LeastRequestLbConfig;
      }
    }

    /// <summary>Field number for the "common_lb_config" field.</summary>
    public const int CommonLbConfigFieldNumber = 27;
    private global::Envoy.Api.V2.Cluster.Types.CommonLbConfig commonLbConfig_;
    /// <summary>
    /// Common configuration for all load balancer implementations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Cluster.Types.CommonLbConfig CommonLbConfig {
      get { return commonLbConfig_; }
      set {
        commonLbConfig_ = value;
      }
    }

    /// <summary>Field number for the "transport_socket" field.</summary>
    public const int TransportSocketFieldNumber = 24;
    private global::Envoy.Api.V2.Core.TransportSocket transportSocket_;
    /// <summary>
    /// Optional custom transport socket implementation to use for upstream connections.
    /// To setup TLS, set a transport socket with name `tls` and
    /// :ref:`UpstreamTlsContexts &lt;envoy_api_msg_auth.UpstreamTlsContext>` in the `typed_config`.
    /// If no transport socket configuration is specified, new connections
    /// will be set up with plaintext.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.TransportSocket TransportSocket {
      get { return transportSocket_; }
      set {
        transportSocket_ = value;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 25;
    private global::Envoy.Api.V2.Core.Metadata metadata_;
    /// <summary>
    /// The Metadata field can be used to provide additional information about the
    /// cluster. It can be used for stats, logging, and varying filter behavior.
    /// Fields should use reverse DNS notation to denote which entity within Envoy
    /// will need the information. For instance, if the metadata is intended for
    /// the Router filter, the filter name should be specified as *envoy.filters.http.router*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "protocol_selection" field.</summary>
    public const int ProtocolSelectionFieldNumber = 26;
    private global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection protocolSelection_ = global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol;
    /// <summary>
    /// Determines how Envoy selects the protocol used to speak to upstream hosts.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection ProtocolSelection {
      get { return protocolSelection_; }
      set {
        protocolSelection_ = value;
      }
    }

    /// <summary>Field number for the "upstream_connection_options" field.</summary>
    public const int UpstreamConnectionOptionsFieldNumber = 30;
    private global::Envoy.Api.V2.UpstreamConnectionOptions upstreamConnectionOptions_;
    /// <summary>
    /// Optional options for upstream connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.UpstreamConnectionOptions UpstreamConnectionOptions {
      get { return upstreamConnectionOptions_; }
      set {
        upstreamConnectionOptions_ = value;
      }
    }

    /// <summary>Field number for the "close_connections_on_host_health_failure" field.</summary>
    public const int CloseConnectionsOnHostHealthFailureFieldNumber = 31;
    private bool closeConnectionsOnHostHealthFailure_;
    /// <summary>
    /// If an upstream host becomes unhealthy (as determined by the configured health checks
    /// or outlier detection), immediately close all connections to the failed host.
    ///
    /// .. note::
    ///
    ///   This is currently only supported for connections created by tcp_proxy.
    ///
    /// .. note::
    ///
    ///   The current implementation of this feature closes all connections immediately when
    ///   the unhealthy status is detected. If there are a large number of connections open
    ///   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
    ///   time exclusively closing these connections, and not processing any other traffic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool CloseConnectionsOnHostHealthFailure {
      get { return closeConnectionsOnHostHealthFailure_; }
      set {
        closeConnectionsOnHostHealthFailure_ = value;
      }
    }

    /// <summary>Field number for the "drain_connections_on_host_removal" field.</summary>
    public const int DrainConnectionsOnHostRemovalFieldNumber = 32;
    private bool drainConnectionsOnHostRemoval_;
    /// <summary>
    /// If set to true, Envoy will ignore the health value of a host when processing its removal
    /// from service discovery. This means that if active health checking is used, Envoy will *not*
    /// wait for the endpoint to go unhealthy before removing it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool DrainConnectionsOnHostRemoval {
      get { return drainConnectionsOnHostRemoval_; }
      set {
        drainConnectionsOnHostRemoval_ = value;
      }
    }

    /// <summary>Field number for the "filters" field.</summary>
    public const int FiltersFieldNumber = 40;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.ClusterNS.Filter> _repeated_filters_codec
        = pb::FieldCodec.ForMessage(322, global::Envoy.Api.V2.ClusterNS.Filter.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.ClusterNS.Filter> filters_ = new pbc::RepeatedField<global::Envoy.Api.V2.ClusterNS.Filter>();
    /// <summary>
    /// An (optional) network filter chain, listed in the order the filters should be applied.
    /// The chain will be applied to all outgoing connections that Envoy makes to the upstream
    /// servers of this cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Api.V2.ClusterNS.Filter> Filters {
      get { return filters_; }
    }

    /// <summary>Field number for the "load_balancing_policy" field.</summary>
    public const int LoadBalancingPolicyFieldNumber = 41;
    private global::Envoy.Api.V2.LoadBalancingPolicy loadBalancingPolicy_;
    /// <summary>
    /// [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
    /// :ref:`lb_policy&lt;envoy_api_field_Cluster.lb_policy>` field has the value
    /// :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.LoadBalancingPolicy LoadBalancingPolicy {
      get { return loadBalancingPolicy_; }
      set {
        loadBalancingPolicy_ = value;
      }
    }

    /// <summary>Field number for the "lrs_server" field.</summary>
    public const int LrsServerFieldNumber = 42;
    private global::Envoy.Api.V2.Core.ConfigSource lrsServer_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// If present, tells the client where to send load reports via LRS. If not present, the
    /// client will fall back to a client-side default, which may be either (a) don't send any
    /// load reports or (b) send load reports for all clusters to a single default server
    /// (which may be configured in the bootstrap file).
    ///
    /// Note that if multiple clusters point to the same LRS server, the client may choose to
    /// create a separate stream for each cluster or it may choose to coalesce the data for
    /// multiple clusters onto a single stream. Either way, the client must make sure to send
    /// the data for any given cluster on no more than one stream.
    ///
    /// [#next-major-version: In the v3 API, we should consider restructuring this somehow,
    /// maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
    /// from the LRS stream here.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.ConfigSource LrsServer {
      get { return lrsServer_; }
      set {
        lrsServer_ = value;
      }
    }

    /// <summary>Field number for the "track_timeout_budgets" field.</summary>
    public const int TrackTimeoutBudgetsFieldNumber = 47;
    private bool trackTimeoutBudgets_;
    /// <summary>
    /// If track_timeout_budgets is true, the :ref:`timeout budget histograms
    /// &lt;config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
    /// request. These show what percentage of a request's per try and global timeout was used. A value
    /// of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
    /// of 100 would indicate that the request took the entirety of the timeout given to it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool TrackTimeoutBudgets {
      get { return trackTimeoutBudgets_; }
      set {
        trackTimeoutBudgets_ = value;
      }
    }

    private object clusterDiscoveryType_;
    /// <summary>Enum of possible cases for the "cluster_discovery_type" oneof.</summary>
    public enum ClusterDiscoveryTypeOneofCase {
      None = 0,
      Type = 2,
      ClusterType = 38,
    }
    private ClusterDiscoveryTypeOneofCase clusterDiscoveryTypeCase_ = ClusterDiscoveryTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClusterDiscoveryTypeOneofCase ClusterDiscoveryTypeCase {
      get { return clusterDiscoveryTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearClusterDiscoveryType() {
      clusterDiscoveryTypeCase_ = ClusterDiscoveryTypeOneofCase.None;
      clusterDiscoveryType_ = null;
    }

    private object lbConfig_;
    /// <summary>Enum of possible cases for the "lb_config" oneof.</summary>
    public enum LbConfigOneofCase {
      None = 0,
      RingHashLbConfig = 23,
      OriginalDstLbConfig = 34,
      LeastRequestLbConfig = 37,
    }
    private LbConfigOneofCase lbConfigCase_ = LbConfigOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LbConfigOneofCase LbConfigCase {
      get { return lbConfigCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLbConfig() {
      lbConfigCase_ = LbConfigOneofCase.None;
      lbConfig_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Cluster);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Cluster other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!transportSocketMatches_.Equals(other.transportSocketMatches_)) return false;
      if (Name != other.Name) return false;
      if (AltStatName != other.AltStatName) return false;
      if (Type != other.Type) return false;
      if (!object.Equals(ClusterType, other.ClusterType)) return false;
      if (!object.Equals(EdsClusterConfig, other.EdsClusterConfig)) return false;
      if (!object.Equals(ConnectTimeout, other.ConnectTimeout)) return false;
      if (PerConnectionBufferLimitBytes != other.PerConnectionBufferLimitBytes) return false;
      if (LbPolicy != other.LbPolicy) return false;
      if(!hosts_.Equals(other.hosts_)) return false;
      if (!object.Equals(LoadAssignment, other.LoadAssignment)) return false;
      if(!healthChecks_.Equals(other.healthChecks_)) return false;
      if (MaxRequestsPerConnection != other.MaxRequestsPerConnection) return false;
      if (!object.Equals(CircuitBreakers, other.CircuitBreakers)) return false;
      if (!object.Equals(TlsContext, other.TlsContext)) return false;
      if (!object.Equals(UpstreamHttpProtocolOptions, other.UpstreamHttpProtocolOptions)) return false;
      if (!object.Equals(CommonHttpProtocolOptions, other.CommonHttpProtocolOptions)) return false;
      if (!object.Equals(HttpProtocolOptions, other.HttpProtocolOptions)) return false;
      if (!object.Equals(Http2ProtocolOptions, other.Http2ProtocolOptions)) return false;
      if (!ExtensionProtocolOptions.Equals(other.ExtensionProtocolOptions)) return false;
      if (!TypedExtensionProtocolOptions.Equals(other.TypedExtensionProtocolOptions)) return false;
      if (!object.Equals(DnsRefreshRate, other.DnsRefreshRate)) return false;
      if (!object.Equals(DnsFailureRefreshRate, other.DnsFailureRefreshRate)) return false;
      if (RespectDnsTtl != other.RespectDnsTtl) return false;
      if (DnsLookupFamily != other.DnsLookupFamily) return false;
      if(!dnsResolvers_.Equals(other.dnsResolvers_)) return false;
      if (UseTcpForDnsLookups != other.UseTcpForDnsLookups) return false;
      if (!object.Equals(OutlierDetection, other.OutlierDetection)) return false;
      if (!object.Equals(CleanupInterval, other.CleanupInterval)) return false;
      if (!object.Equals(UpstreamBindConfig, other.UpstreamBindConfig)) return false;
      if (!object.Equals(LbSubsetConfig, other.LbSubsetConfig)) return false;
      if (!object.Equals(RingHashLbConfig, other.RingHashLbConfig)) return false;
      if (!object.Equals(OriginalDstLbConfig, other.OriginalDstLbConfig)) return false;
      if (!object.Equals(LeastRequestLbConfig, other.LeastRequestLbConfig)) return false;
      if (!object.Equals(CommonLbConfig, other.CommonLbConfig)) return false;
      if (!object.Equals(TransportSocket, other.TransportSocket)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (ProtocolSelection != other.ProtocolSelection) return false;
      if (!object.Equals(UpstreamConnectionOptions, other.UpstreamConnectionOptions)) return false;
      if (CloseConnectionsOnHostHealthFailure != other.CloseConnectionsOnHostHealthFailure) return false;
      if (DrainConnectionsOnHostRemoval != other.DrainConnectionsOnHostRemoval) return false;
      if(!filters_.Equals(other.filters_)) return false;
      if (!object.Equals(LoadBalancingPolicy, other.LoadBalancingPolicy)) return false;
      if (!object.Equals(LrsServer, other.LrsServer)) return false;
      if (TrackTimeoutBudgets != other.TrackTimeoutBudgets) return false;
      if (ClusterDiscoveryTypeCase != other.ClusterDiscoveryTypeCase) return false;
      if (LbConfigCase != other.LbConfigCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= transportSocketMatches_.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (AltStatName.Length != 0) hash ^= AltStatName.GetHashCode();
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.Type) hash ^= Type.GetHashCode();
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) hash ^= ClusterType.GetHashCode();
      if (edsClusterConfig_ != null) hash ^= EdsClusterConfig.GetHashCode();
      if (connectTimeout_ != null) hash ^= ConnectTimeout.GetHashCode();
      if (perConnectionBufferLimitBytes_ != null) hash ^= PerConnectionBufferLimitBytes.GetHashCode();
      if (LbPolicy != global::Envoy.Api.V2.Cluster.Types.LbPolicy.RoundRobin) hash ^= LbPolicy.GetHashCode();
      hash ^= hosts_.GetHashCode();
      if (loadAssignment_ != null) hash ^= LoadAssignment.GetHashCode();
      hash ^= healthChecks_.GetHashCode();
      if (maxRequestsPerConnection_ != null) hash ^= MaxRequestsPerConnection.GetHashCode();
      if (circuitBreakers_ != null) hash ^= CircuitBreakers.GetHashCode();
      if (tlsContext_ != null) hash ^= TlsContext.GetHashCode();
      if (upstreamHttpProtocolOptions_ != null) hash ^= UpstreamHttpProtocolOptions.GetHashCode();
      if (commonHttpProtocolOptions_ != null) hash ^= CommonHttpProtocolOptions.GetHashCode();
      if (httpProtocolOptions_ != null) hash ^= HttpProtocolOptions.GetHashCode();
      if (http2ProtocolOptions_ != null) hash ^= Http2ProtocolOptions.GetHashCode();
      hash ^= ExtensionProtocolOptions.GetHashCode();
      hash ^= TypedExtensionProtocolOptions.GetHashCode();
      if (dnsRefreshRate_ != null) hash ^= DnsRefreshRate.GetHashCode();
      if (dnsFailureRefreshRate_ != null) hash ^= DnsFailureRefreshRate.GetHashCode();
      if (RespectDnsTtl != false) hash ^= RespectDnsTtl.GetHashCode();
      if (DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) hash ^= DnsLookupFamily.GetHashCode();
      hash ^= dnsResolvers_.GetHashCode();
      if (UseTcpForDnsLookups != false) hash ^= UseTcpForDnsLookups.GetHashCode();
      if (outlierDetection_ != null) hash ^= OutlierDetection.GetHashCode();
      if (cleanupInterval_ != null) hash ^= CleanupInterval.GetHashCode();
      if (upstreamBindConfig_ != null) hash ^= UpstreamBindConfig.GetHashCode();
      if (lbSubsetConfig_ != null) hash ^= LbSubsetConfig.GetHashCode();
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) hash ^= RingHashLbConfig.GetHashCode();
      if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) hash ^= OriginalDstLbConfig.GetHashCode();
      if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) hash ^= LeastRequestLbConfig.GetHashCode();
      if (commonLbConfig_ != null) hash ^= CommonLbConfig.GetHashCode();
      if (transportSocket_ != null) hash ^= TransportSocket.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (ProtocolSelection != global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol) hash ^= ProtocolSelection.GetHashCode();
      if (upstreamConnectionOptions_ != null) hash ^= UpstreamConnectionOptions.GetHashCode();
      if (CloseConnectionsOnHostHealthFailure != false) hash ^= CloseConnectionsOnHostHealthFailure.GetHashCode();
      if (DrainConnectionsOnHostRemoval != false) hash ^= DrainConnectionsOnHostRemoval.GetHashCode();
      hash ^= filters_.GetHashCode();
      if (loadBalancingPolicy_ != null) hash ^= LoadBalancingPolicy.GetHashCode();
      if (lrsServer_ != null) hash ^= LrsServer.GetHashCode();
      if (TrackTimeoutBudgets != false) hash ^= TrackTimeoutBudgets.GetHashCode();
      hash ^= (int) clusterDiscoveryTypeCase_;
      hash ^= (int) lbConfigCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.Type) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (edsClusterConfig_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(EdsClusterConfig);
      }
      if (connectTimeout_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ConnectTimeout);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        _single_perConnectionBufferLimitBytes_codec.WriteTagAndValue(output, PerConnectionBufferLimitBytes);
      }
      if (LbPolicy != global::Envoy.Api.V2.Cluster.Types.LbPolicy.RoundRobin) {
        output.WriteRawTag(48);
        output.WriteEnum((int) LbPolicy);
      }
      hosts_.WriteTo(output, _repeated_hosts_codec);
      healthChecks_.WriteTo(output, _repeated_healthChecks_codec);
      if (maxRequestsPerConnection_ != null) {
        _single_maxRequestsPerConnection_codec.WriteTagAndValue(output, MaxRequestsPerConnection);
      }
      if (circuitBreakers_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(CircuitBreakers);
      }
      if (tlsContext_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(TlsContext);
      }
      if (httpProtocolOptions_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (dnsRefreshRate_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(DnsRefreshRate);
      }
      if (DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) DnsLookupFamily);
      }
      dnsResolvers_.WriteTo(output, _repeated_dnsResolvers_codec);
      if (outlierDetection_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(OutlierDetection);
      }
      if (cleanupInterval_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(CleanupInterval);
      }
      if (upstreamBindConfig_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(UpstreamBindConfig);
      }
      if (lbSubsetConfig_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(LbSubsetConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(RingHashLbConfig);
      }
      if (transportSocket_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(TransportSocket);
      }
      if (metadata_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(Metadata);
      }
      if (ProtocolSelection != global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol) {
        output.WriteRawTag(208, 1);
        output.WriteEnum((int) ProtocolSelection);
      }
      if (commonLbConfig_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(CommonLbConfig);
      }
      if (AltStatName.Length != 0) {
        output.WriteRawTag(226, 1);
        output.WriteString(AltStatName);
      }
      if (commonHttpProtocolOptions_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(CommonHttpProtocolOptions);
      }
      if (upstreamConnectionOptions_ != null) {
        output.WriteRawTag(242, 1);
        output.WriteMessage(UpstreamConnectionOptions);
      }
      if (CloseConnectionsOnHostHealthFailure != false) {
        output.WriteRawTag(248, 1);
        output.WriteBool(CloseConnectionsOnHostHealthFailure);
      }
      if (DrainConnectionsOnHostRemoval != false) {
        output.WriteRawTag(128, 2);
        output.WriteBool(DrainConnectionsOnHostRemoval);
      }
      if (loadAssignment_ != null) {
        output.WriteRawTag(138, 2);
        output.WriteMessage(LoadAssignment);
      }
      if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) {
        output.WriteRawTag(146, 2);
        output.WriteMessage(OriginalDstLbConfig);
      }
      extensionProtocolOptions_.WriteTo(output, _map_extensionProtocolOptions_codec);
      typedExtensionProtocolOptions_.WriteTo(output, _map_typedExtensionProtocolOptions_codec);
      if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) {
        output.WriteRawTag(170, 2);
        output.WriteMessage(LeastRequestLbConfig);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) {
        output.WriteRawTag(178, 2);
        output.WriteMessage(ClusterType);
      }
      if (RespectDnsTtl != false) {
        output.WriteRawTag(184, 2);
        output.WriteBool(RespectDnsTtl);
      }
      filters_.WriteTo(output, _repeated_filters_codec);
      if (loadBalancingPolicy_ != null) {
        output.WriteRawTag(202, 2);
        output.WriteMessage(LoadBalancingPolicy);
      }
      if (lrsServer_ != null) {
        output.WriteRawTag(210, 2);
        output.WriteMessage(LrsServer);
      }
      transportSocketMatches_.WriteTo(output, _repeated_transportSocketMatches_codec);
      if (dnsFailureRefreshRate_ != null) {
        output.WriteRawTag(226, 2);
        output.WriteMessage(DnsFailureRefreshRate);
      }
      if (UseTcpForDnsLookups != false) {
        output.WriteRawTag(232, 2);
        output.WriteBool(UseTcpForDnsLookups);
      }
      if (upstreamHttpProtocolOptions_ != null) {
        output.WriteRawTag(242, 2);
        output.WriteMessage(UpstreamHttpProtocolOptions);
      }
      if (TrackTimeoutBudgets != false) {
        output.WriteRawTag(248, 2);
        output.WriteBool(TrackTimeoutBudgets);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.Type) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (edsClusterConfig_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(EdsClusterConfig);
      }
      if (connectTimeout_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ConnectTimeout);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        _single_perConnectionBufferLimitBytes_codec.WriteTagAndValue(ref output, PerConnectionBufferLimitBytes);
      }
      if (LbPolicy != global::Envoy.Api.V2.Cluster.Types.LbPolicy.RoundRobin) {
        output.WriteRawTag(48);
        output.WriteEnum((int) LbPolicy);
      }
      hosts_.WriteTo(ref output, _repeated_hosts_codec);
      healthChecks_.WriteTo(ref output, _repeated_healthChecks_codec);
      if (maxRequestsPerConnection_ != null) {
        _single_maxRequestsPerConnection_codec.WriteTagAndValue(ref output, MaxRequestsPerConnection);
      }
      if (circuitBreakers_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(CircuitBreakers);
      }
      if (tlsContext_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(TlsContext);
      }
      if (httpProtocolOptions_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (dnsRefreshRate_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(DnsRefreshRate);
      }
      if (DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) DnsLookupFamily);
      }
      dnsResolvers_.WriteTo(ref output, _repeated_dnsResolvers_codec);
      if (outlierDetection_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(OutlierDetection);
      }
      if (cleanupInterval_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(CleanupInterval);
      }
      if (upstreamBindConfig_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(UpstreamBindConfig);
      }
      if (lbSubsetConfig_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(LbSubsetConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(RingHashLbConfig);
      }
      if (transportSocket_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(TransportSocket);
      }
      if (metadata_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(Metadata);
      }
      if (ProtocolSelection != global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol) {
        output.WriteRawTag(208, 1);
        output.WriteEnum((int) ProtocolSelection);
      }
      if (commonLbConfig_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(CommonLbConfig);
      }
      if (AltStatName.Length != 0) {
        output.WriteRawTag(226, 1);
        output.WriteString(AltStatName);
      }
      if (commonHttpProtocolOptions_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(CommonHttpProtocolOptions);
      }
      if (upstreamConnectionOptions_ != null) {
        output.WriteRawTag(242, 1);
        output.WriteMessage(UpstreamConnectionOptions);
      }
      if (CloseConnectionsOnHostHealthFailure != false) {
        output.WriteRawTag(248, 1);
        output.WriteBool(CloseConnectionsOnHostHealthFailure);
      }
      if (DrainConnectionsOnHostRemoval != false) {
        output.WriteRawTag(128, 2);
        output.WriteBool(DrainConnectionsOnHostRemoval);
      }
      if (loadAssignment_ != null) {
        output.WriteRawTag(138, 2);
        output.WriteMessage(LoadAssignment);
      }
      if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) {
        output.WriteRawTag(146, 2);
        output.WriteMessage(OriginalDstLbConfig);
      }
      extensionProtocolOptions_.WriteTo(ref output, _map_extensionProtocolOptions_codec);
      typedExtensionProtocolOptions_.WriteTo(ref output, _map_typedExtensionProtocolOptions_codec);
      if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) {
        output.WriteRawTag(170, 2);
        output.WriteMessage(LeastRequestLbConfig);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) {
        output.WriteRawTag(178, 2);
        output.WriteMessage(ClusterType);
      }
      if (RespectDnsTtl != false) {
        output.WriteRawTag(184, 2);
        output.WriteBool(RespectDnsTtl);
      }
      filters_.WriteTo(ref output, _repeated_filters_codec);
      if (loadBalancingPolicy_ != null) {
        output.WriteRawTag(202, 2);
        output.WriteMessage(LoadBalancingPolicy);
      }
      if (lrsServer_ != null) {
        output.WriteRawTag(210, 2);
        output.WriteMessage(LrsServer);
      }
      transportSocketMatches_.WriteTo(ref output, _repeated_transportSocketMatches_codec);
      if (dnsFailureRefreshRate_ != null) {
        output.WriteRawTag(226, 2);
        output.WriteMessage(DnsFailureRefreshRate);
      }
      if (UseTcpForDnsLookups != false) {
        output.WriteRawTag(232, 2);
        output.WriteBool(UseTcpForDnsLookups);
      }
      if (upstreamHttpProtocolOptions_ != null) {
        output.WriteRawTag(242, 2);
        output.WriteMessage(UpstreamHttpProtocolOptions);
      }
      if (TrackTimeoutBudgets != false) {
        output.WriteRawTag(248, 2);
        output.WriteBool(TrackTimeoutBudgets);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += transportSocketMatches_.CalculateSize(_repeated_transportSocketMatches_codec);
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (AltStatName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(AltStatName);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.Type) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ClusterType);
      }
      if (edsClusterConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EdsClusterConfig);
      }
      if (connectTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConnectTimeout);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        size += _single_perConnectionBufferLimitBytes_codec.CalculateSizeWithTag(PerConnectionBufferLimitBytes);
      }
      if (LbPolicy != global::Envoy.Api.V2.Cluster.Types.LbPolicy.RoundRobin) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LbPolicy);
      }
      size += hosts_.CalculateSize(_repeated_hosts_codec);
      if (loadAssignment_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LoadAssignment);
      }
      size += healthChecks_.CalculateSize(_repeated_healthChecks_codec);
      if (maxRequestsPerConnection_ != null) {
        size += _single_maxRequestsPerConnection_codec.CalculateSizeWithTag(MaxRequestsPerConnection);
      }
      if (circuitBreakers_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CircuitBreakers);
      }
      if (tlsContext_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TlsContext);
      }
      if (upstreamHttpProtocolOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UpstreamHttpProtocolOptions);
      }
      if (commonHttpProtocolOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CommonHttpProtocolOptions);
      }
      if (httpProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Http2ProtocolOptions);
      }
      size += extensionProtocolOptions_.CalculateSize(_map_extensionProtocolOptions_codec);
      size += typedExtensionProtocolOptions_.CalculateSize(_map_typedExtensionProtocolOptions_codec);
      if (dnsRefreshRate_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DnsRefreshRate);
      }
      if (dnsFailureRefreshRate_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DnsFailureRefreshRate);
      }
      if (RespectDnsTtl != false) {
        size += 2 + 1;
      }
      if (DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) DnsLookupFamily);
      }
      size += dnsResolvers_.CalculateSize(_repeated_dnsResolvers_codec);
      if (UseTcpForDnsLookups != false) {
        size += 2 + 1;
      }
      if (outlierDetection_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OutlierDetection);
      }
      if (cleanupInterval_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CleanupInterval);
      }
      if (upstreamBindConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UpstreamBindConfig);
      }
      if (lbSubsetConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LbSubsetConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RingHashLbConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OriginalDstLbConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LeastRequestLbConfig);
      }
      if (commonLbConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CommonLbConfig);
      }
      if (transportSocket_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TransportSocket);
      }
      if (metadata_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (ProtocolSelection != global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ProtocolSelection);
      }
      if (upstreamConnectionOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UpstreamConnectionOptions);
      }
      if (CloseConnectionsOnHostHealthFailure != false) {
        size += 2 + 1;
      }
      if (DrainConnectionsOnHostRemoval != false) {
        size += 2 + 1;
      }
      size += filters_.CalculateSize(_repeated_filters_codec);
      if (loadBalancingPolicy_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LoadBalancingPolicy);
      }
      if (lrsServer_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LrsServer);
      }
      if (TrackTimeoutBudgets != false) {
        size += 2 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Cluster other) {
      if (other == null) {
        return;
      }
      transportSocketMatches_.Add(other.transportSocketMatches_);
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.AltStatName.Length != 0) {
        AltStatName = other.AltStatName;
      }
      if (other.edsClusterConfig_ != null) {
        if (edsClusterConfig_ == null) {
          EdsClusterConfig = new global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig();
        }
        EdsClusterConfig.MergeFrom(other.EdsClusterConfig);
      }
      if (other.connectTimeout_ != null) {
        if (connectTimeout_ == null) {
          ConnectTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        ConnectTimeout.MergeFrom(other.ConnectTimeout);
      }
      if (other.perConnectionBufferLimitBytes_ != null) {
        if (perConnectionBufferLimitBytes_ == null || other.PerConnectionBufferLimitBytes != 0) {
          PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
        }
      }
      if (other.LbPolicy != global::Envoy.Api.V2.Cluster.Types.LbPolicy.RoundRobin) {
        LbPolicy = other.LbPolicy;
      }
      hosts_.Add(other.hosts_);
      if (other.loadAssignment_ != null) {
        if (loadAssignment_ == null) {
          LoadAssignment = new global::Envoy.Api.V2.ClusterLoadAssignment();
        }
        LoadAssignment.MergeFrom(other.LoadAssignment);
      }
      healthChecks_.Add(other.healthChecks_);
      if (other.maxRequestsPerConnection_ != null) {
        if (maxRequestsPerConnection_ == null || other.MaxRequestsPerConnection != 0) {
          MaxRequestsPerConnection = other.MaxRequestsPerConnection;
        }
      }
      if (other.circuitBreakers_ != null) {
        if (circuitBreakers_ == null) {
          CircuitBreakers = new global::Envoy.Api.V2.ClusterNS.CircuitBreakers();
        }
        CircuitBreakers.MergeFrom(other.CircuitBreakers);
      }
      if (other.tlsContext_ != null) {
        if (tlsContext_ == null) {
          TlsContext = new global::Envoy.Api.V2.Auth.UpstreamTlsContext();
        }
        TlsContext.MergeFrom(other.TlsContext);
      }
      if (other.upstreamHttpProtocolOptions_ != null) {
        if (upstreamHttpProtocolOptions_ == null) {
          UpstreamHttpProtocolOptions = new global::Envoy.Api.V2.Core.UpstreamHttpProtocolOptions();
        }
        UpstreamHttpProtocolOptions.MergeFrom(other.UpstreamHttpProtocolOptions);
      }
      if (other.commonHttpProtocolOptions_ != null) {
        if (commonHttpProtocolOptions_ == null) {
          CommonHttpProtocolOptions = new global::Envoy.Api.V2.Core.HttpProtocolOptions();
        }
        CommonHttpProtocolOptions.MergeFrom(other.CommonHttpProtocolOptions);
      }
      if (other.httpProtocolOptions_ != null) {
        if (httpProtocolOptions_ == null) {
          HttpProtocolOptions = new global::Envoy.Api.V2.Core.Http1ProtocolOptions();
        }
        HttpProtocolOptions.MergeFrom(other.HttpProtocolOptions);
      }
      if (other.http2ProtocolOptions_ != null) {
        if (http2ProtocolOptions_ == null) {
          Http2ProtocolOptions = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
        }
        Http2ProtocolOptions.MergeFrom(other.Http2ProtocolOptions);
      }
      extensionProtocolOptions_.Add(other.extensionProtocolOptions_);
      typedExtensionProtocolOptions_.Add(other.typedExtensionProtocolOptions_);
      if (other.dnsRefreshRate_ != null) {
        if (dnsRefreshRate_ == null) {
          DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DnsRefreshRate.MergeFrom(other.DnsRefreshRate);
      }
      if (other.dnsFailureRefreshRate_ != null) {
        if (dnsFailureRefreshRate_ == null) {
          DnsFailureRefreshRate = new global::Envoy.Api.V2.Cluster.Types.RefreshRate();
        }
        DnsFailureRefreshRate.MergeFrom(other.DnsFailureRefreshRate);
      }
      if (other.RespectDnsTtl != false) {
        RespectDnsTtl = other.RespectDnsTtl;
      }
      if (other.DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) {
        DnsLookupFamily = other.DnsLookupFamily;
      }
      dnsResolvers_.Add(other.dnsResolvers_);
      if (other.UseTcpForDnsLookups != false) {
        UseTcpForDnsLookups = other.UseTcpForDnsLookups;
      }
      if (other.outlierDetection_ != null) {
        if (outlierDetection_ == null) {
          OutlierDetection = new global::Envoy.Api.V2.ClusterNS.OutlierDetection();
        }
        OutlierDetection.MergeFrom(other.OutlierDetection);
      }
      if (other.cleanupInterval_ != null) {
        if (cleanupInterval_ == null) {
          CleanupInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        CleanupInterval.MergeFrom(other.CleanupInterval);
      }
      if (other.upstreamBindConfig_ != null) {
        if (upstreamBindConfig_ == null) {
          UpstreamBindConfig = new global::Envoy.Api.V2.Core.BindConfig();
        }
        UpstreamBindConfig.MergeFrom(other.UpstreamBindConfig);
      }
      if (other.lbSubsetConfig_ != null) {
        if (lbSubsetConfig_ == null) {
          LbSubsetConfig = new global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig();
        }
        LbSubsetConfig.MergeFrom(other.LbSubsetConfig);
      }
      if (other.commonLbConfig_ != null) {
        if (commonLbConfig_ == null) {
          CommonLbConfig = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig();
        }
        CommonLbConfig.MergeFrom(other.CommonLbConfig);
      }
      if (other.transportSocket_ != null) {
        if (transportSocket_ == null) {
          TransportSocket = new global::Envoy.Api.V2.Core.TransportSocket();
        }
        TransportSocket.MergeFrom(other.TransportSocket);
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::Envoy.Api.V2.Core.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.ProtocolSelection != global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol) {
        ProtocolSelection = other.ProtocolSelection;
      }
      if (other.upstreamConnectionOptions_ != null) {
        if (upstreamConnectionOptions_ == null) {
          UpstreamConnectionOptions = new global::Envoy.Api.V2.UpstreamConnectionOptions();
        }
        UpstreamConnectionOptions.MergeFrom(other.UpstreamConnectionOptions);
      }
      if (other.CloseConnectionsOnHostHealthFailure != false) {
        CloseConnectionsOnHostHealthFailure = other.CloseConnectionsOnHostHealthFailure;
      }
      if (other.DrainConnectionsOnHostRemoval != false) {
        DrainConnectionsOnHostRemoval = other.DrainConnectionsOnHostRemoval;
      }
      filters_.Add(other.filters_);
      if (other.loadBalancingPolicy_ != null) {
        if (loadBalancingPolicy_ == null) {
          LoadBalancingPolicy = new global::Envoy.Api.V2.LoadBalancingPolicy();
        }
        LoadBalancingPolicy.MergeFrom(other.LoadBalancingPolicy);
      }
      if (other.lrsServer_ != null) {
        if (lrsServer_ == null) {
          LrsServer = new global::Envoy.Api.V2.Core.ConfigSource();
        }
        LrsServer.MergeFrom(other.LrsServer);
      }
      if (other.TrackTimeoutBudgets != false) {
        TrackTimeoutBudgets = other.TrackTimeoutBudgets;
      }
      switch (other.ClusterDiscoveryTypeCase) {
        case ClusterDiscoveryTypeOneofCase.Type:
          Type = other.Type;
          break;
        case ClusterDiscoveryTypeOneofCase.ClusterType:
          if (ClusterType == null) {
            ClusterType = new global::Envoy.Api.V2.Cluster.Types.CustomClusterType();
          }
          ClusterType.MergeFrom(other.ClusterType);
          break;
      }

      switch (other.LbConfigCase) {
        case LbConfigOneofCase.RingHashLbConfig:
          if (RingHashLbConfig == null) {
            RingHashLbConfig = new global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig();
          }
          RingHashLbConfig.MergeFrom(other.RingHashLbConfig);
          break;
        case LbConfigOneofCase.OriginalDstLbConfig:
          if (OriginalDstLbConfig == null) {
            OriginalDstLbConfig = new global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig();
          }
          OriginalDstLbConfig.MergeFrom(other.OriginalDstLbConfig);
          break;
        case LbConfigOneofCase.LeastRequestLbConfig:
          if (LeastRequestLbConfig == null) {
            LeastRequestLbConfig = new global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig();
          }
          LeastRequestLbConfig.MergeFrom(other.LeastRequestLbConfig);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            clusterDiscoveryType_ = input.ReadEnum();
            clusterDiscoveryTypeCase_ = ClusterDiscoveryTypeOneofCase.Type;
            break;
          }
          case 26: {
            if (edsClusterConfig_ == null) {
              EdsClusterConfig = new global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig();
            }
            input.ReadMessage(EdsClusterConfig);
            break;
          }
          case 34: {
            if (connectTimeout_ == null) {
              ConnectTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(ConnectTimeout);
            break;
          }
          case 42: {
            uint? value = _single_perConnectionBufferLimitBytes_codec.Read(input);
            if (perConnectionBufferLimitBytes_ == null || value != 0) {
              PerConnectionBufferLimitBytes = value;
            }
            break;
          }
          case 48: {
            LbPolicy = (global::Envoy.Api.V2.Cluster.Types.LbPolicy) input.ReadEnum();
            break;
          }
          case 58: {
            hosts_.AddEntriesFrom(input, _repeated_hosts_codec);
            break;
          }
          case 66: {
            healthChecks_.AddEntriesFrom(input, _repeated_healthChecks_codec);
            break;
          }
          case 74: {
            uint? value = _single_maxRequestsPerConnection_codec.Read(input);
            if (maxRequestsPerConnection_ == null || value != 0) {
              MaxRequestsPerConnection = value;
            }
            break;
          }
          case 82: {
            if (circuitBreakers_ == null) {
              CircuitBreakers = new global::Envoy.Api.V2.ClusterNS.CircuitBreakers();
            }
            input.ReadMessage(CircuitBreakers);
            break;
          }
          case 90: {
            if (tlsContext_ == null) {
              TlsContext = new global::Envoy.Api.V2.Auth.UpstreamTlsContext();
            }
            input.ReadMessage(TlsContext);
            break;
          }
          case 106: {
            if (httpProtocolOptions_ == null) {
              HttpProtocolOptions = new global::Envoy.Api.V2.Core.Http1ProtocolOptions();
            }
            input.ReadMessage(HttpProtocolOptions);
            break;
          }
          case 114: {
            if (http2ProtocolOptions_ == null) {
              Http2ProtocolOptions = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
            }
            input.ReadMessage(Http2ProtocolOptions);
            break;
          }
          case 130: {
            if (dnsRefreshRate_ == null) {
              DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DnsRefreshRate);
            break;
          }
          case 136: {
            DnsLookupFamily = (global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily) input.ReadEnum();
            break;
          }
          case 146: {
            dnsResolvers_.AddEntriesFrom(input, _repeated_dnsResolvers_codec);
            break;
          }
          case 154: {
            if (outlierDetection_ == null) {
              OutlierDetection = new global::Envoy.Api.V2.ClusterNS.OutlierDetection();
            }
            input.ReadMessage(OutlierDetection);
            break;
          }
          case 162: {
            if (cleanupInterval_ == null) {
              CleanupInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(CleanupInterval);
            break;
          }
          case 170: {
            if (upstreamBindConfig_ == null) {
              UpstreamBindConfig = new global::Envoy.Api.V2.Core.BindConfig();
            }
            input.ReadMessage(UpstreamBindConfig);
            break;
          }
          case 178: {
            if (lbSubsetConfig_ == null) {
              LbSubsetConfig = new global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig();
            }
            input.ReadMessage(LbSubsetConfig);
            break;
          }
          case 186: {
            global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
              subBuilder.MergeFrom(RingHashLbConfig);
            }
            input.ReadMessage(subBuilder);
            RingHashLbConfig = subBuilder;
            break;
          }
          case 194: {
            if (transportSocket_ == null) {
              TransportSocket = new global::Envoy.Api.V2.Core.TransportSocket();
            }
            input.ReadMessage(TransportSocket);
            break;
          }
          case 202: {
            if (metadata_ == null) {
              Metadata = new global::Envoy.Api.V2.Core.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 208: {
            ProtocolSelection = (global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection) input.ReadEnum();
            break;
          }
          case 218: {
            if (commonLbConfig_ == null) {
              CommonLbConfig = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig();
            }
            input.ReadMessage(CommonLbConfig);
            break;
          }
          case 226: {
            AltStatName = input.ReadString();
            break;
          }
          case 234: {
            if (commonHttpProtocolOptions_ == null) {
              CommonHttpProtocolOptions = new global::Envoy.Api.V2.Core.HttpProtocolOptions();
            }
            input.ReadMessage(CommonHttpProtocolOptions);
            break;
          }
          case 242: {
            if (upstreamConnectionOptions_ == null) {
              UpstreamConnectionOptions = new global::Envoy.Api.V2.UpstreamConnectionOptions();
            }
            input.ReadMessage(UpstreamConnectionOptions);
            break;
          }
          case 248: {
            CloseConnectionsOnHostHealthFailure = input.ReadBool();
            break;
          }
          case 256: {
            DrainConnectionsOnHostRemoval = input.ReadBool();
            break;
          }
          case 266: {
            if (loadAssignment_ == null) {
              LoadAssignment = new global::Envoy.Api.V2.ClusterLoadAssignment();
            }
            input.ReadMessage(LoadAssignment);
            break;
          }
          case 274: {
            global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) {
              subBuilder.MergeFrom(OriginalDstLbConfig);
            }
            input.ReadMessage(subBuilder);
            OriginalDstLbConfig = subBuilder;
            break;
          }
          case 282: {
            extensionProtocolOptions_.AddEntriesFrom(input, _map_extensionProtocolOptions_codec);
            break;
          }
          case 290: {
            typedExtensionProtocolOptions_.AddEntriesFrom(input, _map_typedExtensionProtocolOptions_codec);
            break;
          }
          case 298: {
            global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) {
              subBuilder.MergeFrom(LeastRequestLbConfig);
            }
            input.ReadMessage(subBuilder);
            LeastRequestLbConfig = subBuilder;
            break;
          }
          case 306: {
            global::Envoy.Api.V2.Cluster.Types.CustomClusterType subBuilder = new global::Envoy.Api.V2.Cluster.Types.CustomClusterType();
            if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) {
              subBuilder.MergeFrom(ClusterType);
            }
            input.ReadMessage(subBuilder);
            ClusterType = subBuilder;
            break;
          }
          case 312: {
            RespectDnsTtl = input.ReadBool();
            break;
          }
          case 322: {
            filters_.AddEntriesFrom(input, _repeated_filters_codec);
            break;
          }
          case 330: {
            if (loadBalancingPolicy_ == null) {
              LoadBalancingPolicy = new global::Envoy.Api.V2.LoadBalancingPolicy();
            }
            input.ReadMessage(LoadBalancingPolicy);
            break;
          }
          case 338: {
            if (lrsServer_ == null) {
              LrsServer = new global::Envoy.Api.V2.Core.ConfigSource();
            }
            input.ReadMessage(LrsServer);
            break;
          }
          case 346: {
            transportSocketMatches_.AddEntriesFrom(input, _repeated_transportSocketMatches_codec);
            break;
          }
          case 354: {
            if (dnsFailureRefreshRate_ == null) {
              DnsFailureRefreshRate = new global::Envoy.Api.V2.Cluster.Types.RefreshRate();
            }
            input.ReadMessage(DnsFailureRefreshRate);
            break;
          }
          case 360: {
            UseTcpForDnsLookups = input.ReadBool();
            break;
          }
          case 370: {
            if (upstreamHttpProtocolOptions_ == null) {
              UpstreamHttpProtocolOptions = new global::Envoy.Api.V2.Core.UpstreamHttpProtocolOptions();
            }
            input.ReadMessage(UpstreamHttpProtocolOptions);
            break;
          }
          case 376: {
            TrackTimeoutBudgets = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            clusterDiscoveryType_ = input.ReadEnum();
            clusterDiscoveryTypeCase_ = ClusterDiscoveryTypeOneofCase.Type;
            break;
          }
          case 26: {
            if (edsClusterConfig_ == null) {
              EdsClusterConfig = new global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig();
            }
            input.ReadMessage(EdsClusterConfig);
            break;
          }
          case 34: {
            if (connectTimeout_ == null) {
              ConnectTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(ConnectTimeout);
            break;
          }
          case 42: {
            uint? value = _single_perConnectionBufferLimitBytes_codec.Read(ref input);
            if (perConnectionBufferLimitBytes_ == null || value != 0) {
              PerConnectionBufferLimitBytes = value;
            }
            break;
          }
          case 48: {
            LbPolicy = (global::Envoy.Api.V2.Cluster.Types.LbPolicy) input.ReadEnum();
            break;
          }
          case 58: {
            hosts_.AddEntriesFrom(ref input, _repeated_hosts_codec);
            break;
          }
          case 66: {
            healthChecks_.AddEntriesFrom(ref input, _repeated_healthChecks_codec);
            break;
          }
          case 74: {
            uint? value = _single_maxRequestsPerConnection_codec.Read(ref input);
            if (maxRequestsPerConnection_ == null || value != 0) {
              MaxRequestsPerConnection = value;
            }
            break;
          }
          case 82: {
            if (circuitBreakers_ == null) {
              CircuitBreakers = new global::Envoy.Api.V2.ClusterNS.CircuitBreakers();
            }
            input.ReadMessage(CircuitBreakers);
            break;
          }
          case 90: {
            if (tlsContext_ == null) {
              TlsContext = new global::Envoy.Api.V2.Auth.UpstreamTlsContext();
            }
            input.ReadMessage(TlsContext);
            break;
          }
          case 106: {
            if (httpProtocolOptions_ == null) {
              HttpProtocolOptions = new global::Envoy.Api.V2.Core.Http1ProtocolOptions();
            }
            input.ReadMessage(HttpProtocolOptions);
            break;
          }
          case 114: {
            if (http2ProtocolOptions_ == null) {
              Http2ProtocolOptions = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
            }
            input.ReadMessage(Http2ProtocolOptions);
            break;
          }
          case 130: {
            if (dnsRefreshRate_ == null) {
              DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DnsRefreshRate);
            break;
          }
          case 136: {
            DnsLookupFamily = (global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily) input.ReadEnum();
            break;
          }
          case 146: {
            dnsResolvers_.AddEntriesFrom(ref input, _repeated_dnsResolvers_codec);
            break;
          }
          case 154: {
            if (outlierDetection_ == null) {
              OutlierDetection = new global::Envoy.Api.V2.ClusterNS.OutlierDetection();
            }
            input.ReadMessage(OutlierDetection);
            break;
          }
          case 162: {
            if (cleanupInterval_ == null) {
              CleanupInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(CleanupInterval);
            break;
          }
          case 170: {
            if (upstreamBindConfig_ == null) {
              UpstreamBindConfig = new global::Envoy.Api.V2.Core.BindConfig();
            }
            input.ReadMessage(UpstreamBindConfig);
            break;
          }
          case 178: {
            if (lbSubsetConfig_ == null) {
              LbSubsetConfig = new global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig();
            }
            input.ReadMessage(LbSubsetConfig);
            break;
          }
          case 186: {
            global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
              subBuilder.MergeFrom(RingHashLbConfig);
            }
            input.ReadMessage(subBuilder);
            RingHashLbConfig = subBuilder;
            break;
          }
          case 194: {
            if (transportSocket_ == null) {
              TransportSocket = new global::Envoy.Api.V2.Core.TransportSocket();
            }
            input.ReadMessage(TransportSocket);
            break;
          }
          case 202: {
            if (metadata_ == null) {
              Metadata = new global::Envoy.Api.V2.Core.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 208: {
            ProtocolSelection = (global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection) input.ReadEnum();
            break;
          }
          case 218: {
            if (commonLbConfig_ == null) {
              CommonLbConfig = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig();
            }
            input.ReadMessage(CommonLbConfig);
            break;
          }
          case 226: {
            AltStatName = input.ReadString();
            break;
          }
          case 234: {
            if (commonHttpProtocolOptions_ == null) {
              CommonHttpProtocolOptions = new global::Envoy.Api.V2.Core.HttpProtocolOptions();
            }
            input.ReadMessage(CommonHttpProtocolOptions);
            break;
          }
          case 242: {
            if (upstreamConnectionOptions_ == null) {
              UpstreamConnectionOptions = new global::Envoy.Api.V2.UpstreamConnectionOptions();
            }
            input.ReadMessage(UpstreamConnectionOptions);
            break;
          }
          case 248: {
            CloseConnectionsOnHostHealthFailure = input.ReadBool();
            break;
          }
          case 256: {
            DrainConnectionsOnHostRemoval = input.ReadBool();
            break;
          }
          case 266: {
            if (loadAssignment_ == null) {
              LoadAssignment = new global::Envoy.Api.V2.ClusterLoadAssignment();
            }
            input.ReadMessage(LoadAssignment);
            break;
          }
          case 274: {
            global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) {
              subBuilder.MergeFrom(OriginalDstLbConfig);
            }
            input.ReadMessage(subBuilder);
            OriginalDstLbConfig = subBuilder;
            break;
          }
          case 282: {
            extensionProtocolOptions_.AddEntriesFrom(ref input, _map_extensionProtocolOptions_codec);
            break;
          }
          case 290: {
            typedExtensionProtocolOptions_.AddEntriesFrom(ref input, _map_typedExtensionProtocolOptions_codec);
            break;
          }
          case 298: {
            global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) {
              subBuilder.MergeFrom(LeastRequestLbConfig);
            }
            input.ReadMessage(subBuilder);
            LeastRequestLbConfig = subBuilder;
            break;
          }
          case 306: {
            global::Envoy.Api.V2.Cluster.Types.CustomClusterType subBuilder = new global::Envoy.Api.V2.Cluster.Types.CustomClusterType();
            if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) {
              subBuilder.MergeFrom(ClusterType);
            }
            input.ReadMessage(subBuilder);
            ClusterType = subBuilder;
            break;
          }
          case 312: {
            RespectDnsTtl = input.ReadBool();
            break;
          }
          case 322: {
            filters_.AddEntriesFrom(ref input, _repeated_filters_codec);
            break;
          }
          case 330: {
            if (loadBalancingPolicy_ == null) {
              LoadBalancingPolicy = new global::Envoy.Api.V2.LoadBalancingPolicy();
            }
            input.ReadMessage(LoadBalancingPolicy);
            break;
          }
          case 338: {
            if (lrsServer_ == null) {
              LrsServer = new global::Envoy.Api.V2.Core.ConfigSource();
            }
            input.ReadMessage(LrsServer);
            break;
          }
          case 346: {
            transportSocketMatches_.AddEntriesFrom(ref input, _repeated_transportSocketMatches_codec);
            break;
          }
          case 354: {
            if (dnsFailureRefreshRate_ == null) {
              DnsFailureRefreshRate = new global::Envoy.Api.V2.Cluster.Types.RefreshRate();
            }
            input.ReadMessage(DnsFailureRefreshRate);
            break;
          }
          case 360: {
            UseTcpForDnsLookups = input.ReadBool();
            break;
          }
          case 370: {
            if (upstreamHttpProtocolOptions_ == null) {
              UpstreamHttpProtocolOptions = new global::Envoy.Api.V2.Core.UpstreamHttpProtocolOptions();
            }
            input.ReadMessage(UpstreamHttpProtocolOptions);
            break;
          }
          case 376: {
            TrackTimeoutBudgets = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Cluster message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Refer to :ref:`service discovery type &lt;arch_overview_service_discovery_types>`
      /// for an explanation on each type.
      /// </summary>
      public enum DiscoveryType {
        /// <summary>
        /// Refer to the :ref:`static discovery type&lt;arch_overview_service_discovery_types_static>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("STATIC")] Static = 0,
        /// <summary>
        /// Refer to the :ref:`strict DNS discovery
        /// type&lt;arch_overview_service_discovery_types_strict_dns>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("STRICT_DNS")] StrictDns = 1,
        /// <summary>
        /// Refer to the :ref:`logical DNS discovery
        /// type&lt;arch_overview_service_discovery_types_logical_dns>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("LOGICAL_DNS")] LogicalDns = 2,
        /// <summary>
        /// Refer to the :ref:`service discovery type&lt;arch_overview_service_discovery_types_eds>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("EDS")] Eds = 3,
        /// <summary>
        /// Refer to the :ref:`original destination discovery
        /// type&lt;arch_overview_service_discovery_types_original_destination>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("ORIGINAL_DST")] OriginalDst = 4,
      }

      /// <summary>
      /// Refer to :ref:`load balancer type &lt;arch_overview_load_balancing_types>` architecture
      /// overview section for information on each type.
      /// </summary>
      public enum LbPolicy {
        /// <summary>
        /// Refer to the :ref:`round robin load balancing
        /// policy&lt;arch_overview_load_balancing_types_round_robin>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("ROUND_ROBIN")] RoundRobin = 0,
        /// <summary>
        /// Refer to the :ref:`least request load balancing
        /// policy&lt;arch_overview_load_balancing_types_least_request>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("LEAST_REQUEST")] LeastRequest = 1,
        /// <summary>
        /// Refer to the :ref:`ring hash load balancing
        /// policy&lt;arch_overview_load_balancing_types_ring_hash>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("RING_HASH")] RingHash = 2,
        /// <summary>
        /// Refer to the :ref:`random load balancing
        /// policy&lt;arch_overview_load_balancing_types_random>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("RANDOM")] Random = 3,
        /// <summary>
        /// Refer to the :ref:`original destination load balancing
        /// policy&lt;arch_overview_load_balancing_types_original_destination>`
        /// for an explanation.
        ///
        /// .. attention::
        ///
        ///   **This load balancing policy is deprecated**. Use CLUSTER_PROVIDED instead.
        ///
        /// </summary>
        [pbr::OriginalName("ORIGINAL_DST_LB")] OriginalDstLb = 4,
        /// <summary>
        /// Refer to the :ref:`Maglev load balancing policy&lt;arch_overview_load_balancing_types_maglev>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("MAGLEV")] Maglev = 5,
        /// <summary>
        /// This load balancer type must be specified if the configured cluster provides a cluster
        /// specific load balancer. Consult the configured cluster's documentation for whether to set
        /// this option or not.
        /// </summary>
        [pbr::OriginalName("CLUSTER_PROVIDED")] ClusterProvided = 6,
        /// <summary>
        /// [#not-implemented-hide:] Use the new :ref:`load_balancing_policy
        /// &lt;envoy_api_field_Cluster.load_balancing_policy>` field to determine the LB policy.
        /// [#next-major-version: In the v3 API, we should consider deprecating the lb_policy field
        /// and instead using the new load_balancing_policy field as the one and only mechanism for
        /// configuring this.]
        /// </summary>
        [pbr::OriginalName("LOAD_BALANCING_POLICY_CONFIG")] LoadBalancingPolicyConfig = 7,
      }

      /// <summary>
      /// When V4_ONLY is selected, the DNS resolver will only perform a lookup for
      /// addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
      /// only perform a lookup for addresses in the IPv6 family. If AUTO is
      /// specified, the DNS resolver will first perform a lookup for addresses in
      /// the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
      /// For cluster types other than
      /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>` and
      /// :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
      /// this setting is
      /// ignored.
      /// </summary>
      public enum DnsLookupFamily {
        [pbr::OriginalName("AUTO")] Auto = 0,
        [pbr::OriginalName("V4_ONLY")] V4Only = 1,
        [pbr::OriginalName("V6_ONLY")] V6Only = 2,
      }

      public enum ClusterProtocolSelection {
        /// <summary>
        /// Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
        /// If :ref:`http2_protocol_options &lt;envoy_api_field_Cluster.http2_protocol_options>` are
        /// present, HTTP2 will be used, otherwise HTTP1.1 will be used.
        /// </summary>
        [pbr::OriginalName("USE_CONFIGURED_PROTOCOL")] UseConfiguredProtocol = 0,
        /// <summary>
        /// Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
        /// </summary>
        [pbr::OriginalName("USE_DOWNSTREAM_PROTOCOL")] UseDownstreamProtocol = 1,
      }

      /// <summary>
      /// TransportSocketMatch specifies what transport socket config will be used
      /// when the match conditions are satisfied.
      /// </summary>
      public sealed partial class TransportSocketMatch : pb::IMessage<TransportSocketMatch>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<TransportSocketMatch> _parser = new pb::MessageParser<TransportSocketMatch>(() => new TransportSocketMatch());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<TransportSocketMatch> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TransportSocketMatch() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TransportSocketMatch(TransportSocketMatch other) : this() {
          name_ = other.name_;
          match_ = other.match_ != null ? other.match_.Clone() : null;
          transportSocket_ = other.transportSocket_ != null ? other.transportSocket_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TransportSocketMatch Clone() {
          return new TransportSocketMatch(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// The name of the match, used in stats generation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "match" field.</summary>
        public const int MatchFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Struct match_;
        /// <summary>
        /// Optional endpoint metadata match criteria.
        /// The connection to the endpoint with metadata matching what is set in this field
        /// will use the transport socket configuration specified here.
        /// The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
        /// against the values specified in this field.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Struct Match {
          get { return match_; }
          set {
            match_ = value;
          }
        }

        /// <summary>Field number for the "transport_socket" field.</summary>
        public const int TransportSocketFieldNumber = 3;
        private global::Envoy.Api.V2.Core.TransportSocket transportSocket_;
        /// <summary>
        /// The configuration of the transport socket.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Api.V2.Core.TransportSocket TransportSocket {
          get { return transportSocket_; }
          set {
            transportSocket_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as TransportSocketMatch);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(TransportSocketMatch other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(Match, other.Match)) return false;
          if (!object.Equals(TransportSocket, other.TransportSocket)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (match_ != null) hash ^= Match.GetHashCode();
          if (transportSocket_ != null) hash ^= TransportSocket.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (match_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Match);
          }
          if (transportSocket_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(TransportSocket);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (match_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Match);
          }
          if (transportSocket_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(TransportSocket);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (match_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Match);
          }
          if (transportSocket_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TransportSocket);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(TransportSocketMatch other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.match_ != null) {
            if (match_ == null) {
              Match = new global::Google.Protobuf.WellKnownTypes.Struct();
            }
            Match.MergeFrom(other.Match);
          }
          if (other.transportSocket_ != null) {
            if (transportSocket_ == null) {
              TransportSocket = new global::Envoy.Api.V2.Core.TransportSocket();
            }
            TransportSocket.MergeFrom(other.TransportSocket);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                if (match_ == null) {
                  Match = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(Match);
                break;
              }
              case 26: {
                if (transportSocket_ == null) {
                  TransportSocket = new global::Envoy.Api.V2.Core.TransportSocket();
                }
                input.ReadMessage(TransportSocket);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                if (match_ == null) {
                  Match = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(Match);
                break;
              }
              case 26: {
                if (transportSocket_ == null) {
                  TransportSocket = new global::Envoy.Api.V2.Core.TransportSocket();
                }
                input.ReadMessage(TransportSocket);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Extended cluster type.
      /// </summary>
      public sealed partial class CustomClusterType : pb::IMessage<CustomClusterType>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<CustomClusterType> _parser = new pb::MessageParser<CustomClusterType>(() => new CustomClusterType());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<CustomClusterType> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CustomClusterType() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CustomClusterType(CustomClusterType other) : this() {
          name_ = other.name_;
          typedConfig_ = other.typedConfig_ != null ? other.typedConfig_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CustomClusterType Clone() {
          return new CustomClusterType(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// The type of the cluster to instantiate. The name must match a supported cluster type.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "typed_config" field.</summary>
        public const int TypedConfigFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Any typedConfig_;
        /// <summary>
        /// Cluster specific configuration which depends on the cluster being instantiated.
        /// See the supported cluster for further documentation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Any TypedConfig {
          get { return typedConfig_; }
          set {
            typedConfig_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as CustomClusterType);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(CustomClusterType other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (typedConfig_ != null) hash ^= TypedConfig.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (typedConfig_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (typedConfig_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (typedConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(CustomClusterType other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.typedConfig_ != null) {
            if (typedConfig_ == null) {
              TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            TypedConfig.MergeFrom(other.TypedConfig);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                if (typedConfig_ == null) {
                  TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
                }
                input.ReadMessage(TypedConfig);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                if (typedConfig_ == null) {
                  TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
                }
                input.ReadMessage(TypedConfig);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Only valid when discovery type is EDS.
      /// </summary>
      public sealed partial class EdsClusterConfig : pb::IMessage<EdsClusterConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<EdsClusterConfig> _parser = new pb::MessageParser<EdsClusterConfig>(() => new EdsClusterConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<EdsClusterConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EdsClusterConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EdsClusterConfig(EdsClusterConfig other) : this() {
          edsConfig_ = other.edsConfig_ != null ? other.edsConfig_.Clone() : null;
          serviceName_ = other.serviceName_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EdsClusterConfig Clone() {
          return new EdsClusterConfig(this);
        }

        /// <summary>Field number for the "eds_config" field.</summary>
        public const int EdsConfigFieldNumber = 1;
        private global::Envoy.Api.V2.Core.ConfigSource edsConfig_;
        /// <summary>
        /// Configuration for the source of EDS updates for this Cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Api.V2.Core.ConfigSource EdsConfig {
          get { return edsConfig_; }
          set {
            edsConfig_ = value;
          }
        }

        /// <summary>Field number for the "service_name" field.</summary>
        public const int ServiceNameFieldNumber = 2;
        private string serviceName_ = "";
        /// <summary>
        /// Optional alternative to cluster name to present to EDS. This does not
        /// have the same restrictions as cluster name, i.e. it may be arbitrary
        /// length.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string ServiceName {
          get { return serviceName_; }
          set {
            serviceName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as EdsClusterConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(EdsClusterConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(EdsConfig, other.EdsConfig)) return false;
          if (ServiceName != other.ServiceName) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (edsConfig_ != null) hash ^= EdsConfig.GetHashCode();
          if (ServiceName.Length != 0) hash ^= ServiceName.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (edsConfig_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(EdsConfig);
          }
          if (ServiceName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(ServiceName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (edsConfig_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(EdsConfig);
          }
          if (ServiceName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(ServiceName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (edsConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(EdsConfig);
          }
          if (ServiceName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(ServiceName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(EdsClusterConfig other) {
          if (other == null) {
            return;
          }
          if (other.edsConfig_ != null) {
            if (edsConfig_ == null) {
              EdsConfig = new global::Envoy.Api.V2.Core.ConfigSource();
            }
            EdsConfig.MergeFrom(other.EdsConfig);
          }
          if (other.ServiceName.Length != 0) {
            ServiceName = other.ServiceName;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (edsConfig_ == null) {
                  EdsConfig = new global::Envoy.Api.V2.Core.ConfigSource();
                }
                input.ReadMessage(EdsConfig);
                break;
              }
              case 18: {
                ServiceName = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (edsConfig_ == null) {
                  EdsConfig = new global::Envoy.Api.V2.Core.ConfigSource();
                }
                input.ReadMessage(EdsConfig);
                break;
              }
              case 18: {
                ServiceName = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Optionally divide the endpoints in this cluster into subsets defined by
      /// endpoint metadata and selected by route and weighted cluster metadata.
      /// [#next-free-field: 8]
      /// </summary>
      public sealed partial class LbSubsetConfig : pb::IMessage<LbSubsetConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LbSubsetConfig> _parser = new pb::MessageParser<LbSubsetConfig>(() => new LbSubsetConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LbSubsetConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LbSubsetConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LbSubsetConfig(LbSubsetConfig other) : this() {
          fallbackPolicy_ = other.fallbackPolicy_;
          defaultSubset_ = other.defaultSubset_ != null ? other.defaultSubset_.Clone() : null;
          subsetSelectors_ = other.subsetSelectors_.Clone();
          localityWeightAware_ = other.localityWeightAware_;
          scaleLocalityWeight_ = other.scaleLocalityWeight_;
          panicModeAny_ = other.panicModeAny_;
          listAsAny_ = other.listAsAny_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LbSubsetConfig Clone() {
          return new LbSubsetConfig(this);
        }

        /// <summary>Field number for the "fallback_policy" field.</summary>
        public const int FallbackPolicyFieldNumber = 1;
        private global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy fallbackPolicy_ = global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback;
        /// <summary>
        /// The behavior used when no endpoint subset matches the selected route's
        /// metadata. The value defaults to
        /// :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy FallbackPolicy {
          get { return fallbackPolicy_; }
          set {
            fallbackPolicy_ = value;
          }
        }

        /// <summary>Field number for the "default_subset" field.</summary>
        public const int DefaultSubsetFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Struct defaultSubset_;
        /// <summary>
        /// Specifies the default subset of endpoints used during fallback if
        /// fallback_policy is
        /// :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
        /// Each field in default_subset is
        /// compared to the matching LbEndpoint.Metadata under the *envoy.lb*
        /// namespace. It is valid for no hosts to match, in which case the behavior
        /// is the same as a fallback_policy of
        /// :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Struct DefaultSubset {
          get { return defaultSubset_; }
          set {
            defaultSubset_ = value;
          }
        }

        /// <summary>Field number for the "subset_selectors" field.</summary>
        public const int SubsetSelectorsFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> _repeated_subsetSelectors_codec
            = pb::FieldCodec.ForMessage(26, global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> subsetSelectors_ = new pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector>();
        /// <summary>
        /// For each entry, LbEndpoint.Metadata's
        /// *envoy.lb* namespace is traversed and a subset is created for each unique
        /// combination of key and value. For example:
        ///
        /// .. code-block:: json
        ///
        ///   { "subset_selectors": [
        ///       { "keys": [ "version" ] },
        ///       { "keys": [ "stage", "hardware_type" ] }
        ///   ]}
        ///
        /// A subset is matched when the metadata from the selected route and
        /// weighted cluster contains the same keys and values as the subset's
        /// metadata. The same host may appear in multiple subsets.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> SubsetSelectors {
          get { return subsetSelectors_; }
        }

        /// <summary>Field number for the "locality_weight_aware" field.</summary>
        public const int LocalityWeightAwareFieldNumber = 4;
        private bool localityWeightAware_;
        /// <summary>
        /// If true, routing to subsets will take into account the localities and locality weights of the
        /// endpoints when making the routing decision.
        ///
        /// There are some potential pitfalls associated with enabling this feature, as the resulting
        /// traffic split after applying both a subset match and locality weights might be undesirable.
        ///
        /// Consider for example a situation in which you have 50/50 split across two localities X/Y
        /// which have 100 hosts each without subsetting. If the subset LB results in X having only 1
        /// host selected but Y having 100, then a lot more load is being dumped on the single host in X
        /// than originally anticipated in the load balancing assignment delivered via EDS.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool LocalityWeightAware {
          get { return localityWeightAware_; }
          set {
            localityWeightAware_ = value;
          }
        }

        /// <summary>Field number for the "scale_locality_weight" field.</summary>
        public const int ScaleLocalityWeightFieldNumber = 5;
        private bool scaleLocalityWeight_;
        /// <summary>
        /// When used with locality_weight_aware, scales the weight of each locality by the ratio
        /// of hosts in the subset vs hosts in the original subset. This aims to even out the load
        /// going to an individual locality if said locality is disproportionately affected by the
        /// subset predicate.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool ScaleLocalityWeight {
          get { return scaleLocalityWeight_; }
          set {
            scaleLocalityWeight_ = value;
          }
        }

        /// <summary>Field number for the "panic_mode_any" field.</summary>
        public const int PanicModeAnyFieldNumber = 6;
        private bool panicModeAny_;
        /// <summary>
        /// If true, when a fallback policy is configured and its corresponding subset fails to find
        /// a host this will cause any host to be selected instead.
        ///
        /// This is useful when using the default subset as the fallback policy, given the default
        /// subset might become empty. With this option enabled, if that happens the LB will attempt
        /// to select a host from the entire cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool PanicModeAny {
          get { return panicModeAny_; }
          set {
            panicModeAny_ = value;
          }
        }

        /// <summary>Field number for the "list_as_any" field.</summary>
        public const int ListAsAnyFieldNumber = 7;
        private bool listAsAny_;
        /// <summary>
        /// If true, metadata specified for a metadata key will be matched against the corresponding
        /// endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
        /// and any of the elements in the list matches the criteria.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool ListAsAny {
          get { return listAsAny_; }
          set {
            listAsAny_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LbSubsetConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LbSubsetConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (FallbackPolicy != other.FallbackPolicy) return false;
          if (!object.Equals(DefaultSubset, other.DefaultSubset)) return false;
          if(!subsetSelectors_.Equals(other.subsetSelectors_)) return false;
          if (LocalityWeightAware != other.LocalityWeightAware) return false;
          if (ScaleLocalityWeight != other.ScaleLocalityWeight) return false;
          if (PanicModeAny != other.PanicModeAny) return false;
          if (ListAsAny != other.ListAsAny) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback) hash ^= FallbackPolicy.GetHashCode();
          if (defaultSubset_ != null) hash ^= DefaultSubset.GetHashCode();
          hash ^= subsetSelectors_.GetHashCode();
          if (LocalityWeightAware != false) hash ^= LocalityWeightAware.GetHashCode();
          if (ScaleLocalityWeight != false) hash ^= ScaleLocalityWeight.GetHashCode();
          if (PanicModeAny != false) hash ^= PanicModeAny.GetHashCode();
          if (ListAsAny != false) hash ^= ListAsAny.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback) {
            output.WriteRawTag(8);
            output.WriteEnum((int) FallbackPolicy);
          }
          if (defaultSubset_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(DefaultSubset);
          }
          subsetSelectors_.WriteTo(output, _repeated_subsetSelectors_codec);
          if (LocalityWeightAware != false) {
            output.WriteRawTag(32);
            output.WriteBool(LocalityWeightAware);
          }
          if (ScaleLocalityWeight != false) {
            output.WriteRawTag(40);
            output.WriteBool(ScaleLocalityWeight);
          }
          if (PanicModeAny != false) {
            output.WriteRawTag(48);
            output.WriteBool(PanicModeAny);
          }
          if (ListAsAny != false) {
            output.WriteRawTag(56);
            output.WriteBool(ListAsAny);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback) {
            output.WriteRawTag(8);
            output.WriteEnum((int) FallbackPolicy);
          }
          if (defaultSubset_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(DefaultSubset);
          }
          subsetSelectors_.WriteTo(ref output, _repeated_subsetSelectors_codec);
          if (LocalityWeightAware != false) {
            output.WriteRawTag(32);
            output.WriteBool(LocalityWeightAware);
          }
          if (ScaleLocalityWeight != false) {
            output.WriteRawTag(40);
            output.WriteBool(ScaleLocalityWeight);
          }
          if (PanicModeAny != false) {
            output.WriteRawTag(48);
            output.WriteBool(PanicModeAny);
          }
          if (ListAsAny != false) {
            output.WriteRawTag(56);
            output.WriteBool(ListAsAny);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FallbackPolicy);
          }
          if (defaultSubset_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefaultSubset);
          }
          size += subsetSelectors_.CalculateSize(_repeated_subsetSelectors_codec);
          if (LocalityWeightAware != false) {
            size += 1 + 1;
          }
          if (ScaleLocalityWeight != false) {
            size += 1 + 1;
          }
          if (PanicModeAny != false) {
            size += 1 + 1;
          }
          if (ListAsAny != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LbSubsetConfig other) {
          if (other == null) {
            return;
          }
          if (other.FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback) {
            FallbackPolicy = other.FallbackPolicy;
          }
          if (other.defaultSubset_ != null) {
            if (defaultSubset_ == null) {
              DefaultSubset = new global::Google.Protobuf.WellKnownTypes.Struct();
            }
            DefaultSubset.MergeFrom(other.DefaultSubset);
          }
          subsetSelectors_.Add(other.subsetSelectors_);
          if (other.LocalityWeightAware != false) {
            LocalityWeightAware = other.LocalityWeightAware;
          }
          if (other.ScaleLocalityWeight != false) {
            ScaleLocalityWeight = other.ScaleLocalityWeight;
          }
          if (other.PanicModeAny != false) {
            PanicModeAny = other.PanicModeAny;
          }
          if (other.ListAsAny != false) {
            ListAsAny = other.ListAsAny;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                FallbackPolicy = (global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy) input.ReadEnum();
                break;
              }
              case 18: {
                if (defaultSubset_ == null) {
                  DefaultSubset = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(DefaultSubset);
                break;
              }
              case 26: {
                subsetSelectors_.AddEntriesFrom(input, _repeated_subsetSelectors_codec);
                break;
              }
              case 32: {
                LocalityWeightAware = input.ReadBool();
                break;
              }
              case 40: {
                ScaleLocalityWeight = input.ReadBool();
                break;
              }
              case 48: {
                PanicModeAny = input.ReadBool();
                break;
              }
              case 56: {
                ListAsAny = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                FallbackPolicy = (global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy) input.ReadEnum();
                break;
              }
              case 18: {
                if (defaultSubset_ == null) {
                  DefaultSubset = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(DefaultSubset);
                break;
              }
              case 26: {
                subsetSelectors_.AddEntriesFrom(ref input, _repeated_subsetSelectors_codec);
                break;
              }
              case 32: {
                LocalityWeightAware = input.ReadBool();
                break;
              }
              case 40: {
                ScaleLocalityWeight = input.ReadBool();
                break;
              }
              case 48: {
                PanicModeAny = input.ReadBool();
                break;
              }
              case 56: {
                ListAsAny = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the LbSubsetConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// If NO_FALLBACK is selected, a result
          /// equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
          /// any cluster endpoint may be returned (subject to policy, health checks,
          /// etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
          /// endpoints matching the values from the default_subset field.
          /// </summary>
          public enum LbSubsetFallbackPolicy {
            [pbr::OriginalName("NO_FALLBACK")] NoFallback = 0,
            [pbr::OriginalName("ANY_ENDPOINT")] AnyEndpoint = 1,
            [pbr::OriginalName("DEFAULT_SUBSET")] DefaultSubset = 2,
          }

          /// <summary>
          /// Specifications for subsets.
          /// </summary>
          public sealed partial class LbSubsetSelector : pb::IMessage<LbSubsetSelector>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<LbSubsetSelector> _parser = new pb::MessageParser<LbSubsetSelector>(() => new LbSubsetSelector());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<LbSubsetSelector> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public LbSubsetSelector() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public LbSubsetSelector(LbSubsetSelector other) : this() {
              keys_ = other.keys_.Clone();
              fallbackPolicy_ = other.fallbackPolicy_;
              fallbackKeysSubset_ = other.fallbackKeysSubset_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public LbSubsetSelector Clone() {
              return new LbSubsetSelector(this);
            }

            /// <summary>Field number for the "keys" field.</summary>
            public const int KeysFieldNumber = 1;
            private static readonly pb::FieldCodec<string> _repeated_keys_codec
                = pb::FieldCodec.ForString(10);
            private readonly pbc::RepeatedField<string> keys_ = new pbc::RepeatedField<string>();
            /// <summary>
            /// List of keys to match with the weighted cluster metadata.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pbc::RepeatedField<string> Keys {
              get { return keys_; }
            }

            /// <summary>Field number for the "fallback_policy" field.</summary>
            public const int FallbackPolicyFieldNumber = 2;
            private global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy fallbackPolicy_ = global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined;
            /// <summary>
            /// The behavior used when no endpoint subset matches the selected route's
            /// metadata.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy FallbackPolicy {
              get { return fallbackPolicy_; }
              set {
                fallbackPolicy_ = value;
              }
            }

            /// <summary>Field number for the "fallback_keys_subset" field.</summary>
            public const int FallbackKeysSubsetFieldNumber = 3;
            private static readonly pb::FieldCodec<string> _repeated_fallbackKeysSubset_codec
                = pb::FieldCodec.ForString(26);
            private readonly pbc::RepeatedField<string> fallbackKeysSubset_ = new pbc::RepeatedField<string>();
            /// <summary>
            /// Subset of
            /// :ref:`keys&lt;envoy_api_field_Cluster.LbSubsetConfig.LbSubsetSelector.keys>` used by
            /// :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
            /// fallback policy.
            /// It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
            /// For any other fallback policy the parameter is not used and should not be set.
            /// Only values also present in
            /// :ref:`keys&lt;envoy_api_field_Cluster.LbSubsetConfig.LbSubsetSelector.keys>` are allowed, but
            /// `fallback_keys_subset` cannot be equal to `keys`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pbc::RepeatedField<string> FallbackKeysSubset {
              get { return fallbackKeysSubset_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as LbSubsetSelector);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(LbSubsetSelector other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!keys_.Equals(other.keys_)) return false;
              if (FallbackPolicy != other.FallbackPolicy) return false;
              if(!fallbackKeysSubset_.Equals(other.fallbackKeysSubset_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= keys_.GetHashCode();
              if (FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined) hash ^= FallbackPolicy.GetHashCode();
              hash ^= fallbackKeysSubset_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              keys_.WriteTo(output, _repeated_keys_codec);
              if (FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined) {
                output.WriteRawTag(16);
                output.WriteEnum((int) FallbackPolicy);
              }
              fallbackKeysSubset_.WriteTo(output, _repeated_fallbackKeysSubset_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              keys_.WriteTo(ref output, _repeated_keys_codec);
              if (FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined) {
                output.WriteRawTag(16);
                output.WriteEnum((int) FallbackPolicy);
              }
              fallbackKeysSubset_.WriteTo(ref output, _repeated_fallbackKeysSubset_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              size += keys_.CalculateSize(_repeated_keys_codec);
              if (FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FallbackPolicy);
              }
              size += fallbackKeysSubset_.CalculateSize(_repeated_fallbackKeysSubset_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(LbSubsetSelector other) {
              if (other == null) {
                return;
              }
              keys_.Add(other.keys_);
              if (other.FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined) {
                FallbackPolicy = other.FallbackPolicy;
              }
              fallbackKeysSubset_.Add(other.fallbackKeysSubset_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    keys_.AddEntriesFrom(input, _repeated_keys_codec);
                    break;
                  }
                  case 16: {
                    FallbackPolicy = (global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy) input.ReadEnum();
                    break;
                  }
                  case 26: {
                    fallbackKeysSubset_.AddEntriesFrom(input, _repeated_fallbackKeysSubset_codec);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    keys_.AddEntriesFrom(ref input, _repeated_keys_codec);
                    break;
                  }
                  case 16: {
                    FallbackPolicy = (global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy) input.ReadEnum();
                    break;
                  }
                  case 26: {
                    fallbackKeysSubset_.AddEntriesFrom(ref input, _repeated_fallbackKeysSubset_codec);
                    break;
                  }
                }
              }
            }
            #endif

            #region Nested types
            /// <summary>Container for nested types declared in the LbSubsetSelector message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static partial class Types {
              /// <summary>
              /// Allows to override top level fallback policy per selector.
              /// </summary>
              public enum LbSubsetSelectorFallbackPolicy {
                /// <summary>
                /// If NOT_DEFINED top level config fallback policy is used instead.
                /// </summary>
                [pbr::OriginalName("NOT_DEFINED")] NotDefined = 0,
                /// <summary>
                /// If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
                /// </summary>
                [pbr::OriginalName("NO_FALLBACK")] NoFallback = 1,
                /// <summary>
                /// If ANY_ENDPOINT is selected, any cluster endpoint may be returned
                /// (subject to policy, health checks, etc).
                /// </summary>
                [pbr::OriginalName("ANY_ENDPOINT")] AnyEndpoint = 2,
                /// <summary>
                /// If DEFAULT_SUBSET is selected, load balancing is performed over the
                /// endpoints matching the values from the default_subset field.
                /// </summary>
                [pbr::OriginalName("DEFAULT_SUBSET")] DefaultSubset = 3,
                /// <summary>
                /// If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
                /// keys reduced to
                /// :ref:`fallback_keys_subset&lt;envoy_api_field_Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset>`.
                /// It allows for a fallback to a different, less specific selector if some of the keys of
                /// the selector are considered optional.
                /// </summary>
                [pbr::OriginalName("KEYS_SUBSET")] KeysSubset = 4,
              }

            }
            #endregion

          }

        }
        #endregion

      }

      /// <summary>
      /// Specific configuration for the LeastRequest load balancing policy.
      /// </summary>
      public sealed partial class LeastRequestLbConfig : pb::IMessage<LeastRequestLbConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LeastRequestLbConfig> _parser = new pb::MessageParser<LeastRequestLbConfig>(() => new LeastRequestLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LeastRequestLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LeastRequestLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LeastRequestLbConfig(LeastRequestLbConfig other) : this() {
          ChoiceCount = other.ChoiceCount;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LeastRequestLbConfig Clone() {
          return new LeastRequestLbConfig(this);
        }

        /// <summary>Field number for the "choice_count" field.</summary>
        public const int ChoiceCountFieldNumber = 1;
        private static readonly pb::FieldCodec<uint?> _single_choiceCount_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
        private uint? choiceCount_;
        /// <summary>
        /// The number of random healthy hosts from which the host with the fewest active requests will
        /// be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint? ChoiceCount {
          get { return choiceCount_; }
          set {
            choiceCount_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LeastRequestLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LeastRequestLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ChoiceCount != other.ChoiceCount) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (choiceCount_ != null) hash ^= ChoiceCount.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (choiceCount_ != null) {
            _single_choiceCount_codec.WriteTagAndValue(output, ChoiceCount);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (choiceCount_ != null) {
            _single_choiceCount_codec.WriteTagAndValue(ref output, ChoiceCount);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (choiceCount_ != null) {
            size += _single_choiceCount_codec.CalculateSizeWithTag(ChoiceCount);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LeastRequestLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.choiceCount_ != null) {
            if (choiceCount_ == null || other.ChoiceCount != 0) {
              ChoiceCount = other.ChoiceCount;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                uint? value = _single_choiceCount_codec.Read(input);
                if (choiceCount_ == null || value != 0) {
                  ChoiceCount = value;
                }
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                uint? value = _single_choiceCount_codec.Read(ref input);
                if (choiceCount_ == null || value != 0) {
                  ChoiceCount = value;
                }
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Specific configuration for the :ref:`RingHash&lt;arch_overview_load_balancing_types_ring_hash>`
      /// load balancing policy.
      /// </summary>
      public sealed partial class RingHashLbConfig : pb::IMessage<RingHashLbConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RingHashLbConfig> _parser = new pb::MessageParser<RingHashLbConfig>(() => new RingHashLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<RingHashLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[5]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RingHashLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RingHashLbConfig(RingHashLbConfig other) : this() {
          MinimumRingSize = other.MinimumRingSize;
          hashFunction_ = other.hashFunction_;
          MaximumRingSize = other.MaximumRingSize;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RingHashLbConfig Clone() {
          return new RingHashLbConfig(this);
        }

        /// <summary>Field number for the "minimum_ring_size" field.</summary>
        public const int MinimumRingSizeFieldNumber = 1;
        private static readonly pb::FieldCodec<ulong?> _single_minimumRingSize_codec = pb::FieldCodec.ForStructWrapper<ulong>(10);
        private ulong? minimumRingSize_;
        /// <summary>
        /// Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
        /// provided host) the better the request distribution will reflect the desired weights. Defaults
        /// to 1024 entries, and limited to 8M entries. See also
        /// :ref:`maximum_ring_size&lt;envoy_api_field_Cluster.RingHashLbConfig.maximum_ring_size>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ulong? MinimumRingSize {
          get { return minimumRingSize_; }
          set {
            minimumRingSize_ = value;
          }
        }


        /// <summary>Field number for the "hash_function" field.</summary>
        public const int HashFunctionFieldNumber = 3;
        private global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction hashFunction_ = global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash;
        /// <summary>
        /// The hash function used to hash hosts onto the ketama ring. The value defaults to
        /// :ref:`XX_HASH&lt;envoy_api_enum_value_Cluster.RingHashLbConfig.HashFunction.XX_HASH>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction HashFunction {
          get { return hashFunction_; }
          set {
            hashFunction_ = value;
          }
        }

        /// <summary>Field number for the "maximum_ring_size" field.</summary>
        public const int MaximumRingSizeFieldNumber = 4;
        private static readonly pb::FieldCodec<ulong?> _single_maximumRingSize_codec = pb::FieldCodec.ForStructWrapper<ulong>(34);
        private ulong? maximumRingSize_;
        /// <summary>
        /// Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
        /// to further constrain resource use. See also
        /// :ref:`minimum_ring_size&lt;envoy_api_field_Cluster.RingHashLbConfig.minimum_ring_size>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ulong? MaximumRingSize {
          get { return maximumRingSize_; }
          set {
            maximumRingSize_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as RingHashLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(RingHashLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MinimumRingSize != other.MinimumRingSize) return false;
          if (HashFunction != other.HashFunction) return false;
          if (MaximumRingSize != other.MaximumRingSize) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (minimumRingSize_ != null) hash ^= MinimumRingSize.GetHashCode();
          if (HashFunction != global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash) hash ^= HashFunction.GetHashCode();
          if (maximumRingSize_ != null) hash ^= MaximumRingSize.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (minimumRingSize_ != null) {
            _single_minimumRingSize_codec.WriteTagAndValue(output, MinimumRingSize);
          }
          if (HashFunction != global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash) {
            output.WriteRawTag(24);
            output.WriteEnum((int) HashFunction);
          }
          if (maximumRingSize_ != null) {
            _single_maximumRingSize_codec.WriteTagAndValue(output, MaximumRingSize);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (minimumRingSize_ != null) {
            _single_minimumRingSize_codec.WriteTagAndValue(ref output, MinimumRingSize);
          }
          if (HashFunction != global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash) {
            output.WriteRawTag(24);
            output.WriteEnum((int) HashFunction);
          }
          if (maximumRingSize_ != null) {
            _single_maximumRingSize_codec.WriteTagAndValue(ref output, MaximumRingSize);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (minimumRingSize_ != null) {
            size += _single_minimumRingSize_codec.CalculateSizeWithTag(MinimumRingSize);
          }
          if (HashFunction != global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) HashFunction);
          }
          if (maximumRingSize_ != null) {
            size += _single_maximumRingSize_codec.CalculateSizeWithTag(MaximumRingSize);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(RingHashLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.minimumRingSize_ != null) {
            if (minimumRingSize_ == null || other.MinimumRingSize != 0UL) {
              MinimumRingSize = other.MinimumRingSize;
            }
          }
          if (other.HashFunction != global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash) {
            HashFunction = other.HashFunction;
          }
          if (other.maximumRingSize_ != null) {
            if (maximumRingSize_ == null || other.MaximumRingSize != 0UL) {
              MaximumRingSize = other.MaximumRingSize;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                ulong? value = _single_minimumRingSize_codec.Read(input);
                if (minimumRingSize_ == null || value != 0UL) {
                  MinimumRingSize = value;
                }
                break;
              }
              case 24: {
                HashFunction = (global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction) input.ReadEnum();
                break;
              }
              case 34: {
                ulong? value = _single_maximumRingSize_codec.Read(input);
                if (maximumRingSize_ == null || value != 0UL) {
                  MaximumRingSize = value;
                }
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                ulong? value = _single_minimumRingSize_codec.Read(ref input);
                if (minimumRingSize_ == null || value != 0UL) {
                  MinimumRingSize = value;
                }
                break;
              }
              case 24: {
                HashFunction = (global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction) input.ReadEnum();
                break;
              }
              case 34: {
                ulong? value = _single_maximumRingSize_codec.Read(ref input);
                if (maximumRingSize_ == null || value != 0UL) {
                  MaximumRingSize = value;
                }
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the RingHashLbConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// The hash function used to hash hosts onto the ketama ring.
          /// </summary>
          public enum HashFunction {
            /// <summary>
            /// Use `xxHash &lt;https://github.com/Cyan4973/xxHash>`_, this is the default hash function.
            /// </summary>
            [pbr::OriginalName("XX_HASH")] XxHash = 0,
            /// <summary>
            /// Use `MurmurHash2 &lt;https://sites.google.com/site/murmurhash/>`_, this is compatible with
            /// std:hash&lt;string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
            /// on Linux and not macOS.
            /// </summary>
            [pbr::OriginalName("MURMUR_HASH_2")] MurmurHash2 = 1,
          }

        }
        #endregion

      }

      /// <summary>
      /// Specific configuration for the
      /// :ref:`Original Destination &lt;arch_overview_load_balancing_types_original_destination>`
      /// load balancing policy.
      /// </summary>
      public sealed partial class OriginalDstLbConfig : pb::IMessage<OriginalDstLbConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<OriginalDstLbConfig> _parser = new pb::MessageParser<OriginalDstLbConfig>(() => new OriginalDstLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<OriginalDstLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[6]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OriginalDstLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OriginalDstLbConfig(OriginalDstLbConfig other) : this() {
          useHttpHeader_ = other.useHttpHeader_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OriginalDstLbConfig Clone() {
          return new OriginalDstLbConfig(this);
        }

        /// <summary>Field number for the "use_http_header" field.</summary>
        public const int UseHttpHeaderFieldNumber = 1;
        private bool useHttpHeader_;
        /// <summary>
        /// When true, :ref:`x-envoy-original-dst-host
        /// &lt;config_http_conn_man_headers_x-envoy-original-dst-host>` can be used to override destination
        /// address.
        ///
        /// .. attention::
        ///
        ///   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
        ///   route traffic to arbitrary hosts and/or ports, which may have serious security
        ///   consequences.
        ///
        /// .. note::
        ///
        ///   If the header appears multiple times only the first value is used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool UseHttpHeader {
          get { return useHttpHeader_; }
          set {
            useHttpHeader_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as OriginalDstLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(OriginalDstLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (UseHttpHeader != other.UseHttpHeader) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (UseHttpHeader != false) hash ^= UseHttpHeader.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (UseHttpHeader != false) {
            output.WriteRawTag(8);
            output.WriteBool(UseHttpHeader);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (UseHttpHeader != false) {
            output.WriteRawTag(8);
            output.WriteBool(UseHttpHeader);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (UseHttpHeader != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(OriginalDstLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.UseHttpHeader != false) {
            UseHttpHeader = other.UseHttpHeader;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                UseHttpHeader = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                UseHttpHeader = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Common configuration for all load balancer implementations.
      /// [#next-free-field: 8]
      /// </summary>
      public sealed partial class CommonLbConfig : pb::IMessage<CommonLbConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<CommonLbConfig> _parser = new pb::MessageParser<CommonLbConfig>(() => new CommonLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<CommonLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[7]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CommonLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CommonLbConfig(CommonLbConfig other) : this() {
          healthyPanicThreshold_ = other.healthyPanicThreshold_ != null ? other.healthyPanicThreshold_.Clone() : null;
          updateMergeWindow_ = other.updateMergeWindow_ != null ? other.updateMergeWindow_.Clone() : null;
          ignoreNewHostsUntilFirstHc_ = other.ignoreNewHostsUntilFirstHc_;
          closeConnectionsOnHostSetChange_ = other.closeConnectionsOnHostSetChange_;
          consistentHashingLbConfig_ = other.consistentHashingLbConfig_ != null ? other.consistentHashingLbConfig_.Clone() : null;
          switch (other.LocalityConfigSpecifierCase) {
            case LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig:
              ZoneAwareLbConfig = other.ZoneAwareLbConfig.Clone();
              break;
            case LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig:
              LocalityWeightedLbConfig = other.LocalityWeightedLbConfig.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CommonLbConfig Clone() {
          return new CommonLbConfig(this);
        }

        /// <summary>Field number for the "healthy_panic_threshold" field.</summary>
        public const int HealthyPanicThresholdFieldNumber = 1;
        private global::Envoy.Type.Percent healthyPanicThreshold_;
        /// <summary>
        /// Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold>`.
        /// If not specified, the default is 50%.
        /// To disable panic mode, set to 0%.
        ///
        /// .. note::
        ///   The specified percent will be truncated to the nearest 1%.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Type.Percent HealthyPanicThreshold {
          get { return healthyPanicThreshold_; }
          set {
            healthyPanicThreshold_ = value;
          }
        }

        /// <summary>Field number for the "zone_aware_lb_config" field.</summary>
        public const int ZoneAwareLbConfigFieldNumber = 2;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig ZoneAwareLbConfig {
          get { return localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig ? (global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig) localityConfigSpecifier_ : null; }
          set {
            localityConfigSpecifier_ = value;
            localityConfigSpecifierCase_ = value == null ? LocalityConfigSpecifierOneofCase.None : LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig;
          }
        }

        /// <summary>Field number for the "locality_weighted_lb_config" field.</summary>
        public const int LocalityWeightedLbConfigFieldNumber = 3;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig LocalityWeightedLbConfig {
          get { return localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig ? (global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig) localityConfigSpecifier_ : null; }
          set {
            localityConfigSpecifier_ = value;
            localityConfigSpecifierCase_ = value == null ? LocalityConfigSpecifierOneofCase.None : LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig;
          }
        }

        /// <summary>Field number for the "update_merge_window" field.</summary>
        public const int UpdateMergeWindowFieldNumber = 4;
        private global::Google.Protobuf.WellKnownTypes.Duration updateMergeWindow_;
        /// <summary>
        /// If set, all health check/weight/metadata updates that happen within this duration will be
        /// merged and delivered in one shot when the duration expires. The start of the duration is when
        /// the first update happens. This is useful for big clusters, with potentially noisy deploys
        /// that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
        /// or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
        /// cluster). Please always keep in mind that the use of sandbox technologies may change this
        /// behavior.
        ///
        /// If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
        /// window to 0.
        ///
        /// Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
        /// because merging those updates isn't currently safe. See
        /// https://github.com/envoyproxy/envoy/pull/3941.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration UpdateMergeWindow {
          get { return updateMergeWindow_; }
          set {
            updateMergeWindow_ = value;
          }
        }

        /// <summary>Field number for the "ignore_new_hosts_until_first_hc" field.</summary>
        public const int IgnoreNewHostsUntilFirstHcFieldNumber = 5;
        private bool ignoreNewHostsUntilFirstHc_;
        /// <summary>
        /// If set to true, Envoy will not consider new hosts when computing load balancing weights until
        /// they have been health checked for the first time. This will have no effect unless
        /// active health checking is also configured.
        ///
        /// Ignoring a host means that for any load balancing calculations that adjust weights based
        /// on the ratio of eligible hosts and total hosts (priority spillover, locality weighting and
        /// panic mode) Envoy will exclude these hosts in the denominator.
        ///
        /// For example, with hosts in two priorities P0 and P1, where P0 looks like
        /// {healthy, unhealthy (new), unhealthy (new)}
        /// and where P1 looks like
        /// {healthy, healthy}
        /// all traffic will still hit P0, as 1 / (3 - 2) = 1.
        ///
        /// Enabling this will allow scaling up the number of hosts for a given cluster without entering
        /// panic mode or triggering priority spillover, assuming the hosts pass the first health check.
        ///
        /// If panic mode is triggered, new hosts are still eligible for traffic; they simply do not
        /// contribute to the calculation when deciding whether panic mode is enabled or not.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool IgnoreNewHostsUntilFirstHc {
          get { return ignoreNewHostsUntilFirstHc_; }
          set {
            ignoreNewHostsUntilFirstHc_ = value;
          }
        }

        /// <summary>Field number for the "close_connections_on_host_set_change" field.</summary>
        public const int CloseConnectionsOnHostSetChangeFieldNumber = 6;
        private bool closeConnectionsOnHostSetChange_;
        /// <summary>
        /// If set to `true`, the cluster manager will drain all existing
        /// connections to upstream hosts whenever hosts are added or removed from the cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool CloseConnectionsOnHostSetChange {
          get { return closeConnectionsOnHostSetChange_; }
          set {
            closeConnectionsOnHostSetChange_ = value;
          }
        }

        /// <summary>Field number for the "consistent_hashing_lb_config" field.</summary>
        public const int ConsistentHashingLbConfigFieldNumber = 7;
        private global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ConsistentHashingLbConfig consistentHashingLbConfig_;
        /// <summary>
        /// Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ConsistentHashingLbConfig ConsistentHashingLbConfig {
          get { return consistentHashingLbConfig_; }
          set {
            consistentHashingLbConfig_ = value;
          }
        }

        private object localityConfigSpecifier_;
        /// <summary>Enum of possible cases for the "locality_config_specifier" oneof.</summary>
        public enum LocalityConfigSpecifierOneofCase {
          None = 0,
          ZoneAwareLbConfig = 2,
          LocalityWeightedLbConfig = 3,
        }
        private LocalityConfigSpecifierOneofCase localityConfigSpecifierCase_ = LocalityConfigSpecifierOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocalityConfigSpecifierOneofCase LocalityConfigSpecifierCase {
          get { return localityConfigSpecifierCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLocalityConfigSpecifier() {
          localityConfigSpecifierCase_ = LocalityConfigSpecifierOneofCase.None;
          localityConfigSpecifier_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as CommonLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(CommonLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(HealthyPanicThreshold, other.HealthyPanicThreshold)) return false;
          if (!object.Equals(ZoneAwareLbConfig, other.ZoneAwareLbConfig)) return false;
          if (!object.Equals(LocalityWeightedLbConfig, other.LocalityWeightedLbConfig)) return false;
          if (!object.Equals(UpdateMergeWindow, other.UpdateMergeWindow)) return false;
          if (IgnoreNewHostsUntilFirstHc != other.IgnoreNewHostsUntilFirstHc) return false;
          if (CloseConnectionsOnHostSetChange != other.CloseConnectionsOnHostSetChange) return false;
          if (!object.Equals(ConsistentHashingLbConfig, other.ConsistentHashingLbConfig)) return false;
          if (LocalityConfigSpecifierCase != other.LocalityConfigSpecifierCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (healthyPanicThreshold_ != null) hash ^= HealthyPanicThreshold.GetHashCode();
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) hash ^= ZoneAwareLbConfig.GetHashCode();
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) hash ^= LocalityWeightedLbConfig.GetHashCode();
          if (updateMergeWindow_ != null) hash ^= UpdateMergeWindow.GetHashCode();
          if (IgnoreNewHostsUntilFirstHc != false) hash ^= IgnoreNewHostsUntilFirstHc.GetHashCode();
          if (CloseConnectionsOnHostSetChange != false) hash ^= CloseConnectionsOnHostSetChange.GetHashCode();
          if (consistentHashingLbConfig_ != null) hash ^= ConsistentHashingLbConfig.GetHashCode();
          hash ^= (int) localityConfigSpecifierCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (healthyPanicThreshold_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(HealthyPanicThreshold);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
            output.WriteRawTag(18);
            output.WriteMessage(ZoneAwareLbConfig);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
            output.WriteRawTag(26);
            output.WriteMessage(LocalityWeightedLbConfig);
          }
          if (updateMergeWindow_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(UpdateMergeWindow);
          }
          if (IgnoreNewHostsUntilFirstHc != false) {
            output.WriteRawTag(40);
            output.WriteBool(IgnoreNewHostsUntilFirstHc);
          }
          if (CloseConnectionsOnHostSetChange != false) {
            output.WriteRawTag(48);
            output.WriteBool(CloseConnectionsOnHostSetChange);
          }
          if (consistentHashingLbConfig_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(ConsistentHashingLbConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (healthyPanicThreshold_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(HealthyPanicThreshold);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
            output.WriteRawTag(18);
            output.WriteMessage(ZoneAwareLbConfig);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
            output.WriteRawTag(26);
            output.WriteMessage(LocalityWeightedLbConfig);
          }
          if (updateMergeWindow_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(UpdateMergeWindow);
          }
          if (IgnoreNewHostsUntilFirstHc != false) {
            output.WriteRawTag(40);
            output.WriteBool(IgnoreNewHostsUntilFirstHc);
          }
          if (CloseConnectionsOnHostSetChange != false) {
            output.WriteRawTag(48);
            output.WriteBool(CloseConnectionsOnHostSetChange);
          }
          if (consistentHashingLbConfig_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(ConsistentHashingLbConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (healthyPanicThreshold_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(HealthyPanicThreshold);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ZoneAwareLbConfig);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalityWeightedLbConfig);
          }
          if (updateMergeWindow_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateMergeWindow);
          }
          if (IgnoreNewHostsUntilFirstHc != false) {
            size += 1 + 1;
          }
          if (CloseConnectionsOnHostSetChange != false) {
            size += 1 + 1;
          }
          if (consistentHashingLbConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConsistentHashingLbConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(CommonLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.healthyPanicThreshold_ != null) {
            if (healthyPanicThreshold_ == null) {
              HealthyPanicThreshold = new global::Envoy.Type.Percent();
            }
            HealthyPanicThreshold.MergeFrom(other.HealthyPanicThreshold);
          }
          if (other.updateMergeWindow_ != null) {
            if (updateMergeWindow_ == null) {
              UpdateMergeWindow = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            UpdateMergeWindow.MergeFrom(other.UpdateMergeWindow);
          }
          if (other.IgnoreNewHostsUntilFirstHc != false) {
            IgnoreNewHostsUntilFirstHc = other.IgnoreNewHostsUntilFirstHc;
          }
          if (other.CloseConnectionsOnHostSetChange != false) {
            CloseConnectionsOnHostSetChange = other.CloseConnectionsOnHostSetChange;
          }
          if (other.consistentHashingLbConfig_ != null) {
            if (consistentHashingLbConfig_ == null) {
              ConsistentHashingLbConfig = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ConsistentHashingLbConfig();
            }
            ConsistentHashingLbConfig.MergeFrom(other.ConsistentHashingLbConfig);
          }
          switch (other.LocalityConfigSpecifierCase) {
            case LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig:
              if (ZoneAwareLbConfig == null) {
                ZoneAwareLbConfig = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig();
              }
              ZoneAwareLbConfig.MergeFrom(other.ZoneAwareLbConfig);
              break;
            case LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig:
              if (LocalityWeightedLbConfig == null) {
                LocalityWeightedLbConfig = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig();
              }
              LocalityWeightedLbConfig.MergeFrom(other.LocalityWeightedLbConfig);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (healthyPanicThreshold_ == null) {
                  HealthyPanicThreshold = new global::Envoy.Type.Percent();
                }
                input.ReadMessage(HealthyPanicThreshold);
                break;
              }
              case 18: {
                global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig();
                if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
                  subBuilder.MergeFrom(ZoneAwareLbConfig);
                }
                input.ReadMessage(subBuilder);
                ZoneAwareLbConfig = subBuilder;
                break;
              }
              case 26: {
                global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig();
                if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
                  subBuilder.MergeFrom(LocalityWeightedLbConfig);
                }
                input.ReadMessage(subBuilder);
                LocalityWeightedLbConfig = subBuilder;
                break;
              }
              case 34: {
                if (updateMergeWindow_ == null) {
                  UpdateMergeWindow = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(UpdateMergeWindow);
                break;
              }
              case 40: {
                IgnoreNewHostsUntilFirstHc = input.ReadBool();
                break;
              }
              case 48: {
                CloseConnectionsOnHostSetChange = input.ReadBool();
                break;
              }
              case 58: {
                if (consistentHashingLbConfig_ == null) {
                  ConsistentHashingLbConfig = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ConsistentHashingLbConfig();
                }
                input.ReadMessage(ConsistentHashingLbConfig);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (healthyPanicThreshold_ == null) {
                  HealthyPanicThreshold = new global::Envoy.Type.Percent();
                }
                input.ReadMessage(HealthyPanicThreshold);
                break;
              }
              case 18: {
                global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig();
                if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
                  subBuilder.MergeFrom(ZoneAwareLbConfig);
                }
                input.ReadMessage(subBuilder);
                ZoneAwareLbConfig = subBuilder;
                break;
              }
              case 26: {
                global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig();
                if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
                  subBuilder.MergeFrom(LocalityWeightedLbConfig);
                }
                input.ReadMessage(subBuilder);
                LocalityWeightedLbConfig = subBuilder;
                break;
              }
              case 34: {
                if (updateMergeWindow_ == null) {
                  UpdateMergeWindow = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(UpdateMergeWindow);
                break;
              }
              case 40: {
                IgnoreNewHostsUntilFirstHc = input.ReadBool();
                break;
              }
              case 48: {
                CloseConnectionsOnHostSetChange = input.ReadBool();
                break;
              }
              case 58: {
                if (consistentHashingLbConfig_ == null) {
                  ConsistentHashingLbConfig = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ConsistentHashingLbConfig();
                }
                input.ReadMessage(ConsistentHashingLbConfig);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the CommonLbConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Configuration for :ref:`zone aware routing
          /// &lt;arch_overview_load_balancing_zone_aware_routing>`.
          /// </summary>
          public sealed partial class ZoneAwareLbConfig : pb::IMessage<ZoneAwareLbConfig>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<ZoneAwareLbConfig> _parser = new pb::MessageParser<ZoneAwareLbConfig>(() => new ZoneAwareLbConfig());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<ZoneAwareLbConfig> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ZoneAwareLbConfig() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ZoneAwareLbConfig(ZoneAwareLbConfig other) : this() {
              routingEnabled_ = other.routingEnabled_ != null ? other.routingEnabled_.Clone() : null;
              MinClusterSize = other.MinClusterSize;
              failTrafficOnPanic_ = other.failTrafficOnPanic_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ZoneAwareLbConfig Clone() {
              return new ZoneAwareLbConfig(this);
            }

            /// <summary>Field number for the "routing_enabled" field.</summary>
            public const int RoutingEnabledFieldNumber = 1;
            private global::Envoy.Type.Percent routingEnabled_;
            /// <summary>
            /// Configures percentage of requests that will be considered for zone aware routing
            /// if zone aware routing is configured. If not specified, the default is 100%.
            /// * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing>`.
            /// * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing>`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Envoy.Type.Percent RoutingEnabled {
              get { return routingEnabled_; }
              set {
                routingEnabled_ = value;
              }
            }

            /// <summary>Field number for the "min_cluster_size" field.</summary>
            public const int MinClusterSizeFieldNumber = 2;
            private static readonly pb::FieldCodec<ulong?> _single_minClusterSize_codec = pb::FieldCodec.ForStructWrapper<ulong>(18);
            private ulong? minClusterSize_;
            /// <summary>
            /// Configures minimum upstream cluster size required for zone aware routing
            /// If upstream cluster size is less than specified, zone aware routing is not performed
            /// even if zone aware routing is configured. If not specified, the default is 6.
            /// * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing>`.
            /// * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing>`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ulong? MinClusterSize {
              get { return minClusterSize_; }
              set {
                minClusterSize_ = value;
              }
            }


            /// <summary>Field number for the "fail_traffic_on_panic" field.</summary>
            public const int FailTrafficOnPanicFieldNumber = 3;
            private bool failTrafficOnPanic_;
            /// <summary>
            /// If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
            /// mode&lt;arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
            /// requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
            /// failing service.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool FailTrafficOnPanic {
              get { return failTrafficOnPanic_; }
              set {
                failTrafficOnPanic_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as ZoneAwareLbConfig);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(ZoneAwareLbConfig other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(RoutingEnabled, other.RoutingEnabled)) return false;
              if (MinClusterSize != other.MinClusterSize) return false;
              if (FailTrafficOnPanic != other.FailTrafficOnPanic) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (routingEnabled_ != null) hash ^= RoutingEnabled.GetHashCode();
              if (minClusterSize_ != null) hash ^= MinClusterSize.GetHashCode();
              if (FailTrafficOnPanic != false) hash ^= FailTrafficOnPanic.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (routingEnabled_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(RoutingEnabled);
              }
              if (minClusterSize_ != null) {
                _single_minClusterSize_codec.WriteTagAndValue(output, MinClusterSize);
              }
              if (FailTrafficOnPanic != false) {
                output.WriteRawTag(24);
                output.WriteBool(FailTrafficOnPanic);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (routingEnabled_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(RoutingEnabled);
              }
              if (minClusterSize_ != null) {
                _single_minClusterSize_codec.WriteTagAndValue(ref output, MinClusterSize);
              }
              if (FailTrafficOnPanic != false) {
                output.WriteRawTag(24);
                output.WriteBool(FailTrafficOnPanic);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (routingEnabled_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(RoutingEnabled);
              }
              if (minClusterSize_ != null) {
                size += _single_minClusterSize_codec.CalculateSizeWithTag(MinClusterSize);
              }
              if (FailTrafficOnPanic != false) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(ZoneAwareLbConfig other) {
              if (other == null) {
                return;
              }
              if (other.routingEnabled_ != null) {
                if (routingEnabled_ == null) {
                  RoutingEnabled = new global::Envoy.Type.Percent();
                }
                RoutingEnabled.MergeFrom(other.RoutingEnabled);
              }
              if (other.minClusterSize_ != null) {
                if (minClusterSize_ == null || other.MinClusterSize != 0UL) {
                  MinClusterSize = other.MinClusterSize;
                }
              }
              if (other.FailTrafficOnPanic != false) {
                FailTrafficOnPanic = other.FailTrafficOnPanic;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    if (routingEnabled_ == null) {
                      RoutingEnabled = new global::Envoy.Type.Percent();
                    }
                    input.ReadMessage(RoutingEnabled);
                    break;
                  }
                  case 18: {
                    ulong? value = _single_minClusterSize_codec.Read(input);
                    if (minClusterSize_ == null || value != 0UL) {
                      MinClusterSize = value;
                    }
                    break;
                  }
                  case 24: {
                    FailTrafficOnPanic = input.ReadBool();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    if (routingEnabled_ == null) {
                      RoutingEnabled = new global::Envoy.Type.Percent();
                    }
                    input.ReadMessage(RoutingEnabled);
                    break;
                  }
                  case 18: {
                    ulong? value = _single_minClusterSize_codec.Read(ref input);
                    if (minClusterSize_ == null || value != 0UL) {
                      MinClusterSize = value;
                    }
                    break;
                  }
                  case 24: {
                    FailTrafficOnPanic = input.ReadBool();
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// Configuration for :ref:`locality weighted load balancing
          /// &lt;arch_overview_load_balancing_locality_weighted_lb>`
          /// </summary>
          public sealed partial class LocalityWeightedLbConfig : pb::IMessage<LocalityWeightedLbConfig>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<LocalityWeightedLbConfig> _parser = new pb::MessageParser<LocalityWeightedLbConfig>(() => new LocalityWeightedLbConfig());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<LocalityWeightedLbConfig> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public LocalityWeightedLbConfig() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public LocalityWeightedLbConfig(LocalityWeightedLbConfig other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public LocalityWeightedLbConfig Clone() {
              return new LocalityWeightedLbConfig(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as LocalityWeightedLbConfig);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(LocalityWeightedLbConfig other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(LocalityWeightedLbConfig other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                }
              }
            }
            #endif

          }

          /// <summary>
          /// Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
          /// </summary>
          public sealed partial class ConsistentHashingLbConfig : pb::IMessage<ConsistentHashingLbConfig>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<ConsistentHashingLbConfig> _parser = new pb::MessageParser<ConsistentHashingLbConfig>(() => new ConsistentHashingLbConfig());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<ConsistentHashingLbConfig> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ConsistentHashingLbConfig() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ConsistentHashingLbConfig(ConsistentHashingLbConfig other) : this() {
              useHostnameForHashing_ = other.useHostnameForHashing_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ConsistentHashingLbConfig Clone() {
              return new ConsistentHashingLbConfig(this);
            }

            /// <summary>Field number for the "use_hostname_for_hashing" field.</summary>
            public const int UseHostnameForHashingFieldNumber = 1;
            private bool useHostnameForHashing_;
            /// <summary>
            /// If set to `true`, the cluster will use hostname instead of the resolved
            /// address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool UseHostnameForHashing {
              get { return useHostnameForHashing_; }
              set {
                useHostnameForHashing_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as ConsistentHashingLbConfig);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(ConsistentHashingLbConfig other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (UseHostnameForHashing != other.UseHostnameForHashing) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (UseHostnameForHashing != false) hash ^= UseHostnameForHashing.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (UseHostnameForHashing != false) {
                output.WriteRawTag(8);
                output.WriteBool(UseHostnameForHashing);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (UseHostnameForHashing != false) {
                output.WriteRawTag(8);
                output.WriteBool(UseHostnameForHashing);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (UseHostnameForHashing != false) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(ConsistentHashingLbConfig other) {
              if (other == null) {
                return;
              }
              if (other.UseHostnameForHashing != false) {
                UseHostnameForHashing = other.UseHostnameForHashing;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    UseHostnameForHashing = input.ReadBool();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    UseHostnameForHashing = input.ReadBool();
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

      public sealed partial class RefreshRate : pb::IMessage<RefreshRate>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RefreshRate> _parser = new pb::MessageParser<RefreshRate>(() => new RefreshRate());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<RefreshRate> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[8]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RefreshRate() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RefreshRate(RefreshRate other) : this() {
          baseInterval_ = other.baseInterval_ != null ? other.baseInterval_.Clone() : null;
          maxInterval_ = other.maxInterval_ != null ? other.maxInterval_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RefreshRate Clone() {
          return new RefreshRate(this);
        }

        /// <summary>Field number for the "base_interval" field.</summary>
        public const int BaseIntervalFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Duration baseInterval_;
        /// <summary>
        /// Specifies the base interval between refreshes. This parameter is required and must be greater
        /// than zero and less than
        /// :ref:`max_interval &lt;envoy_api_field_Cluster.RefreshRate.max_interval>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration BaseInterval {
          get { return baseInterval_; }
          set {
            baseInterval_ = value;
          }
        }

        /// <summary>Field number for the "max_interval" field.</summary>
        public const int MaxIntervalFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Duration maxInterval_;
        /// <summary>
        /// Specifies the maximum interval between refreshes. This parameter is optional, but must be
        /// greater than or equal to the
        /// :ref:`base_interval &lt;envoy_api_field_Cluster.RefreshRate.base_interval>`  if set. The default
        /// is 10 times the :ref:`base_interval &lt;envoy_api_field_Cluster.RefreshRate.base_interval>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration MaxInterval {
          get { return maxInterval_; }
          set {
            maxInterval_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as RefreshRate);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(RefreshRate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(BaseInterval, other.BaseInterval)) return false;
          if (!object.Equals(MaxInterval, other.MaxInterval)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (baseInterval_ != null) hash ^= BaseInterval.GetHashCode();
          if (maxInterval_ != null) hash ^= MaxInterval.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (baseInterval_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(BaseInterval);
          }
          if (maxInterval_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(MaxInterval);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (baseInterval_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(BaseInterval);
          }
          if (maxInterval_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(MaxInterval);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (baseInterval_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(BaseInterval);
          }
          if (maxInterval_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxInterval);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(RefreshRate other) {
          if (other == null) {
            return;
          }
          if (other.baseInterval_ != null) {
            if (baseInterval_ == null) {
              BaseInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            BaseInterval.MergeFrom(other.BaseInterval);
          }
          if (other.maxInterval_ != null) {
            if (maxInterval_ == null) {
              MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            MaxInterval.MergeFrom(other.MaxInterval);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (baseInterval_ == null) {
                  BaseInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(BaseInterval);
                break;
              }
              case 18: {
                if (maxInterval_ == null) {
                  MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxInterval);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (baseInterval_ == null) {
                  BaseInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(BaseInterval);
                break;
              }
              case 18: {
                if (maxInterval_ == null) {
                  MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxInterval);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// [#not-implemented-hide:] Extensible load balancing policy configuration.
  ///
  /// Every LB policy defined via this mechanism will be identified via a unique name using reverse
  /// DNS notation. If the policy needs configuration parameters, it must define a message for its
  /// own configuration, which will be stored in the config field. The name of the policy will tell
  /// clients which type of message they should expect to see in the config field.
  ///
  /// Note that there are cases where it is useful to be able to independently select LB policies
  /// for choosing a locality and for choosing an endpoint within that locality. For example, a
  /// given deployment may always use the same policy to choose the locality, but for choosing the
  /// endpoint within the locality, some clusters may use weighted-round-robin, while others may
  /// use some sort of session-based balancing.
  ///
  /// This can be accomplished via hierarchical LB policies, where the parent LB policy creates a
  /// child LB policy for each locality. For each request, the parent chooses the locality and then
  /// delegates to the child policy for that locality to choose the endpoint within the locality.
  ///
  /// To facilitate this, the config message for the top-level LB policy may include a field of
  /// type LoadBalancingPolicy that specifies the child policy.
  /// </summary>
  public sealed partial class LoadBalancingPolicy : pb::IMessage<LoadBalancingPolicy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LoadBalancingPolicy> _parser = new pb::MessageParser<LoadBalancingPolicy>(() => new LoadBalancingPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LoadBalancingPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.ClusterReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LoadBalancingPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LoadBalancingPolicy(LoadBalancingPolicy other) : this() {
      policies_ = other.policies_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LoadBalancingPolicy Clone() {
      return new LoadBalancingPolicy(this);
    }

    /// <summary>Field number for the "policies" field.</summary>
    public const int PoliciesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.LoadBalancingPolicy.Types.Policy> _repeated_policies_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Api.V2.LoadBalancingPolicy.Types.Policy.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.LoadBalancingPolicy.Types.Policy> policies_ = new pbc::RepeatedField<global::Envoy.Api.V2.LoadBalancingPolicy.Types.Policy>();
    /// <summary>
    /// Each client will iterate over the list in order and stop at the first policy that it
    /// supports. This provides a mechanism for starting to use new LB policies that are not yet
    /// supported by all clients.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Api.V2.LoadBalancingPolicy.Types.Policy> Policies {
      get { return policies_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LoadBalancingPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LoadBalancingPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!policies_.Equals(other.policies_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= policies_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      policies_.WriteTo(output, _repeated_policies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      policies_.WriteTo(ref output, _repeated_policies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += policies_.CalculateSize(_repeated_policies_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LoadBalancingPolicy other) {
      if (other == null) {
        return;
      }
      policies_.Add(other.policies_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            policies_.AddEntriesFrom(input, _repeated_policies_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            policies_.AddEntriesFrom(ref input, _repeated_policies_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the LoadBalancingPolicy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public sealed partial class Policy : pb::IMessage<Policy>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Policy> _parser = new pb::MessageParser<Policy>(() => new Policy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Policy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.LoadBalancingPolicy.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Policy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Policy(Policy other) : this() {
          name_ = other.name_;
          config_ = other.config_ != null ? other.config_.Clone() : null;
          typedConfig_ = other.typedConfig_ != null ? other.typedConfig_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Policy Clone() {
          return new Policy(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// Required. The name of the LB policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "config" field.</summary>
        public const int ConfigFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Struct config_;
        /// <summary>
        /// Optional config for the LB policy.
        /// No more than one of these two fields may be populated.
        /// </summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Struct Config {
          get { return config_; }
          set {
            config_ = value;
          }
        }

        /// <summary>Field number for the "typed_config" field.</summary>
        public const int TypedConfigFieldNumber = 3;
        private global::Google.Protobuf.WellKnownTypes.Any typedConfig_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Any TypedConfig {
          get { return typedConfig_; }
          set {
            typedConfig_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Policy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Policy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(Config, other.Config)) return false;
          if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (config_ != null) hash ^= Config.GetHashCode();
          if (typedConfig_ != null) hash ^= TypedConfig.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (config_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Config);
          }
          if (typedConfig_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (config_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Config);
          }
          if (typedConfig_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (config_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
          }
          if (typedConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Policy other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.config_ != null) {
            if (config_ == null) {
              Config = new global::Google.Protobuf.WellKnownTypes.Struct();
            }
            Config.MergeFrom(other.Config);
          }
          if (other.typedConfig_ != null) {
            if (typedConfig_ == null) {
              TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            TypedConfig.MergeFrom(other.TypedConfig);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                if (config_ == null) {
                  Config = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(Config);
                break;
              }
              case 26: {
                if (typedConfig_ == null) {
                  TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
                }
                input.ReadMessage(TypedConfig);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                if (config_ == null) {
                  Config = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(Config);
                break;
              }
              case 26: {
                if (typedConfig_ == null) {
                  TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
                }
                input.ReadMessage(TypedConfig);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// An extensible structure containing the address Envoy should bind to when
  /// establishing upstream connections.
  /// </summary>
  public sealed partial class UpstreamBindConfig : pb::IMessage<UpstreamBindConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpstreamBindConfig> _parser = new pb::MessageParser<UpstreamBindConfig>(() => new UpstreamBindConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UpstreamBindConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.ClusterReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamBindConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamBindConfig(UpstreamBindConfig other) : this() {
      sourceAddress_ = other.sourceAddress_ != null ? other.sourceAddress_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamBindConfig Clone() {
      return new UpstreamBindConfig(this);
    }

    /// <summary>Field number for the "source_address" field.</summary>
    public const int SourceAddressFieldNumber = 1;
    private global::Envoy.Api.V2.Core.Address sourceAddress_;
    /// <summary>
    /// The address Envoy should bind to when establishing upstream connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.Address SourceAddress {
      get { return sourceAddress_; }
      set {
        sourceAddress_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UpstreamBindConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UpstreamBindConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SourceAddress, other.SourceAddress)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (sourceAddress_ != null) hash ^= SourceAddress.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (sourceAddress_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SourceAddress);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (sourceAddress_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SourceAddress);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (sourceAddress_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceAddress);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UpstreamBindConfig other) {
      if (other == null) {
        return;
      }
      if (other.sourceAddress_ != null) {
        if (sourceAddress_ == null) {
          SourceAddress = new global::Envoy.Api.V2.Core.Address();
        }
        SourceAddress.MergeFrom(other.SourceAddress);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (sourceAddress_ == null) {
              SourceAddress = new global::Envoy.Api.V2.Core.Address();
            }
            input.ReadMessage(SourceAddress);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (sourceAddress_ == null) {
              SourceAddress = new global::Envoy.Api.V2.Core.Address();
            }
            input.ReadMessage(SourceAddress);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class UpstreamConnectionOptions : pb::IMessage<UpstreamConnectionOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpstreamConnectionOptions> _parser = new pb::MessageParser<UpstreamConnectionOptions>(() => new UpstreamConnectionOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UpstreamConnectionOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.ClusterReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamConnectionOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamConnectionOptions(UpstreamConnectionOptions other) : this() {
      tcpKeepalive_ = other.tcpKeepalive_ != null ? other.tcpKeepalive_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamConnectionOptions Clone() {
      return new UpstreamConnectionOptions(this);
    }

    /// <summary>Field number for the "tcp_keepalive" field.</summary>
    public const int TcpKeepaliveFieldNumber = 1;
    private global::Envoy.Api.V2.Core.TcpKeepalive tcpKeepalive_;
    /// <summary>
    /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.TcpKeepalive TcpKeepalive {
      get { return tcpKeepalive_; }
      set {
        tcpKeepalive_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UpstreamConnectionOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UpstreamConnectionOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TcpKeepalive, other.TcpKeepalive)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (tcpKeepalive_ != null) hash ^= TcpKeepalive.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tcpKeepalive_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TcpKeepalive);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tcpKeepalive_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TcpKeepalive);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (tcpKeepalive_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TcpKeepalive);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UpstreamConnectionOptions other) {
      if (other == null) {
        return;
      }
      if (other.tcpKeepalive_ != null) {
        if (tcpKeepalive_ == null) {
          TcpKeepalive = new global::Envoy.Api.V2.Core.TcpKeepalive();
        }
        TcpKeepalive.MergeFrom(other.TcpKeepalive);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tcpKeepalive_ == null) {
              TcpKeepalive = new global::Envoy.Api.V2.Core.TcpKeepalive();
            }
            input.ReadMessage(TcpKeepalive);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (tcpKeepalive_ == null) {
              TcpKeepalive = new global::Envoy.Api.V2.Core.TcpKeepalive();
            }
            input.ReadMessage(TcpKeepalive);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
