// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/api/v2/listener.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2 {

  /// <summary>Holder for reflection information generated from envoy/api/v2/listener.proto</summary>
  public static partial class ListenerReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/api/v2/listener.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ListenerReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChtlbnZveS9hcGkvdjIvbGlzdGVuZXIucHJvdG8SDGVudm95LmFwaS52Mhof",
            "ZW52b3kvYXBpL3YyL2NvcmUvYWRkcmVzcy5wcm90bxocZW52b3kvYXBpL3Yy",
            "L2NvcmUvYmFzZS5wcm90bxolZW52b3kvYXBpL3YyL2NvcmUvc29ja2V0X29w",
            "dGlvbi5wcm90bxovZW52b3kvYXBpL3YyL2xpc3RlbmVyL2xpc3RlbmVyX2Nv",
            "bXBvbmVudHMucHJvdG8aL2Vudm95L2FwaS92Mi9saXN0ZW5lci91ZHBfbGlz",
            "dGVuZXJfY29uZmlnLnByb3RvGjBlbnZveS9jb25maWcvZmlsdGVyL2FjY2Vz",
            "c2xvZy92Mi9hY2Nlc3Nsb2cucHJvdG8aK2Vudm95L2NvbmZpZy9saXN0ZW5l",
            "ci92Mi9hcGlfbGlzdGVuZXIucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi9kdXJh",
            "dGlvbi5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvGh51",
            "ZHBhL2Fubm90YXRpb25zL21pZ3JhdGUucHJvdG8aHXVkcGEvYW5ub3RhdGlv",
            "bnMvc3RhdHVzLnByb3RvGhd2YWxpZGF0ZS92YWxpZGF0ZS5wcm90byKqCwoI",
            "TGlzdGVuZXISDAoEbmFtZRgBIAEoCRI1CgdhZGRyZXNzGAIgASgLMhouZW52",
            "b3kuYXBpLnYyLmNvcmUuQWRkcmVzc0II+kIFigECEAESOQoNZmlsdGVyX2No",
            "YWlucxgDIAMoCzIiLmVudm95LmFwaS52Mi5saXN0ZW5lci5GaWx0ZXJDaGFp",
            "bhI4ChB1c2Vfb3JpZ2luYWxfZHN0GAQgASgLMhouZ29vZ2xlLnByb3RvYnVm",
            "LkJvb2xWYWx1ZUICGAESRwohcGVyX2Nvbm5lY3Rpb25fYnVmZmVyX2xpbWl0",
            "X2J5dGVzGAUgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlEi0K",
            "CG1ldGFkYXRhGAYgASgLMhsuZW52b3kuYXBpLnYyLmNvcmUuTWV0YWRhdGES",
            "OgoNZGVwcmVjYXRlZF92MRgHIAEoCzIjLmVudm95LmFwaS52Mi5MaXN0ZW5l",
            "ci5EZXByZWNhdGVkVjESNAoKZHJhaW5fdHlwZRgIIAEoDjIgLmVudm95LmFw",
            "aS52Mi5MaXN0ZW5lci5EcmFpblR5cGUSPwoQbGlzdGVuZXJfZmlsdGVycxgJ",
            "IAMoCzIlLmVudm95LmFwaS52Mi5saXN0ZW5lci5MaXN0ZW5lckZpbHRlchI7",
            "ChhsaXN0ZW5lcl9maWx0ZXJzX3RpbWVvdXQYDyABKAsyGS5nb29nbGUucHJv",
            "dG9idWYuRHVyYXRpb24SLAokY29udGludWVfb25fbGlzdGVuZXJfZmlsdGVy",
            "c190aW1lb3V0GBEgASgIEi8KC3RyYW5zcGFyZW50GAogASgLMhouZ29vZ2xl",
            "LnByb3RvYnVmLkJvb2xWYWx1ZRIsCghmcmVlYmluZBgLIAEoCzIaLmdvb2ds",
            "ZS5wcm90b2J1Zi5Cb29sVmFsdWUSNwoOc29ja2V0X29wdGlvbnMYDSADKAsy",
            "Hy5lbnZveS5hcGkudjIuY29yZS5Tb2NrZXRPcHRpb24SQAoadGNwX2Zhc3Rf",
            "b3Blbl9xdWV1ZV9sZW5ndGgYDCABKAsyHC5nb29nbGUucHJvdG9idWYuVUlu",
            "dDMyVmFsdWUSPgoRdHJhZmZpY19kaXJlY3Rpb24YECABKA4yIy5lbnZveS5h",
            "cGkudjIuY29yZS5UcmFmZmljRGlyZWN0aW9uEkUKE3VkcF9saXN0ZW5lcl9j",
            "b25maWcYEiABKAsyKC5lbnZveS5hcGkudjIubGlzdGVuZXIuVWRwTGlzdGVu",
            "ZXJDb25maWcSOwoMYXBpX2xpc3RlbmVyGBMgASgLMiUuZW52b3kuY29uZmln",
            "Lmxpc3RlbmVyLnYyLkFwaUxpc3RlbmVyElEKGWNvbm5lY3Rpb25fYmFsYW5j",
            "ZV9jb25maWcYFCABKAsyLi5lbnZveS5hcGkudjIuTGlzdGVuZXIuQ29ubmVj",
            "dGlvbkJhbGFuY2VDb25maWcSEgoKcmV1c2VfcG9ydBgVIAEoCBI/CgphY2Nl",
            "c3NfbG9nGBYgAygLMisuZW52b3kuY29uZmlnLmZpbHRlci5hY2Nlc3Nsb2cu",
            "djIuQWNjZXNzTG9nGkAKDERlcHJlY2F0ZWRWMRIwCgxiaW5kX3RvX3BvcnQY",
            "ASABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlGpQBChdDb25uZWN0",
            "aW9uQmFsYW5jZUNvbmZpZxJUCg1leGFjdF9iYWxhbmNlGAEgASgLMjsuZW52",
            "b3kuYXBpLnYyLkxpc3RlbmVyLkNvbm5lY3Rpb25CYWxhbmNlQ29uZmlnLkV4",
            "YWN0QmFsYW5jZUgAGg4KDEV4YWN0QmFsYW5jZUITCgxiYWxhbmNlX3R5cGUS",
            "A/hCASIpCglEcmFpblR5cGUSCwoHREVGQVVMVBAAEg8KC01PRElGWV9PTkxZ",
            "EAFKBAgOEA9CVQoaaW8uZW52b3lwcm94eS5lbnZveS5hcGkudjJCDUxpc3Rl",
            "bmVyUHJvdG9QAfKY/o8FGhIYZW52b3kuY29uZmlnLmxpc3RlbmVyLnYzuoDI",
            "0QYCEAFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.AddressReflection.Descriptor, global::Envoy.Api.V2.Core.BaseReflection.Descriptor, global::Envoy.Api.V2.Core.SocketOptionReflection.Descriptor, global::Envoy.Api.V2.ListenerNS.ListenerComponentsReflection.Descriptor, global::Envoy.Api.V2.ListenerNS.UdpListenerConfigReflection.Descriptor, global::Envoy.Config.Filter.Accesslog.V2.AccesslogReflection.Descriptor, global::Envoy.Config.Listener.V2.ApiListenerReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Udpa.Annotations.MigrateReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Listener), global::Envoy.Api.V2.Listener.Parser, new[]{ "Name", "Address", "FilterChains", "UseOriginalDst", "PerConnectionBufferLimitBytes", "Metadata", "DeprecatedV1", "DrainType", "ListenerFilters", "ListenerFiltersTimeout", "ContinueOnListenerFiltersTimeout", "Transparent", "Freebind", "SocketOptions", "TcpFastOpenQueueLength", "TrafficDirection", "UdpListenerConfig", "ApiListener", "ConnectionBalanceConfig", "ReusePort", "AccessLog" }, null, new[]{ typeof(global::Envoy.Api.V2.Listener.Types.DrainType) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Listener.Types.DeprecatedV1), global::Envoy.Api.V2.Listener.Types.DeprecatedV1.Parser, new[]{ "BindToPort" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig), global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig.Parser, new[]{ "ExactBalance" }, new[]{ "BalanceType" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance), global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance.Parser, null, null, null, null, null)})})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// [#next-free-field: 23]
  /// </summary>
  public sealed partial class Listener : pb::IMessage<Listener>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Listener> _parser = new pb::MessageParser<Listener>(() => new Listener());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Listener> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.ListenerReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Listener() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Listener(Listener other) : this() {
      name_ = other.name_;
      address_ = other.address_ != null ? other.address_.Clone() : null;
      filterChains_ = other.filterChains_.Clone();
      UseOriginalDst = other.UseOriginalDst;
      PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      deprecatedV1_ = other.deprecatedV1_ != null ? other.deprecatedV1_.Clone() : null;
      drainType_ = other.drainType_;
      listenerFilters_ = other.listenerFilters_.Clone();
      listenerFiltersTimeout_ = other.listenerFiltersTimeout_ != null ? other.listenerFiltersTimeout_.Clone() : null;
      continueOnListenerFiltersTimeout_ = other.continueOnListenerFiltersTimeout_;
      Transparent = other.Transparent;
      Freebind = other.Freebind;
      socketOptions_ = other.socketOptions_.Clone();
      TcpFastOpenQueueLength = other.TcpFastOpenQueueLength;
      trafficDirection_ = other.trafficDirection_;
      udpListenerConfig_ = other.udpListenerConfig_ != null ? other.udpListenerConfig_.Clone() : null;
      apiListener_ = other.apiListener_ != null ? other.apiListener_.Clone() : null;
      connectionBalanceConfig_ = other.connectionBalanceConfig_ != null ? other.connectionBalanceConfig_.Clone() : null;
      reusePort_ = other.reusePort_;
      accessLog_ = other.accessLog_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Listener Clone() {
      return new Listener(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The unique name by which this listener is known. If no name is provided,
    /// Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
    /// updated or removed via :ref:`LDS &lt;config_listeners_lds>` a unique name must be provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 2;
    private global::Envoy.Api.V2.Core.Address address_;
    /// <summary>
    /// The address that the listener should listen on. In general, the address must be unique, though
    /// that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
    /// Linux as the actual port will be allocated by the OS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.Address Address {
      get { return address_; }
      set {
        address_ = value;
      }
    }

    /// <summary>Field number for the "filter_chains" field.</summary>
    public const int FilterChainsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.ListenerNS.FilterChain> _repeated_filterChains_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Api.V2.ListenerNS.FilterChain.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.ListenerNS.FilterChain> filterChains_ = new pbc::RepeatedField<global::Envoy.Api.V2.ListenerNS.FilterChain>();
    /// <summary>
    /// A list of filter chains to consider for this listener. The
    /// :ref:`FilterChain &lt;envoy_api_msg_listener.FilterChain>` with the most specific
    /// :ref:`FilterChainMatch &lt;envoy_api_msg_listener.FilterChainMatch>` criteria is used on a
    /// connection.
    ///
    /// Example using SNI for filter chain selection can be found in the
    /// :ref:`FAQ entry &lt;faq_how_to_setup_sni>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Api.V2.ListenerNS.FilterChain> FilterChains {
      get { return filterChains_; }
    }

    /// <summary>Field number for the "use_original_dst" field.</summary>
    public const int UseOriginalDstFieldNumber = 4;
    private static readonly pb::FieldCodec<bool?> _single_useOriginalDst_codec = pb::FieldCodec.ForStructWrapper<bool>(34);
    private bool? useOriginalDst_;
    /// <summary>
    /// If a connection is redirected using *iptables*, the port on which the proxy
    /// receives it might be different from the original destination address. When this flag is set to
    /// true, the listener hands off redirected connections to the listener associated with the
    /// original destination address. If there is no listener associated with the original destination
    /// address, the connection is handled by the listener that receives it. Defaults to false.
    ///
    /// .. attention::
    ///
    ///   This field is deprecated. Use :ref:`an original_dst &lt;config_listener_filters_original_dst>`
    ///   :ref:`listener filter &lt;envoy_api_field_Listener.listener_filters>` instead.
    ///
    ///   Note that hand off to another listener is *NOT* performed without this flag. Once
    ///   :ref:`FilterChainMatch &lt;envoy_api_msg_listener.FilterChainMatch>` is implemented this flag
    ///   will be removed, as filter chain matching can be used to select a filter chain based on the
    ///   restored destination address.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? UseOriginalDst {
      get { return useOriginalDst_; }
      set {
        useOriginalDst_ = value;
      }
    }


    /// <summary>Field number for the "per_connection_buffer_limit_bytes" field.</summary>
    public const int PerConnectionBufferLimitBytesFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_perConnectionBufferLimitBytes_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? perConnectionBufferLimitBytes_;
    /// <summary>
    /// Soft limit on size of the listenerâ€™s new connection read and write buffers.
    /// If unspecified, an implementation defined default is applied (1MiB).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? PerConnectionBufferLimitBytes {
      get { return perConnectionBufferLimitBytes_; }
      set {
        perConnectionBufferLimitBytes_ = value;
      }
    }


    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 6;
    private global::Envoy.Api.V2.Core.Metadata metadata_;
    /// <summary>
    /// Listener metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "deprecated_v1" field.</summary>
    public const int DeprecatedV1FieldNumber = 7;
    private global::Envoy.Api.V2.Listener.Types.DeprecatedV1 deprecatedV1_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Listener.Types.DeprecatedV1 DeprecatedV1 {
      get { return deprecatedV1_; }
      set {
        deprecatedV1_ = value;
      }
    }

    /// <summary>Field number for the "drain_type" field.</summary>
    public const int DrainTypeFieldNumber = 8;
    private global::Envoy.Api.V2.Listener.Types.DrainType drainType_ = global::Envoy.Api.V2.Listener.Types.DrainType.Default;
    /// <summary>
    /// The type of draining to perform at a listener-wide level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Listener.Types.DrainType DrainType {
      get { return drainType_; }
      set {
        drainType_ = value;
      }
    }

    /// <summary>Field number for the "listener_filters" field.</summary>
    public const int ListenerFiltersFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.ListenerNS.ListenerFilter> _repeated_listenerFilters_codec
        = pb::FieldCodec.ForMessage(74, global::Envoy.Api.V2.ListenerNS.ListenerFilter.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.ListenerNS.ListenerFilter> listenerFilters_ = new pbc::RepeatedField<global::Envoy.Api.V2.ListenerNS.ListenerFilter>();
    /// <summary>
    /// Listener filters have the opportunity to manipulate and augment the connection metadata that
    /// is used in connection filter chain matching, for example. These filters are run before any in
    /// :ref:`filter_chains &lt;envoy_api_field_Listener.filter_chains>`. Order matters as the
    /// filters are processed sequentially right after a socket has been accepted by the listener, and
    /// before a connection is created.
    /// UDP Listener filters can be specified when the protocol in the listener socket address in
    /// :ref:`protocol &lt;envoy_api_field_core.SocketAddress.protocol>` is :ref:`UDP
    /// &lt;envoy_api_enum_value_core.SocketAddress.Protocol.UDP>`.
    /// UDP listeners currently support a single filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Api.V2.ListenerNS.ListenerFilter> ListenerFilters {
      get { return listenerFilters_; }
    }

    /// <summary>Field number for the "listener_filters_timeout" field.</summary>
    public const int ListenerFiltersTimeoutFieldNumber = 15;
    private global::Google.Protobuf.WellKnownTypes.Duration listenerFiltersTimeout_;
    /// <summary>
    /// The timeout to wait for all listener filters to complete operation. If the timeout is reached,
    /// the accepted socket is closed without a connection being created unless
    /// `continue_on_listener_filters_timeout` is set to true. Specify 0 to disable the
    /// timeout. If not specified, a default timeout of 15s is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration ListenerFiltersTimeout {
      get { return listenerFiltersTimeout_; }
      set {
        listenerFiltersTimeout_ = value;
      }
    }

    /// <summary>Field number for the "continue_on_listener_filters_timeout" field.</summary>
    public const int ContinueOnListenerFiltersTimeoutFieldNumber = 17;
    private bool continueOnListenerFiltersTimeout_;
    /// <summary>
    /// Whether a connection should be created when listener filters timeout. Default is false.
    ///
    /// .. attention::
    ///
    ///   Some listener filters, such as :ref:`Proxy Protocol filter
    ///   &lt;config_listener_filters_proxy_protocol>`, should not be used with this option. It will cause
    ///   unexpected behavior when a connection is created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ContinueOnListenerFiltersTimeout {
      get { return continueOnListenerFiltersTimeout_; }
      set {
        continueOnListenerFiltersTimeout_ = value;
      }
    }

    /// <summary>Field number for the "transparent" field.</summary>
    public const int TransparentFieldNumber = 10;
    private static readonly pb::FieldCodec<bool?> _single_transparent_codec = pb::FieldCodec.ForStructWrapper<bool>(82);
    private bool? transparent_;
    /// <summary>
    /// Whether the listener should be set as a transparent socket.
    /// When this flag is set to true, connections can be redirected to the listener using an
    /// *iptables* *TPROXY* target, in which case the original source and destination addresses and
    /// ports are preserved on accepted connections. This flag should be used in combination with
    /// :ref:`an original_dst &lt;config_listener_filters_original_dst>` :ref:`listener filter
    /// &lt;envoy_api_field_Listener.listener_filters>` to mark the connections' local addresses as
    /// "restored." This can be used to hand off each redirected connection to another listener
    /// associated with the connection's destination address. Direct connections to the socket without
    /// using *TPROXY* cannot be distinguished from connections redirected using *TPROXY* and are
    /// therefore treated as if they were redirected.
    /// When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
    /// Setting this flag requires Envoy to run with the *CAP_NET_ADMIN* capability.
    /// When this flag is not set (default), the socket is not modified, i.e. the transparent option
    /// is neither set nor reset.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? Transparent {
      get { return transparent_; }
      set {
        transparent_ = value;
      }
    }


    /// <summary>Field number for the "freebind" field.</summary>
    public const int FreebindFieldNumber = 11;
    private static readonly pb::FieldCodec<bool?> _single_freebind_codec = pb::FieldCodec.ForStructWrapper<bool>(90);
    private bool? freebind_;
    /// <summary>
    /// Whether the listener should set the *IP_FREEBIND* socket option. When this
    /// flag is set to true, listeners can be bound to an IP address that is not
    /// configured on the system running Envoy. When this flag is set to false, the
    /// option *IP_FREEBIND* is disabled on the socket. When this flag is not set
    /// (default), the socket is not modified, i.e. the option is neither enabled
    /// nor disabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? Freebind {
      get { return freebind_; }
      set {
        freebind_ = value;
      }
    }


    /// <summary>Field number for the "socket_options" field.</summary>
    public const int SocketOptionsFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.SocketOption> _repeated_socketOptions_codec
        = pb::FieldCodec.ForMessage(106, global::Envoy.Api.V2.Core.SocketOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.SocketOption> socketOptions_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.SocketOption>();
    /// <summary>
    /// Additional socket options that may not be present in Envoy source code or
    /// precompiled binaries.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.SocketOption> SocketOptions {
      get { return socketOptions_; }
    }

    /// <summary>Field number for the "tcp_fast_open_queue_length" field.</summary>
    public const int TcpFastOpenQueueLengthFieldNumber = 12;
    private static readonly pb::FieldCodec<uint?> _single_tcpFastOpenQueueLength_codec = pb::FieldCodec.ForStructWrapper<uint>(98);
    private uint? tcpFastOpenQueueLength_;
    /// <summary>
    /// Whether the listener should accept TCP Fast Open (TFO) connections.
    /// When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
    /// the socket, with a queue length of the specified size
    /// (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1>`_).
    /// When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
    /// When this flag is not set (default), the socket is not modified,
    /// i.e. the option is neither enabled nor disabled.
    ///
    /// On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
    /// TCP_FASTOPEN.
    /// See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt>`_.
    ///
    /// On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
    /// To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? TcpFastOpenQueueLength {
      get { return tcpFastOpenQueueLength_; }
      set {
        tcpFastOpenQueueLength_ = value;
      }
    }


    /// <summary>Field number for the "traffic_direction" field.</summary>
    public const int TrafficDirectionFieldNumber = 16;
    private global::Envoy.Api.V2.Core.TrafficDirection trafficDirection_ = global::Envoy.Api.V2.Core.TrafficDirection.Unspecified;
    /// <summary>
    /// Specifies the intended direction of the traffic relative to the local Envoy.
    /// This property is required on Windows for listeners using the original destination filter,
    /// see :ref:`Original Destination &lt;config_listener_filters_original_dst>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.TrafficDirection TrafficDirection {
      get { return trafficDirection_; }
      set {
        trafficDirection_ = value;
      }
    }

    /// <summary>Field number for the "udp_listener_config" field.</summary>
    public const int UdpListenerConfigFieldNumber = 18;
    private global::Envoy.Api.V2.ListenerNS.UdpListenerConfig udpListenerConfig_;
    /// <summary>
    /// If the protocol in the listener socket address in :ref:`protocol
    /// &lt;envoy_api_field_core.SocketAddress.protocol>` is :ref:`UDP
    /// &lt;envoy_api_enum_value_core.SocketAddress.Protocol.UDP>`, this field specifies the actual udp
    /// listener to create, i.e. :ref:`udp_listener_name
    /// &lt;envoy_api_field_listener.UdpListenerConfig.udp_listener_name>` = "raw_udp_listener" for
    /// creating a packet-oriented UDP listener. If not present, treat it as "raw_udp_listener".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.ListenerNS.UdpListenerConfig UdpListenerConfig {
      get { return udpListenerConfig_; }
      set {
        udpListenerConfig_ = value;
      }
    }

    /// <summary>Field number for the "api_listener" field.</summary>
    public const int ApiListenerFieldNumber = 19;
    private global::Envoy.Config.Listener.V2.ApiListener apiListener_;
    /// <summary>
    /// Used to represent an API listener, which is used in non-proxy clients. The type of API
    /// exposed to the non-proxy application depends on the type of API listener.
    /// When this field is set, no other field except for :ref:`name&lt;envoy_api_field_Listener.name>`
    /// should be set.
    ///
    /// .. note::
    ///
    ///  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
    ///  not LDS.
    ///
    /// [#next-major-version: In the v3 API, instead of this messy approach where the socket
    /// listener fields are directly in the top-level Listener message and the API listener types
    /// are in the ApiListener message, the socket listener messages should be in their own message,
    /// and the top-level Listener should essentially be a oneof that selects between the
    /// socket listener and the various types of API listener. That way, a given Listener message
    /// can structurally only contain the fields of the relevant type.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Listener.V2.ApiListener ApiListener {
      get { return apiListener_; }
      set {
        apiListener_ = value;
      }
    }

    /// <summary>Field number for the "connection_balance_config" field.</summary>
    public const int ConnectionBalanceConfigFieldNumber = 20;
    private global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig connectionBalanceConfig_;
    /// <summary>
    /// The listener's connection balancer configuration, currently only applicable to TCP listeners.
    /// If no configuration is specified, Envoy will not attempt to balance active connections between
    /// worker threads.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig ConnectionBalanceConfig {
      get { return connectionBalanceConfig_; }
      set {
        connectionBalanceConfig_ = value;
      }
    }

    /// <summary>Field number for the "reuse_port" field.</summary>
    public const int ReusePortFieldNumber = 21;
    private bool reusePort_;
    /// <summary>
    /// When this flag is set to true, listeners set the *SO_REUSEPORT* socket option and
    /// create one socket for each worker thread. This makes inbound connections
    /// distribute among worker threads roughly evenly in cases where there are a high number
    /// of connections. When this flag is set to false, all worker threads share one socket.
    ///
    /// Before Linux v4.19-rc1, new TCP connections may be rejected during hot restart
    /// (see `3rd paragraph in 'soreuseport' commit message
    /// &lt;https://github.com/torvalds/linux/commit/c617f398edd4db2b8567a28e89>`_).
    /// This issue was fixed by `tcp: Avoid TCP syncookie rejected by SO_REUSEPORT socket
    /// &lt;https://github.com/torvalds/linux/commit/40a1227ea845a37ab197dd1caffb60b047fa36b1>`_.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReusePort {
      get { return reusePort_; }
      set {
        reusePort_ = value;
      }
    }

    /// <summary>Field number for the "access_log" field.</summary>
    public const int AccessLogFieldNumber = 22;
    private static readonly pb::FieldCodec<global::Envoy.Config.Filter.Accesslog.V2.AccessLog> _repeated_accessLog_codec
        = pb::FieldCodec.ForMessage(178, global::Envoy.Config.Filter.Accesslog.V2.AccessLog.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Filter.Accesslog.V2.AccessLog> accessLog_ = new pbc::RepeatedField<global::Envoy.Config.Filter.Accesslog.V2.AccessLog>();
    /// <summary>
    /// Configuration for :ref:`access logs &lt;arch_overview_access_logs>`
    /// emitted by this listener.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Filter.Accesslog.V2.AccessLog> AccessLog {
      get { return accessLog_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Listener);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Listener other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Address, other.Address)) return false;
      if(!filterChains_.Equals(other.filterChains_)) return false;
      if (UseOriginalDst != other.UseOriginalDst) return false;
      if (PerConnectionBufferLimitBytes != other.PerConnectionBufferLimitBytes) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(DeprecatedV1, other.DeprecatedV1)) return false;
      if (DrainType != other.DrainType) return false;
      if(!listenerFilters_.Equals(other.listenerFilters_)) return false;
      if (!object.Equals(ListenerFiltersTimeout, other.ListenerFiltersTimeout)) return false;
      if (ContinueOnListenerFiltersTimeout != other.ContinueOnListenerFiltersTimeout) return false;
      if (Transparent != other.Transparent) return false;
      if (Freebind != other.Freebind) return false;
      if(!socketOptions_.Equals(other.socketOptions_)) return false;
      if (TcpFastOpenQueueLength != other.TcpFastOpenQueueLength) return false;
      if (TrafficDirection != other.TrafficDirection) return false;
      if (!object.Equals(UdpListenerConfig, other.UdpListenerConfig)) return false;
      if (!object.Equals(ApiListener, other.ApiListener)) return false;
      if (!object.Equals(ConnectionBalanceConfig, other.ConnectionBalanceConfig)) return false;
      if (ReusePort != other.ReusePort) return false;
      if(!accessLog_.Equals(other.accessLog_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (address_ != null) hash ^= Address.GetHashCode();
      hash ^= filterChains_.GetHashCode();
      if (useOriginalDst_ != null) hash ^= UseOriginalDst.GetHashCode();
      if (perConnectionBufferLimitBytes_ != null) hash ^= PerConnectionBufferLimitBytes.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (deprecatedV1_ != null) hash ^= DeprecatedV1.GetHashCode();
      if (DrainType != global::Envoy.Api.V2.Listener.Types.DrainType.Default) hash ^= DrainType.GetHashCode();
      hash ^= listenerFilters_.GetHashCode();
      if (listenerFiltersTimeout_ != null) hash ^= ListenerFiltersTimeout.GetHashCode();
      if (ContinueOnListenerFiltersTimeout != false) hash ^= ContinueOnListenerFiltersTimeout.GetHashCode();
      if (transparent_ != null) hash ^= Transparent.GetHashCode();
      if (freebind_ != null) hash ^= Freebind.GetHashCode();
      hash ^= socketOptions_.GetHashCode();
      if (tcpFastOpenQueueLength_ != null) hash ^= TcpFastOpenQueueLength.GetHashCode();
      if (TrafficDirection != global::Envoy.Api.V2.Core.TrafficDirection.Unspecified) hash ^= TrafficDirection.GetHashCode();
      if (udpListenerConfig_ != null) hash ^= UdpListenerConfig.GetHashCode();
      if (apiListener_ != null) hash ^= ApiListener.GetHashCode();
      if (connectionBalanceConfig_ != null) hash ^= ConnectionBalanceConfig.GetHashCode();
      if (ReusePort != false) hash ^= ReusePort.GetHashCode();
      hash ^= accessLog_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (address_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Address);
      }
      filterChains_.WriteTo(output, _repeated_filterChains_codec);
      if (useOriginalDst_ != null) {
        _single_useOriginalDst_codec.WriteTagAndValue(output, UseOriginalDst);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        _single_perConnectionBufferLimitBytes_codec.WriteTagAndValue(output, PerConnectionBufferLimitBytes);
      }
      if (metadata_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Metadata);
      }
      if (deprecatedV1_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DeprecatedV1);
      }
      if (DrainType != global::Envoy.Api.V2.Listener.Types.DrainType.Default) {
        output.WriteRawTag(64);
        output.WriteEnum((int) DrainType);
      }
      listenerFilters_.WriteTo(output, _repeated_listenerFilters_codec);
      if (transparent_ != null) {
        _single_transparent_codec.WriteTagAndValue(output, Transparent);
      }
      if (freebind_ != null) {
        _single_freebind_codec.WriteTagAndValue(output, Freebind);
      }
      if (tcpFastOpenQueueLength_ != null) {
        _single_tcpFastOpenQueueLength_codec.WriteTagAndValue(output, TcpFastOpenQueueLength);
      }
      socketOptions_.WriteTo(output, _repeated_socketOptions_codec);
      if (listenerFiltersTimeout_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(ListenerFiltersTimeout);
      }
      if (TrafficDirection != global::Envoy.Api.V2.Core.TrafficDirection.Unspecified) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) TrafficDirection);
      }
      if (ContinueOnListenerFiltersTimeout != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(ContinueOnListenerFiltersTimeout);
      }
      if (udpListenerConfig_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(UdpListenerConfig);
      }
      if (apiListener_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ApiListener);
      }
      if (connectionBalanceConfig_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(ConnectionBalanceConfig);
      }
      if (ReusePort != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(ReusePort);
      }
      accessLog_.WriteTo(output, _repeated_accessLog_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (address_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Address);
      }
      filterChains_.WriteTo(ref output, _repeated_filterChains_codec);
      if (useOriginalDst_ != null) {
        _single_useOriginalDst_codec.WriteTagAndValue(ref output, UseOriginalDst);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        _single_perConnectionBufferLimitBytes_codec.WriteTagAndValue(ref output, PerConnectionBufferLimitBytes);
      }
      if (metadata_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Metadata);
      }
      if (deprecatedV1_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DeprecatedV1);
      }
      if (DrainType != global::Envoy.Api.V2.Listener.Types.DrainType.Default) {
        output.WriteRawTag(64);
        output.WriteEnum((int) DrainType);
      }
      listenerFilters_.WriteTo(ref output, _repeated_listenerFilters_codec);
      if (transparent_ != null) {
        _single_transparent_codec.WriteTagAndValue(ref output, Transparent);
      }
      if (freebind_ != null) {
        _single_freebind_codec.WriteTagAndValue(ref output, Freebind);
      }
      if (tcpFastOpenQueueLength_ != null) {
        _single_tcpFastOpenQueueLength_codec.WriteTagAndValue(ref output, TcpFastOpenQueueLength);
      }
      socketOptions_.WriteTo(ref output, _repeated_socketOptions_codec);
      if (listenerFiltersTimeout_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(ListenerFiltersTimeout);
      }
      if (TrafficDirection != global::Envoy.Api.V2.Core.TrafficDirection.Unspecified) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) TrafficDirection);
      }
      if (ContinueOnListenerFiltersTimeout != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(ContinueOnListenerFiltersTimeout);
      }
      if (udpListenerConfig_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(UdpListenerConfig);
      }
      if (apiListener_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ApiListener);
      }
      if (connectionBalanceConfig_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(ConnectionBalanceConfig);
      }
      if (ReusePort != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(ReusePort);
      }
      accessLog_.WriteTo(ref output, _repeated_accessLog_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (address_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Address);
      }
      size += filterChains_.CalculateSize(_repeated_filterChains_codec);
      if (useOriginalDst_ != null) {
        size += _single_useOriginalDst_codec.CalculateSizeWithTag(UseOriginalDst);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        size += _single_perConnectionBufferLimitBytes_codec.CalculateSizeWithTag(PerConnectionBufferLimitBytes);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (deprecatedV1_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeprecatedV1);
      }
      if (DrainType != global::Envoy.Api.V2.Listener.Types.DrainType.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DrainType);
      }
      size += listenerFilters_.CalculateSize(_repeated_listenerFilters_codec);
      if (listenerFiltersTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ListenerFiltersTimeout);
      }
      if (ContinueOnListenerFiltersTimeout != false) {
        size += 2 + 1;
      }
      if (transparent_ != null) {
        size += _single_transparent_codec.CalculateSizeWithTag(Transparent);
      }
      if (freebind_ != null) {
        size += _single_freebind_codec.CalculateSizeWithTag(Freebind);
      }
      size += socketOptions_.CalculateSize(_repeated_socketOptions_codec);
      if (tcpFastOpenQueueLength_ != null) {
        size += _single_tcpFastOpenQueueLength_codec.CalculateSizeWithTag(TcpFastOpenQueueLength);
      }
      if (TrafficDirection != global::Envoy.Api.V2.Core.TrafficDirection.Unspecified) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) TrafficDirection);
      }
      if (udpListenerConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UdpListenerConfig);
      }
      if (apiListener_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ApiListener);
      }
      if (connectionBalanceConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ConnectionBalanceConfig);
      }
      if (ReusePort != false) {
        size += 2 + 1;
      }
      size += accessLog_.CalculateSize(_repeated_accessLog_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Listener other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.address_ != null) {
        if (address_ == null) {
          Address = new global::Envoy.Api.V2.Core.Address();
        }
        Address.MergeFrom(other.Address);
      }
      filterChains_.Add(other.filterChains_);
      if (other.useOriginalDst_ != null) {
        if (useOriginalDst_ == null || other.UseOriginalDst != false) {
          UseOriginalDst = other.UseOriginalDst;
        }
      }
      if (other.perConnectionBufferLimitBytes_ != null) {
        if (perConnectionBufferLimitBytes_ == null || other.PerConnectionBufferLimitBytes != 0) {
          PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
        }
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::Envoy.Api.V2.Core.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.deprecatedV1_ != null) {
        if (deprecatedV1_ == null) {
          DeprecatedV1 = new global::Envoy.Api.V2.Listener.Types.DeprecatedV1();
        }
        DeprecatedV1.MergeFrom(other.DeprecatedV1);
      }
      if (other.DrainType != global::Envoy.Api.V2.Listener.Types.DrainType.Default) {
        DrainType = other.DrainType;
      }
      listenerFilters_.Add(other.listenerFilters_);
      if (other.listenerFiltersTimeout_ != null) {
        if (listenerFiltersTimeout_ == null) {
          ListenerFiltersTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        ListenerFiltersTimeout.MergeFrom(other.ListenerFiltersTimeout);
      }
      if (other.ContinueOnListenerFiltersTimeout != false) {
        ContinueOnListenerFiltersTimeout = other.ContinueOnListenerFiltersTimeout;
      }
      if (other.transparent_ != null) {
        if (transparent_ == null || other.Transparent != false) {
          Transparent = other.Transparent;
        }
      }
      if (other.freebind_ != null) {
        if (freebind_ == null || other.Freebind != false) {
          Freebind = other.Freebind;
        }
      }
      socketOptions_.Add(other.socketOptions_);
      if (other.tcpFastOpenQueueLength_ != null) {
        if (tcpFastOpenQueueLength_ == null || other.TcpFastOpenQueueLength != 0) {
          TcpFastOpenQueueLength = other.TcpFastOpenQueueLength;
        }
      }
      if (other.TrafficDirection != global::Envoy.Api.V2.Core.TrafficDirection.Unspecified) {
        TrafficDirection = other.TrafficDirection;
      }
      if (other.udpListenerConfig_ != null) {
        if (udpListenerConfig_ == null) {
          UdpListenerConfig = new global::Envoy.Api.V2.ListenerNS.UdpListenerConfig();
        }
        UdpListenerConfig.MergeFrom(other.UdpListenerConfig);
      }
      if (other.apiListener_ != null) {
        if (apiListener_ == null) {
          ApiListener = new global::Envoy.Config.Listener.V2.ApiListener();
        }
        ApiListener.MergeFrom(other.ApiListener);
      }
      if (other.connectionBalanceConfig_ != null) {
        if (connectionBalanceConfig_ == null) {
          ConnectionBalanceConfig = new global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig();
        }
        ConnectionBalanceConfig.MergeFrom(other.ConnectionBalanceConfig);
      }
      if (other.ReusePort != false) {
        ReusePort = other.ReusePort;
      }
      accessLog_.Add(other.accessLog_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (address_ == null) {
              Address = new global::Envoy.Api.V2.Core.Address();
            }
            input.ReadMessage(Address);
            break;
          }
          case 26: {
            filterChains_.AddEntriesFrom(input, _repeated_filterChains_codec);
            break;
          }
          case 34: {
            bool? value = _single_useOriginalDst_codec.Read(input);
            if (useOriginalDst_ == null || value != false) {
              UseOriginalDst = value;
            }
            break;
          }
          case 42: {
            uint? value = _single_perConnectionBufferLimitBytes_codec.Read(input);
            if (perConnectionBufferLimitBytes_ == null || value != 0) {
              PerConnectionBufferLimitBytes = value;
            }
            break;
          }
          case 50: {
            if (metadata_ == null) {
              Metadata = new global::Envoy.Api.V2.Core.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 58: {
            if (deprecatedV1_ == null) {
              DeprecatedV1 = new global::Envoy.Api.V2.Listener.Types.DeprecatedV1();
            }
            input.ReadMessage(DeprecatedV1);
            break;
          }
          case 64: {
            DrainType = (global::Envoy.Api.V2.Listener.Types.DrainType) input.ReadEnum();
            break;
          }
          case 74: {
            listenerFilters_.AddEntriesFrom(input, _repeated_listenerFilters_codec);
            break;
          }
          case 82: {
            bool? value = _single_transparent_codec.Read(input);
            if (transparent_ == null || value != false) {
              Transparent = value;
            }
            break;
          }
          case 90: {
            bool? value = _single_freebind_codec.Read(input);
            if (freebind_ == null || value != false) {
              Freebind = value;
            }
            break;
          }
          case 98: {
            uint? value = _single_tcpFastOpenQueueLength_codec.Read(input);
            if (tcpFastOpenQueueLength_ == null || value != 0) {
              TcpFastOpenQueueLength = value;
            }
            break;
          }
          case 106: {
            socketOptions_.AddEntriesFrom(input, _repeated_socketOptions_codec);
            break;
          }
          case 122: {
            if (listenerFiltersTimeout_ == null) {
              ListenerFiltersTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(ListenerFiltersTimeout);
            break;
          }
          case 128: {
            TrafficDirection = (global::Envoy.Api.V2.Core.TrafficDirection) input.ReadEnum();
            break;
          }
          case 136: {
            ContinueOnListenerFiltersTimeout = input.ReadBool();
            break;
          }
          case 146: {
            if (udpListenerConfig_ == null) {
              UdpListenerConfig = new global::Envoy.Api.V2.ListenerNS.UdpListenerConfig();
            }
            input.ReadMessage(UdpListenerConfig);
            break;
          }
          case 154: {
            if (apiListener_ == null) {
              ApiListener = new global::Envoy.Config.Listener.V2.ApiListener();
            }
            input.ReadMessage(ApiListener);
            break;
          }
          case 162: {
            if (connectionBalanceConfig_ == null) {
              ConnectionBalanceConfig = new global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig();
            }
            input.ReadMessage(ConnectionBalanceConfig);
            break;
          }
          case 168: {
            ReusePort = input.ReadBool();
            break;
          }
          case 178: {
            accessLog_.AddEntriesFrom(input, _repeated_accessLog_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (address_ == null) {
              Address = new global::Envoy.Api.V2.Core.Address();
            }
            input.ReadMessage(Address);
            break;
          }
          case 26: {
            filterChains_.AddEntriesFrom(ref input, _repeated_filterChains_codec);
            break;
          }
          case 34: {
            bool? value = _single_useOriginalDst_codec.Read(ref input);
            if (useOriginalDst_ == null || value != false) {
              UseOriginalDst = value;
            }
            break;
          }
          case 42: {
            uint? value = _single_perConnectionBufferLimitBytes_codec.Read(ref input);
            if (perConnectionBufferLimitBytes_ == null || value != 0) {
              PerConnectionBufferLimitBytes = value;
            }
            break;
          }
          case 50: {
            if (metadata_ == null) {
              Metadata = new global::Envoy.Api.V2.Core.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 58: {
            if (deprecatedV1_ == null) {
              DeprecatedV1 = new global::Envoy.Api.V2.Listener.Types.DeprecatedV1();
            }
            input.ReadMessage(DeprecatedV1);
            break;
          }
          case 64: {
            DrainType = (global::Envoy.Api.V2.Listener.Types.DrainType) input.ReadEnum();
            break;
          }
          case 74: {
            listenerFilters_.AddEntriesFrom(ref input, _repeated_listenerFilters_codec);
            break;
          }
          case 82: {
            bool? value = _single_transparent_codec.Read(ref input);
            if (transparent_ == null || value != false) {
              Transparent = value;
            }
            break;
          }
          case 90: {
            bool? value = _single_freebind_codec.Read(ref input);
            if (freebind_ == null || value != false) {
              Freebind = value;
            }
            break;
          }
          case 98: {
            uint? value = _single_tcpFastOpenQueueLength_codec.Read(ref input);
            if (tcpFastOpenQueueLength_ == null || value != 0) {
              TcpFastOpenQueueLength = value;
            }
            break;
          }
          case 106: {
            socketOptions_.AddEntriesFrom(ref input, _repeated_socketOptions_codec);
            break;
          }
          case 122: {
            if (listenerFiltersTimeout_ == null) {
              ListenerFiltersTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(ListenerFiltersTimeout);
            break;
          }
          case 128: {
            TrafficDirection = (global::Envoy.Api.V2.Core.TrafficDirection) input.ReadEnum();
            break;
          }
          case 136: {
            ContinueOnListenerFiltersTimeout = input.ReadBool();
            break;
          }
          case 146: {
            if (udpListenerConfig_ == null) {
              UdpListenerConfig = new global::Envoy.Api.V2.ListenerNS.UdpListenerConfig();
            }
            input.ReadMessage(UdpListenerConfig);
            break;
          }
          case 154: {
            if (apiListener_ == null) {
              ApiListener = new global::Envoy.Config.Listener.V2.ApiListener();
            }
            input.ReadMessage(ApiListener);
            break;
          }
          case 162: {
            if (connectionBalanceConfig_ == null) {
              ConnectionBalanceConfig = new global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig();
            }
            input.ReadMessage(ConnectionBalanceConfig);
            break;
          }
          case 168: {
            ReusePort = input.ReadBool();
            break;
          }
          case 178: {
            accessLog_.AddEntriesFrom(ref input, _repeated_accessLog_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Listener message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum DrainType {
        /// <summary>
        /// Drain in response to calling /healthcheck/fail admin endpoint (along with the health check
        /// filter), listener removal/modification, and hot restart.
        /// </summary>
        [pbr::OriginalName("DEFAULT")] Default = 0,
        /// <summary>
        /// Drain in response to listener removal/modification and hot restart. This setting does not
        /// include /healthcheck/fail. This setting may be desirable if Envoy is hosting both ingress
        /// and egress listeners.
        /// </summary>
        [pbr::OriginalName("MODIFY_ONLY")] ModifyOnly = 1,
      }

      /// <summary>
      /// [#not-implemented-hide:]
      /// </summary>
      public sealed partial class DeprecatedV1 : pb::IMessage<DeprecatedV1>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<DeprecatedV1> _parser = new pb::MessageParser<DeprecatedV1>(() => new DeprecatedV1());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<DeprecatedV1> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Listener.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DeprecatedV1() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DeprecatedV1(DeprecatedV1 other) : this() {
          BindToPort = other.BindToPort;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DeprecatedV1 Clone() {
          return new DeprecatedV1(this);
        }

        /// <summary>Field number for the "bind_to_port" field.</summary>
        public const int BindToPortFieldNumber = 1;
        private static readonly pb::FieldCodec<bool?> _single_bindToPort_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
        private bool? bindToPort_;
        /// <summary>
        /// Whether the listener should bind to the port. A listener that doesn't
        /// bind can only receive connections redirected from other listeners that
        /// set use_original_dst parameter to true. Default is true.
        ///
        /// This is deprecated in v2, all Listeners will bind to their port. An
        /// additional filter chain must be created for every original destination
        /// port this listener may redirect to in v2, with the original port
        /// specified in the FilterChainMatch destination_port field.
        ///
        /// [#comment:TODO(PiotrSikora): Remove this once verified that we no longer need it.]
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool? BindToPort {
          get { return bindToPort_; }
          set {
            bindToPort_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as DeprecatedV1);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(DeprecatedV1 other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (BindToPort != other.BindToPort) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (bindToPort_ != null) hash ^= BindToPort.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (bindToPort_ != null) {
            _single_bindToPort_codec.WriteTagAndValue(output, BindToPort);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (bindToPort_ != null) {
            _single_bindToPort_codec.WriteTagAndValue(ref output, BindToPort);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (bindToPort_ != null) {
            size += _single_bindToPort_codec.CalculateSizeWithTag(BindToPort);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(DeprecatedV1 other) {
          if (other == null) {
            return;
          }
          if (other.bindToPort_ != null) {
            if (bindToPort_ == null || other.BindToPort != false) {
              BindToPort = other.BindToPort;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                bool? value = _single_bindToPort_codec.Read(input);
                if (bindToPort_ == null || value != false) {
                  BindToPort = value;
                }
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                bool? value = _single_bindToPort_codec.Read(ref input);
                if (bindToPort_ == null || value != false) {
                  BindToPort = value;
                }
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Configuration for listener connection balancing.
      /// </summary>
      public sealed partial class ConnectionBalanceConfig : pb::IMessage<ConnectionBalanceConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ConnectionBalanceConfig> _parser = new pb::MessageParser<ConnectionBalanceConfig>(() => new ConnectionBalanceConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ConnectionBalanceConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Listener.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConnectionBalanceConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConnectionBalanceConfig(ConnectionBalanceConfig other) : this() {
          switch (other.BalanceTypeCase) {
            case BalanceTypeOneofCase.ExactBalance:
              ExactBalance = other.ExactBalance.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConnectionBalanceConfig Clone() {
          return new ConnectionBalanceConfig(this);
        }

        /// <summary>Field number for the "exact_balance" field.</summary>
        public const int ExactBalanceFieldNumber = 1;
        /// <summary>
        /// If specified, the listener will use the exact connection balancer.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance ExactBalance {
          get { return balanceTypeCase_ == BalanceTypeOneofCase.ExactBalance ? (global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance) balanceType_ : null; }
          set {
            balanceType_ = value;
            balanceTypeCase_ = value == null ? BalanceTypeOneofCase.None : BalanceTypeOneofCase.ExactBalance;
          }
        }

        private object balanceType_;
        /// <summary>Enum of possible cases for the "balance_type" oneof.</summary>
        public enum BalanceTypeOneofCase {
          None = 0,
          ExactBalance = 1,
        }
        private BalanceTypeOneofCase balanceTypeCase_ = BalanceTypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BalanceTypeOneofCase BalanceTypeCase {
          get { return balanceTypeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearBalanceType() {
          balanceTypeCase_ = BalanceTypeOneofCase.None;
          balanceType_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ConnectionBalanceConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ConnectionBalanceConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(ExactBalance, other.ExactBalance)) return false;
          if (BalanceTypeCase != other.BalanceTypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (balanceTypeCase_ == BalanceTypeOneofCase.ExactBalance) hash ^= ExactBalance.GetHashCode();
          hash ^= (int) balanceTypeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (balanceTypeCase_ == BalanceTypeOneofCase.ExactBalance) {
            output.WriteRawTag(10);
            output.WriteMessage(ExactBalance);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (balanceTypeCase_ == BalanceTypeOneofCase.ExactBalance) {
            output.WriteRawTag(10);
            output.WriteMessage(ExactBalance);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (balanceTypeCase_ == BalanceTypeOneofCase.ExactBalance) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExactBalance);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ConnectionBalanceConfig other) {
          if (other == null) {
            return;
          }
          switch (other.BalanceTypeCase) {
            case BalanceTypeOneofCase.ExactBalance:
              if (ExactBalance == null) {
                ExactBalance = new global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance();
              }
              ExactBalance.MergeFrom(other.ExactBalance);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance subBuilder = new global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance();
                if (balanceTypeCase_ == BalanceTypeOneofCase.ExactBalance) {
                  subBuilder.MergeFrom(ExactBalance);
                }
                input.ReadMessage(subBuilder);
                ExactBalance = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance subBuilder = new global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance();
                if (balanceTypeCase_ == BalanceTypeOneofCase.ExactBalance) {
                  subBuilder.MergeFrom(ExactBalance);
                }
                input.ReadMessage(subBuilder);
                ExactBalance = subBuilder;
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the ConnectionBalanceConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// A connection balancer implementation that does exact balancing. This means that a lock is
          /// held during balancing so that connection counts are nearly exactly balanced between worker
          /// threads. This is "nearly" exact in the sense that a connection might close in parallel thus
          /// making the counts incorrect, but this should be rectified on the next accept. This balancer
          /// sacrifices accept throughput for accuracy and should be used when there are a small number of
          /// connections that rarely cycle (e.g., service mesh gRPC egress).
          /// </summary>
          public sealed partial class ExactBalance : pb::IMessage<ExactBalance>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<ExactBalance> _parser = new pb::MessageParser<ExactBalance>(() => new ExactBalance());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<ExactBalance> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Listener.Types.ConnectionBalanceConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ExactBalance() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ExactBalance(ExactBalance other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ExactBalance Clone() {
              return new ExactBalance(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as ExactBalance);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(ExactBalance other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(ExactBalance other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
