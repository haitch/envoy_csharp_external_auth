// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/core/v3/config_source.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Core.V3 {

  /// <summary>Holder for reflection information generated from envoy/config/core/v3/config_source.proto</summary>
  public static partial class ConfigSourceReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/core/v3/config_source.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ConfigSourceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CihlbnZveS9jb25maWcvY29yZS92My9jb25maWdfc291cmNlLnByb3RvEhRl",
            "bnZveS5jb25maWcuY29yZS52MxonZW52b3kvY29uZmlnL2NvcmUvdjMvZ3Jw",
            "Y19zZXJ2aWNlLnByb3RvGh5nb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJv",
            "dG8aHmdvb2dsZS9wcm90b2J1Zi93cmFwcGVycy5wcm90bxobeGRzL2NvcmUv",
            "djMvYXV0aG9yaXR5LnByb3RvGiNlbnZveS9hbm5vdGF0aW9ucy9kZXByZWNh",
            "dGlvbi5wcm90bxoddWRwYS9hbm5vdGF0aW9ucy9zdGF0dXMucHJvdG8aIXVk",
            "cGEvYW5ub3RhdGlvbnMvdmVyc2lvbmluZy5wcm90bxoXdmFsaWRhdGUvdmFs",
            "aWRhdGUucHJvdG8ilQUKD0FwaUNvbmZpZ1NvdXJjZRJJCghhcGlfdHlwZRgB",
            "IAEoDjItLmVudm95LmNvbmZpZy5jb3JlLnYzLkFwaUNvbmZpZ1NvdXJjZS5B",
            "cGlUeXBlQgj6QgWCAQIQARJJChV0cmFuc3BvcnRfYXBpX3ZlcnNpb24YCCAB",
            "KA4yIC5lbnZveS5jb25maWcuY29yZS52My5BcGlWZXJzaW9uQgj6QgWCAQIQ",
            "ARIVCg1jbHVzdGVyX25hbWVzGAIgAygJEjgKDWdycGNfc2VydmljZXMYBCAD",
            "KAsyIS5lbnZveS5jb25maWcuY29yZS52My5HcnBjU2VydmljZRIwCg1yZWZy",
            "ZXNoX2RlbGF5GAMgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjwK",
            "D3JlcXVlc3RfdGltZW91dBgFIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJh",
            "dGlvbkII+kIFqgECKgASRAoTcmF0ZV9saW1pdF9zZXR0aW5ncxgGIAEoCzIn",
            "LmVudm95LmNvbmZpZy5jb3JlLnYzLlJhdGVMaW1pdFNldHRpbmdzEiYKHnNl",
            "dF9ub2RlX29uX2ZpcnN0X21lc3NhZ2Vfb25seRgHIAEoCCKSAQoHQXBpVHlw",
            "ZRIzCiVERVBSRUNBVEVEX0FORF9VTkFWQUlMQUJMRV9ET19OT1RfVVNFEAAa",
            "CAgBqPe0iwIBEggKBFJFU1QQARIICgRHUlBDEAISDgoKREVMVEFfR1JQQxAD",
            "EhMKD0FHR1JFR0FURURfR1JQQxAFEhkKFUFHR1JFR0FURURfREVMVEFfR1JQ",
            "QxAGOiiaxYgeIwohZW52b3kuYXBpLnYyLmNvcmUuQXBpQ29uZmlnU291cmNl",
            "IkkKFkFnZ3JlZ2F0ZWRDb25maWdTb3VyY2U6L5rFiB4qCihlbnZveS5hcGku",
            "djIuY29yZS5BZ2dyZWdhdGVkQ29uZmlnU291cmNlIogBChBTZWxmQ29uZmln",
            "U291cmNlEkkKFXRyYW5zcG9ydF9hcGlfdmVyc2lvbhgBIAEoDjIgLmVudm95",
            "LmNvbmZpZy5jb3JlLnYzLkFwaVZlcnNpb25CCPpCBYIBAhABOimaxYgeJAoi",
            "ZW52b3kuYXBpLnYyLmNvcmUuU2VsZkNvbmZpZ1NvdXJjZSKyAQoRUmF0ZUxp",
            "bWl0U2V0dGluZ3MSMAoKbWF4X3Rva2VucxgBIAEoCzIcLmdvb2dsZS5wcm90",
            "b2J1Zi5VSW50MzJWYWx1ZRI/CglmaWxsX3JhdGUYAiABKAsyHC5nb29nbGUu",
            "cHJvdG9idWYuRG91YmxlVmFsdWVCDvpCCxIJIQAAAAAAAAAAOiqaxYgeJQoj",
            "ZW52b3kuYXBpLnYyLmNvcmUuUmF0ZUxpbWl0U2V0dGluZ3MizwMKDENvbmZp",
            "Z1NvdXJjZRIrCgthdXRob3JpdGllcxgHIAMoCzIWLnhkcy5jb3JlLnYzLkF1",
            "dGhvcml0eRIOCgRwYXRoGAEgASgJSAASQgoRYXBpX2NvbmZpZ19zb3VyY2UY",
            "AiABKAsyJS5lbnZveS5jb25maWcuY29yZS52My5BcGlDb25maWdTb3VyY2VI",
            "ABI7CgNhZHMYAyABKAsyLC5lbnZveS5jb25maWcuY29yZS52My5BZ2dyZWdh",
            "dGVkQ29uZmlnU291cmNlSAASNgoEc2VsZhgFIAEoCzImLmVudm95LmNvbmZp",
            "Zy5jb3JlLnYzLlNlbGZDb25maWdTb3VyY2VIABI4ChVpbml0aWFsX2ZldGNo",
            "X3RpbWVvdXQYBCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SSAoU",
            "cmVzb3VyY2VfYXBpX3ZlcnNpb24YBiABKA4yIC5lbnZveS5jb25maWcuY29y",
            "ZS52My5BcGlWZXJzaW9uQgj6QgWCAQIQATolmsWIHiAKHmVudm95LmFwaS52",
            "Mi5jb3JlLkNvbmZpZ1NvdXJjZUIeChdjb25maWdfc291cmNlX3NwZWNpZmll",
            "chID+EIBKkAKCkFwaVZlcnNpb24SFQoEQVVUTxAAGgsIAYr0m7MFAzMuMBIT",
            "CgJWMhABGgsIAYr0m7MFAzMuMBIGCgJWMxACQkEKImlvLmVudm95cHJveHku",
            "ZW52b3kuY29uZmlnLmNvcmUudjNCEUNvbmZpZ1NvdXJjZVByb3RvUAG6gMjR",
            "BgIQAmIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Core.V3.GrpcServiceReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Xds.Core.V3.AuthorityReflection.Descriptor, global::Envoy.Annotations.DeprecationReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Envoy.Config.Core.V3.ApiVersion), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.ApiConfigSource), global::Envoy.Config.Core.V3.ApiConfigSource.Parser, new[]{ "ApiType", "TransportApiVersion", "ClusterNames", "GrpcServices", "RefreshDelay", "RequestTimeout", "RateLimitSettings", "SetNodeOnFirstMessageOnly" }, null, new[]{ typeof(global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.AggregatedConfigSource), global::Envoy.Config.Core.V3.AggregatedConfigSource.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.SelfConfigSource), global::Envoy.Config.Core.V3.SelfConfigSource.Parser, new[]{ "TransportApiVersion" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.RateLimitSettings), global::Envoy.Config.Core.V3.RateLimitSettings.Parser, new[]{ "MaxTokens", "FillRate" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.ConfigSource), global::Envoy.Config.Core.V3.ConfigSource.Parser, new[]{ "Authorities", "Path", "ApiConfigSource", "Ads", "Self", "InitialFetchTimeout", "ResourceApiVersion" }, new[]{ "ConfigSourceSpecifier" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// xDS API and non-xDS services version. This is used to describe both resource and transport
  /// protocol versions (in distinct configuration fields).
  /// </summary>
  public enum ApiVersion {
    /// <summary>
    /// When not specified, we assume v2, to ease migration to Envoy's stable API
    /// versioning. If a client does not support v2 (e.g. due to deprecation), this
    /// is an invalid value.
    /// </summary>
    [pbr::OriginalName("AUTO")] Auto = 0,
    /// <summary>
    /// Use xDS v2 API.
    /// </summary>
    [pbr::OriginalName("V2")] V2 = 1,
    /// <summary>
    /// Use xDS v3 API.
    /// </summary>
    [pbr::OriginalName("V3")] V3 = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// API configuration source. This identifies the API type and cluster that Envoy
  /// will use to fetch an xDS API.
  /// [#next-free-field: 9]
  /// </summary>
  public sealed partial class ApiConfigSource : pb::IMessage<ApiConfigSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ApiConfigSource> _parser = new pb::MessageParser<ApiConfigSource>(() => new ApiConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ApiConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ApiConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ApiConfigSource(ApiConfigSource other) : this() {
      apiType_ = other.apiType_;
      transportApiVersion_ = other.transportApiVersion_;
      clusterNames_ = other.clusterNames_.Clone();
      grpcServices_ = other.grpcServices_.Clone();
      refreshDelay_ = other.refreshDelay_ != null ? other.refreshDelay_.Clone() : null;
      requestTimeout_ = other.requestTimeout_ != null ? other.requestTimeout_.Clone() : null;
      rateLimitSettings_ = other.rateLimitSettings_ != null ? other.rateLimitSettings_.Clone() : null;
      setNodeOnFirstMessageOnly_ = other.setNodeOnFirstMessageOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ApiConfigSource Clone() {
      return new ApiConfigSource(this);
    }

    /// <summary>Field number for the "api_type" field.</summary>
    public const int ApiTypeFieldNumber = 1;
    private global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType apiType_ = global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType.DeprecatedAndUnavailableDoNotUse;
    /// <summary>
    /// API type (gRPC, REST, delta gRPC)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType ApiType {
      get { return apiType_; }
      set {
        apiType_ = value;
      }
    }

    /// <summary>Field number for the "transport_api_version" field.</summary>
    public const int TransportApiVersionFieldNumber = 8;
    private global::Envoy.Config.Core.V3.ApiVersion transportApiVersion_ = global::Envoy.Config.Core.V3.ApiVersion.Auto;
    /// <summary>
    /// API version for xDS transport protocol. This describes the xDS gRPC/REST
    /// endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ApiVersion TransportApiVersion {
      get { return transportApiVersion_; }
      set {
        transportApiVersion_ = value;
      }
    }

    /// <summary>Field number for the "cluster_names" field.</summary>
    public const int ClusterNamesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_clusterNames_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> clusterNames_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Cluster names should be used only with REST. If > 1
    /// cluster is defined, clusters will be cycled through if any kind of failure
    /// occurs.
    ///
    /// .. note::
    ///
    ///  The cluster with name ``cluster_name`` must be statically defined and its
    ///  type must not be ``EDS``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> ClusterNames {
      get { return clusterNames_; }
    }

    /// <summary>Field number for the "grpc_services" field.</summary>
    public const int GrpcServicesFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.GrpcService> _repeated_grpcServices_codec
        = pb::FieldCodec.ForMessage(34, global::Envoy.Config.Core.V3.GrpcService.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.GrpcService> grpcServices_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.GrpcService>();
    /// <summary>
    /// Multiple gRPC services be provided for GRPC. If > 1 cluster is defined,
    /// services will be cycled through if any kind of failure occurs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.GrpcService> GrpcServices {
      get { return grpcServices_; }
    }

    /// <summary>Field number for the "refresh_delay" field.</summary>
    public const int RefreshDelayFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration refreshDelay_;
    /// <summary>
    /// For REST APIs, the delay between successive polls.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration RefreshDelay {
      get { return refreshDelay_; }
      set {
        refreshDelay_ = value;
      }
    }

    /// <summary>Field number for the "request_timeout" field.</summary>
    public const int RequestTimeoutFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Duration requestTimeout_;
    /// <summary>
    /// For REST APIs, the request timeout. If not set, a default value of 1s will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration RequestTimeout {
      get { return requestTimeout_; }
      set {
        requestTimeout_ = value;
      }
    }

    /// <summary>Field number for the "rate_limit_settings" field.</summary>
    public const int RateLimitSettingsFieldNumber = 6;
    private global::Envoy.Config.Core.V3.RateLimitSettings rateLimitSettings_;
    /// <summary>
    /// For GRPC APIs, the rate limit settings. If present, discovery requests made by Envoy will be
    /// rate limited.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.RateLimitSettings RateLimitSettings {
      get { return rateLimitSettings_; }
      set {
        rateLimitSettings_ = value;
      }
    }

    /// <summary>Field number for the "set_node_on_first_message_only" field.</summary>
    public const int SetNodeOnFirstMessageOnlyFieldNumber = 7;
    private bool setNodeOnFirstMessageOnly_;
    /// <summary>
    /// Skip the node identifier in subsequent discovery requests for streaming gRPC config types.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SetNodeOnFirstMessageOnly {
      get { return setNodeOnFirstMessageOnly_; }
      set {
        setNodeOnFirstMessageOnly_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ApiConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ApiConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ApiType != other.ApiType) return false;
      if (TransportApiVersion != other.TransportApiVersion) return false;
      if(!clusterNames_.Equals(other.clusterNames_)) return false;
      if(!grpcServices_.Equals(other.grpcServices_)) return false;
      if (!object.Equals(RefreshDelay, other.RefreshDelay)) return false;
      if (!object.Equals(RequestTimeout, other.RequestTimeout)) return false;
      if (!object.Equals(RateLimitSettings, other.RateLimitSettings)) return false;
      if (SetNodeOnFirstMessageOnly != other.SetNodeOnFirstMessageOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ApiType != global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType.DeprecatedAndUnavailableDoNotUse) hash ^= ApiType.GetHashCode();
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) hash ^= TransportApiVersion.GetHashCode();
      hash ^= clusterNames_.GetHashCode();
      hash ^= grpcServices_.GetHashCode();
      if (refreshDelay_ != null) hash ^= RefreshDelay.GetHashCode();
      if (requestTimeout_ != null) hash ^= RequestTimeout.GetHashCode();
      if (rateLimitSettings_ != null) hash ^= RateLimitSettings.GetHashCode();
      if (SetNodeOnFirstMessageOnly != false) hash ^= SetNodeOnFirstMessageOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ApiType != global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType.DeprecatedAndUnavailableDoNotUse) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ApiType);
      }
      clusterNames_.WriteTo(output, _repeated_clusterNames_codec);
      if (refreshDelay_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(RefreshDelay);
      }
      grpcServices_.WriteTo(output, _repeated_grpcServices_codec);
      if (requestTimeout_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(RequestTimeout);
      }
      if (rateLimitSettings_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(RateLimitSettings);
      }
      if (SetNodeOnFirstMessageOnly != false) {
        output.WriteRawTag(56);
        output.WriteBool(SetNodeOnFirstMessageOnly);
      }
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        output.WriteRawTag(64);
        output.WriteEnum((int) TransportApiVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ApiType != global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType.DeprecatedAndUnavailableDoNotUse) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ApiType);
      }
      clusterNames_.WriteTo(ref output, _repeated_clusterNames_codec);
      if (refreshDelay_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(RefreshDelay);
      }
      grpcServices_.WriteTo(ref output, _repeated_grpcServices_codec);
      if (requestTimeout_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(RequestTimeout);
      }
      if (rateLimitSettings_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(RateLimitSettings);
      }
      if (SetNodeOnFirstMessageOnly != false) {
        output.WriteRawTag(56);
        output.WriteBool(SetNodeOnFirstMessageOnly);
      }
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        output.WriteRawTag(64);
        output.WriteEnum((int) TransportApiVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ApiType != global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType.DeprecatedAndUnavailableDoNotUse) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ApiType);
      }
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TransportApiVersion);
      }
      size += clusterNames_.CalculateSize(_repeated_clusterNames_codec);
      size += grpcServices_.CalculateSize(_repeated_grpcServices_codec);
      if (refreshDelay_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RefreshDelay);
      }
      if (requestTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequestTimeout);
      }
      if (rateLimitSettings_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RateLimitSettings);
      }
      if (SetNodeOnFirstMessageOnly != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ApiConfigSource other) {
      if (other == null) {
        return;
      }
      if (other.ApiType != global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType.DeprecatedAndUnavailableDoNotUse) {
        ApiType = other.ApiType;
      }
      if (other.TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        TransportApiVersion = other.TransportApiVersion;
      }
      clusterNames_.Add(other.clusterNames_);
      grpcServices_.Add(other.grpcServices_);
      if (other.refreshDelay_ != null) {
        if (refreshDelay_ == null) {
          RefreshDelay = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        RefreshDelay.MergeFrom(other.RefreshDelay);
      }
      if (other.requestTimeout_ != null) {
        if (requestTimeout_ == null) {
          RequestTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        RequestTimeout.MergeFrom(other.RequestTimeout);
      }
      if (other.rateLimitSettings_ != null) {
        if (rateLimitSettings_ == null) {
          RateLimitSettings = new global::Envoy.Config.Core.V3.RateLimitSettings();
        }
        RateLimitSettings.MergeFrom(other.RateLimitSettings);
      }
      if (other.SetNodeOnFirstMessageOnly != false) {
        SetNodeOnFirstMessageOnly = other.SetNodeOnFirstMessageOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ApiType = (global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType) input.ReadEnum();
            break;
          }
          case 18: {
            clusterNames_.AddEntriesFrom(input, _repeated_clusterNames_codec);
            break;
          }
          case 26: {
            if (refreshDelay_ == null) {
              RefreshDelay = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RefreshDelay);
            break;
          }
          case 34: {
            grpcServices_.AddEntriesFrom(input, _repeated_grpcServices_codec);
            break;
          }
          case 42: {
            if (requestTimeout_ == null) {
              RequestTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RequestTimeout);
            break;
          }
          case 50: {
            if (rateLimitSettings_ == null) {
              RateLimitSettings = new global::Envoy.Config.Core.V3.RateLimitSettings();
            }
            input.ReadMessage(RateLimitSettings);
            break;
          }
          case 56: {
            SetNodeOnFirstMessageOnly = input.ReadBool();
            break;
          }
          case 64: {
            TransportApiVersion = (global::Envoy.Config.Core.V3.ApiVersion) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ApiType = (global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType) input.ReadEnum();
            break;
          }
          case 18: {
            clusterNames_.AddEntriesFrom(ref input, _repeated_clusterNames_codec);
            break;
          }
          case 26: {
            if (refreshDelay_ == null) {
              RefreshDelay = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RefreshDelay);
            break;
          }
          case 34: {
            grpcServices_.AddEntriesFrom(ref input, _repeated_grpcServices_codec);
            break;
          }
          case 42: {
            if (requestTimeout_ == null) {
              RequestTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RequestTimeout);
            break;
          }
          case 50: {
            if (rateLimitSettings_ == null) {
              RateLimitSettings = new global::Envoy.Config.Core.V3.RateLimitSettings();
            }
            input.ReadMessage(RateLimitSettings);
            break;
          }
          case 56: {
            SetNodeOnFirstMessageOnly = input.ReadBool();
            break;
          }
          case 64: {
            TransportApiVersion = (global::Envoy.Config.Core.V3.ApiVersion) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ApiConfigSource message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// APIs may be fetched via either REST or gRPC.
      /// </summary>
      public enum ApiType {
        /// <summary>
        /// Ideally this would be 'reserved 0' but one can't reserve the default
        /// value. Instead we throw an exception if this is ever used.
        /// </summary>
        [pbr::OriginalName("DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE")] DeprecatedAndUnavailableDoNotUse = 0,
        /// <summary>
        /// REST-JSON v2 API. The `canonical JSON encoding
        /// &lt;https://developers.google.com/protocol-buffers/docs/proto3#json>`_ for
        /// the v2 protos is used.
        /// </summary>
        [pbr::OriginalName("REST")] Rest = 1,
        /// <summary>
        /// SotW gRPC service.
        /// </summary>
        [pbr::OriginalName("GRPC")] Grpc = 2,
        /// <summary>
        /// Using the delta xDS gRPC service, i.e. DeltaDiscovery{Request,Response}
        /// rather than Discovery{Request,Response}. Rather than sending Envoy the entire state
        /// with every update, the xDS server only sends what has changed since the last update.
        /// </summary>
        [pbr::OriginalName("DELTA_GRPC")] DeltaGrpc = 3,
        /// <summary>
        /// SotW xDS gRPC with ADS. All resources which resolve to this configuration source will be
        /// multiplexed on a single connection to an ADS endpoint.
        /// [#not-implemented-hide:]
        /// </summary>
        [pbr::OriginalName("AGGREGATED_GRPC")] AggregatedGrpc = 5,
        /// <summary>
        /// Delta xDS gRPC with ADS. All resources which resolve to this configuration source will be
        /// multiplexed on a single connection to an ADS endpoint.
        /// [#not-implemented-hide:]
        /// </summary>
        [pbr::OriginalName("AGGREGATED_DELTA_GRPC")] AggregatedDeltaGrpc = 6,
      }

    }
    #endregion

  }

  /// <summary>
  /// Aggregated Discovery Service (ADS) options. This is currently empty, but when
  /// set in :ref:`ConfigSource &lt;envoy_v3_api_msg_config.core.v3.ConfigSource>` can be used to
  /// specify that ADS is to be used.
  /// </summary>
  public sealed partial class AggregatedConfigSource : pb::IMessage<AggregatedConfigSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AggregatedConfigSource> _parser = new pb::MessageParser<AggregatedConfigSource>(() => new AggregatedConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AggregatedConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AggregatedConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AggregatedConfigSource(AggregatedConfigSource other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AggregatedConfigSource Clone() {
      return new AggregatedConfigSource(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AggregatedConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AggregatedConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AggregatedConfigSource other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#not-implemented-hide:]
  /// Self-referencing config source options. This is currently empty, but when
  /// set in :ref:`ConfigSource &lt;envoy_v3_api_msg_config.core.v3.ConfigSource>` can be used to
  /// specify that other data can be obtained from the same server.
  /// </summary>
  public sealed partial class SelfConfigSource : pb::IMessage<SelfConfigSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SelfConfigSource> _parser = new pb::MessageParser<SelfConfigSource>(() => new SelfConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SelfConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SelfConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SelfConfigSource(SelfConfigSource other) : this() {
      transportApiVersion_ = other.transportApiVersion_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SelfConfigSource Clone() {
      return new SelfConfigSource(this);
    }

    /// <summary>Field number for the "transport_api_version" field.</summary>
    public const int TransportApiVersionFieldNumber = 1;
    private global::Envoy.Config.Core.V3.ApiVersion transportApiVersion_ = global::Envoy.Config.Core.V3.ApiVersion.Auto;
    /// <summary>
    /// API version for xDS transport protocol. This describes the xDS gRPC/REST
    /// endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ApiVersion TransportApiVersion {
      get { return transportApiVersion_; }
      set {
        transportApiVersion_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SelfConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SelfConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TransportApiVersion != other.TransportApiVersion) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) hash ^= TransportApiVersion.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TransportApiVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TransportApiVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TransportApiVersion);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SelfConfigSource other) {
      if (other == null) {
        return;
      }
      if (other.TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        TransportApiVersion = other.TransportApiVersion;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            TransportApiVersion = (global::Envoy.Config.Core.V3.ApiVersion) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            TransportApiVersion = (global::Envoy.Config.Core.V3.ApiVersion) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Rate Limit settings to be applied for discovery requests made by Envoy.
  /// </summary>
  public sealed partial class RateLimitSettings : pb::IMessage<RateLimitSettings>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RateLimitSettings> _parser = new pb::MessageParser<RateLimitSettings>(() => new RateLimitSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RateLimitSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RateLimitSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RateLimitSettings(RateLimitSettings other) : this() {
      MaxTokens = other.MaxTokens;
      FillRate = other.FillRate;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RateLimitSettings Clone() {
      return new RateLimitSettings(this);
    }

    /// <summary>Field number for the "max_tokens" field.</summary>
    public const int MaxTokensFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_maxTokens_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? maxTokens_;
    /// <summary>
    /// Maximum number of tokens to be used for rate limiting discovery request calls. If not set, a
    /// default value of 100 will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxTokens {
      get { return maxTokens_; }
      set {
        maxTokens_ = value;
      }
    }


    /// <summary>Field number for the "fill_rate" field.</summary>
    public const int FillRateFieldNumber = 2;
    private static readonly pb::FieldCodec<double?> _single_fillRate_codec = pb::FieldCodec.ForStructWrapper<double>(18);
    private double? fillRate_;
    /// <summary>
    /// Rate at which tokens will be filled per second. If not set, a default fill rate of 10 tokens
    /// per second will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double? FillRate {
      get { return fillRate_; }
      set {
        fillRate_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RateLimitSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RateLimitSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MaxTokens != other.MaxTokens) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(FillRate, other.FillRate)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (maxTokens_ != null) hash ^= MaxTokens.GetHashCode();
      if (fillRate_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(FillRate);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (maxTokens_ != null) {
        _single_maxTokens_codec.WriteTagAndValue(output, MaxTokens);
      }
      if (fillRate_ != null) {
        _single_fillRate_codec.WriteTagAndValue(output, FillRate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (maxTokens_ != null) {
        _single_maxTokens_codec.WriteTagAndValue(ref output, MaxTokens);
      }
      if (fillRate_ != null) {
        _single_fillRate_codec.WriteTagAndValue(ref output, FillRate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (maxTokens_ != null) {
        size += _single_maxTokens_codec.CalculateSizeWithTag(MaxTokens);
      }
      if (fillRate_ != null) {
        size += _single_fillRate_codec.CalculateSizeWithTag(FillRate);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RateLimitSettings other) {
      if (other == null) {
        return;
      }
      if (other.maxTokens_ != null) {
        if (maxTokens_ == null || other.MaxTokens != 0) {
          MaxTokens = other.MaxTokens;
        }
      }
      if (other.fillRate_ != null) {
        if (fillRate_ == null || other.FillRate != 0D) {
          FillRate = other.FillRate;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_maxTokens_codec.Read(input);
            if (maxTokens_ == null || value != 0) {
              MaxTokens = value;
            }
            break;
          }
          case 18: {
            double? value = _single_fillRate_codec.Read(input);
            if (fillRate_ == null || value != 0D) {
              FillRate = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            uint? value = _single_maxTokens_codec.Read(ref input);
            if (maxTokens_ == null || value != 0) {
              MaxTokens = value;
            }
            break;
          }
          case 18: {
            double? value = _single_fillRate_codec.Read(ref input);
            if (fillRate_ == null || value != 0D) {
              FillRate = value;
            }
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configuration for :ref:`listeners &lt;config_listeners>`, :ref:`clusters
  /// &lt;config_cluster_manager>`, :ref:`routes
  /// &lt;envoy_v3_api_msg_config.route.v3.RouteConfiguration>`, :ref:`endpoints
  /// &lt;arch_overview_service_discovery>` etc. may either be sourced from the
  /// filesystem or from an xDS API source. Filesystem configs are watched with
  /// inotify for updates.
  /// [#next-free-field: 8]
  /// </summary>
  public sealed partial class ConfigSource : pb::IMessage<ConfigSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ConfigSource> _parser = new pb::MessageParser<ConfigSource>(() => new ConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigSource(ConfigSource other) : this() {
      authorities_ = other.authorities_.Clone();
      initialFetchTimeout_ = other.initialFetchTimeout_ != null ? other.initialFetchTimeout_.Clone() : null;
      resourceApiVersion_ = other.resourceApiVersion_;
      switch (other.ConfigSourceSpecifierCase) {
        case ConfigSourceSpecifierOneofCase.Path:
          Path = other.Path;
          break;
        case ConfigSourceSpecifierOneofCase.ApiConfigSource:
          ApiConfigSource = other.ApiConfigSource.Clone();
          break;
        case ConfigSourceSpecifierOneofCase.Ads:
          Ads = other.Ads.Clone();
          break;
        case ConfigSourceSpecifierOneofCase.Self:
          Self = other.Self.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigSource Clone() {
      return new ConfigSource(this);
    }

    /// <summary>Field number for the "authorities" field.</summary>
    public const int AuthoritiesFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Xds.Core.V3.Authority> _repeated_authorities_codec
        = pb::FieldCodec.ForMessage(58, global::Xds.Core.V3.Authority.Parser);
    private readonly pbc::RepeatedField<global::Xds.Core.V3.Authority> authorities_ = new pbc::RepeatedField<global::Xds.Core.V3.Authority>();
    /// <summary>
    /// Authorities that this config source may be used for. An authority specified in a xdstp:// URL
    /// is resolved to a *ConfigSource* prior to configuration fetch. This field provides the
    /// association between authority name and configuration source.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Xds.Core.V3.Authority> Authorities {
      get { return authorities_; }
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    /// <summary>
    /// Path on the filesystem to source and watch for configuration updates.
    /// When sourcing configuration for :ref:`secret &lt;envoy_v3_api_msg_extensions.transport_sockets.tls.v3.Secret>`,
    /// the certificate and key files are also watched for updates.
    ///
    /// .. note::
    ///
    ///  The path to the source must exist at config load time.
    ///
    /// .. note::
    ///
    ///   Envoy will only watch the file path for *moves.* This is because in general only moves
    ///   are atomic. The same method of swapping files as is demonstrated in the
    ///   :ref:`runtime documentation &lt;config_runtime_symbolic_link_swap>` can be used here also.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Path ? (string) configSourceSpecifier_ : ""; }
      set {
        configSourceSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        configSourceSpecifierCase_ = ConfigSourceSpecifierOneofCase.Path;
      }
    }

    /// <summary>Field number for the "api_config_source" field.</summary>
    public const int ApiConfigSourceFieldNumber = 2;
    /// <summary>
    /// API configuration source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ApiConfigSource ApiConfigSource {
      get { return configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource ? (global::Envoy.Config.Core.V3.ApiConfigSource) configSourceSpecifier_ : null; }
      set {
        configSourceSpecifier_ = value;
        configSourceSpecifierCase_ = value == null ? ConfigSourceSpecifierOneofCase.None : ConfigSourceSpecifierOneofCase.ApiConfigSource;
      }
    }

    /// <summary>Field number for the "ads" field.</summary>
    public const int AdsFieldNumber = 3;
    /// <summary>
    /// When set, ADS will be used to fetch resources. The ADS API configuration
    /// source in the bootstrap configuration is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.AggregatedConfigSource Ads {
      get { return configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads ? (global::Envoy.Config.Core.V3.AggregatedConfigSource) configSourceSpecifier_ : null; }
      set {
        configSourceSpecifier_ = value;
        configSourceSpecifierCase_ = value == null ? ConfigSourceSpecifierOneofCase.None : ConfigSourceSpecifierOneofCase.Ads;
      }
    }

    /// <summary>Field number for the "self" field.</summary>
    public const int SelfFieldNumber = 5;
    /// <summary>
    /// [#not-implemented-hide:]
    /// When set, the client will access the resources from the same server it got the
    /// ConfigSource from, although not necessarily from the same stream. This is similar to the
    /// :ref:`ads&lt;envoy_v3_api_field.ConfigSource.ads>` field, except that the client may use a
    /// different stream to the same server. As a result, this field can be used for things
    /// like LRS that cannot be sent on an ADS stream. It can also be used to link from (e.g.)
    /// LDS to RDS on the same server without requiring the management server to know its name
    /// or required credentials.
    /// [#next-major-version: In xDS v3, consider replacing the ads field with this one, since
    /// this field can implicitly mean to use the same stream in the case where the ConfigSource
    /// is provided via ADS and the specified data can also be obtained via ADS.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.SelfConfigSource Self {
      get { return configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Self ? (global::Envoy.Config.Core.V3.SelfConfigSource) configSourceSpecifier_ : null; }
      set {
        configSourceSpecifier_ = value;
        configSourceSpecifierCase_ = value == null ? ConfigSourceSpecifierOneofCase.None : ConfigSourceSpecifierOneofCase.Self;
      }
    }

    /// <summary>Field number for the "initial_fetch_timeout" field.</summary>
    public const int InitialFetchTimeoutFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration initialFetchTimeout_;
    /// <summary>
    /// When this timeout is specified, Envoy will wait no longer than the specified time for first
    /// config response on this xDS subscription during the :ref:`initialization process
    /// &lt;arch_overview_initialization>`. After reaching the timeout, Envoy will move to the next
    /// initialization phase, even if the first config is not delivered yet. The timer is activated
    /// when the xDS API subscription starts, and is disarmed on first config update or on error. 0
    /// means no timeout - Envoy will wait indefinitely for the first xDS config (unless another
    /// timeout applies). The default is 15s.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration InitialFetchTimeout {
      get { return initialFetchTimeout_; }
      set {
        initialFetchTimeout_ = value;
      }
    }

    /// <summary>Field number for the "resource_api_version" field.</summary>
    public const int ResourceApiVersionFieldNumber = 6;
    private global::Envoy.Config.Core.V3.ApiVersion resourceApiVersion_ = global::Envoy.Config.Core.V3.ApiVersion.Auto;
    /// <summary>
    /// API version for xDS resources. This implies the type URLs that the client
    /// will request for resources and the resource type that the client will in
    /// turn expect to be delivered.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ApiVersion ResourceApiVersion {
      get { return resourceApiVersion_; }
      set {
        resourceApiVersion_ = value;
      }
    }

    private object configSourceSpecifier_;
    /// <summary>Enum of possible cases for the "config_source_specifier" oneof.</summary>
    public enum ConfigSourceSpecifierOneofCase {
      None = 0,
      Path = 1,
      ApiConfigSource = 2,
      Ads = 3,
      Self = 5,
    }
    private ConfigSourceSpecifierOneofCase configSourceSpecifierCase_ = ConfigSourceSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigSourceSpecifierOneofCase ConfigSourceSpecifierCase {
      get { return configSourceSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConfigSourceSpecifier() {
      configSourceSpecifierCase_ = ConfigSourceSpecifierOneofCase.None;
      configSourceSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!authorities_.Equals(other.authorities_)) return false;
      if (Path != other.Path) return false;
      if (!object.Equals(ApiConfigSource, other.ApiConfigSource)) return false;
      if (!object.Equals(Ads, other.Ads)) return false;
      if (!object.Equals(Self, other.Self)) return false;
      if (!object.Equals(InitialFetchTimeout, other.InitialFetchTimeout)) return false;
      if (ResourceApiVersion != other.ResourceApiVersion) return false;
      if (ConfigSourceSpecifierCase != other.ConfigSourceSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= authorities_.GetHashCode();
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Path) hash ^= Path.GetHashCode();
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) hash ^= ApiConfigSource.GetHashCode();
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) hash ^= Ads.GetHashCode();
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Self) hash ^= Self.GetHashCode();
      if (initialFetchTimeout_ != null) hash ^= InitialFetchTimeout.GetHashCode();
      if (ResourceApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) hash ^= ResourceApiVersion.GetHashCode();
      hash ^= (int) configSourceSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Path) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) {
        output.WriteRawTag(18);
        output.WriteMessage(ApiConfigSource);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) {
        output.WriteRawTag(26);
        output.WriteMessage(Ads);
      }
      if (initialFetchTimeout_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(InitialFetchTimeout);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Self) {
        output.WriteRawTag(42);
        output.WriteMessage(Self);
      }
      if (ResourceApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        output.WriteRawTag(48);
        output.WriteEnum((int) ResourceApiVersion);
      }
      authorities_.WriteTo(output, _repeated_authorities_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Path) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) {
        output.WriteRawTag(18);
        output.WriteMessage(ApiConfigSource);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) {
        output.WriteRawTag(26);
        output.WriteMessage(Ads);
      }
      if (initialFetchTimeout_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(InitialFetchTimeout);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Self) {
        output.WriteRawTag(42);
        output.WriteMessage(Self);
      }
      if (ResourceApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        output.WriteRawTag(48);
        output.WriteEnum((int) ResourceApiVersion);
      }
      authorities_.WriteTo(ref output, _repeated_authorities_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += authorities_.CalculateSize(_repeated_authorities_codec);
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Path) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ApiConfigSource);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Ads);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Self) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Self);
      }
      if (initialFetchTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InitialFetchTimeout);
      }
      if (ResourceApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ResourceApiVersion);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ConfigSource other) {
      if (other == null) {
        return;
      }
      authorities_.Add(other.authorities_);
      if (other.initialFetchTimeout_ != null) {
        if (initialFetchTimeout_ == null) {
          InitialFetchTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        InitialFetchTimeout.MergeFrom(other.InitialFetchTimeout);
      }
      if (other.ResourceApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        ResourceApiVersion = other.ResourceApiVersion;
      }
      switch (other.ConfigSourceSpecifierCase) {
        case ConfigSourceSpecifierOneofCase.Path:
          Path = other.Path;
          break;
        case ConfigSourceSpecifierOneofCase.ApiConfigSource:
          if (ApiConfigSource == null) {
            ApiConfigSource = new global::Envoy.Config.Core.V3.ApiConfigSource();
          }
          ApiConfigSource.MergeFrom(other.ApiConfigSource);
          break;
        case ConfigSourceSpecifierOneofCase.Ads:
          if (Ads == null) {
            Ads = new global::Envoy.Config.Core.V3.AggregatedConfigSource();
          }
          Ads.MergeFrom(other.Ads);
          break;
        case ConfigSourceSpecifierOneofCase.Self:
          if (Self == null) {
            Self = new global::Envoy.Config.Core.V3.SelfConfigSource();
          }
          Self.MergeFrom(other.Self);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            global::Envoy.Config.Core.V3.ApiConfigSource subBuilder = new global::Envoy.Config.Core.V3.ApiConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) {
              subBuilder.MergeFrom(ApiConfigSource);
            }
            input.ReadMessage(subBuilder);
            ApiConfigSource = subBuilder;
            break;
          }
          case 26: {
            global::Envoy.Config.Core.V3.AggregatedConfigSource subBuilder = new global::Envoy.Config.Core.V3.AggregatedConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) {
              subBuilder.MergeFrom(Ads);
            }
            input.ReadMessage(subBuilder);
            Ads = subBuilder;
            break;
          }
          case 34: {
            if (initialFetchTimeout_ == null) {
              InitialFetchTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(InitialFetchTimeout);
            break;
          }
          case 42: {
            global::Envoy.Config.Core.V3.SelfConfigSource subBuilder = new global::Envoy.Config.Core.V3.SelfConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Self) {
              subBuilder.MergeFrom(Self);
            }
            input.ReadMessage(subBuilder);
            Self = subBuilder;
            break;
          }
          case 48: {
            ResourceApiVersion = (global::Envoy.Config.Core.V3.ApiVersion) input.ReadEnum();
            break;
          }
          case 58: {
            authorities_.AddEntriesFrom(input, _repeated_authorities_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            global::Envoy.Config.Core.V3.ApiConfigSource subBuilder = new global::Envoy.Config.Core.V3.ApiConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) {
              subBuilder.MergeFrom(ApiConfigSource);
            }
            input.ReadMessage(subBuilder);
            ApiConfigSource = subBuilder;
            break;
          }
          case 26: {
            global::Envoy.Config.Core.V3.AggregatedConfigSource subBuilder = new global::Envoy.Config.Core.V3.AggregatedConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) {
              subBuilder.MergeFrom(Ads);
            }
            input.ReadMessage(subBuilder);
            Ads = subBuilder;
            break;
          }
          case 34: {
            if (initialFetchTimeout_ == null) {
              InitialFetchTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(InitialFetchTimeout);
            break;
          }
          case 42: {
            global::Envoy.Config.Core.V3.SelfConfigSource subBuilder = new global::Envoy.Config.Core.V3.SelfConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Self) {
              subBuilder.MergeFrom(Self);
            }
            input.ReadMessage(subBuilder);
            Self = subBuilder;
            break;
          }
          case 48: {
            ResourceApiVersion = (global::Envoy.Config.Core.V3.ApiVersion) input.ReadEnum();
            break;
          }
          case 58: {
            authorities_.AddEntriesFrom(ref input, _repeated_authorities_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
