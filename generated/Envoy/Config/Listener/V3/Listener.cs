// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/listener/v3/listener.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Listener.V3 {

  /// <summary>Holder for reflection information generated from envoy/config/listener/v3/listener.proto</summary>
  public static partial class ListenerReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/listener/v3/listener.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ListenerReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CidlbnZveS9jb25maWcvbGlzdGVuZXIvdjMvbGlzdGVuZXIucHJvdG8SGGVu",
            "dm95LmNvbmZpZy5saXN0ZW5lci52MxopZW52b3kvY29uZmlnL2FjY2Vzc2xv",
            "Zy92My9hY2Nlc3Nsb2cucHJvdG8aImVudm95L2NvbmZpZy9jb3JlL3YzL2Fk",
            "ZHJlc3MucHJvdG8aH2Vudm95L2NvbmZpZy9jb3JlL3YzL2Jhc2UucHJvdG8a",
            "KGVudm95L2NvbmZpZy9jb3JlL3YzL3NvY2tldF9vcHRpb24ucHJvdG8aK2Vu",
            "dm95L2NvbmZpZy9saXN0ZW5lci92My9hcGlfbGlzdGVuZXIucHJvdG8aMmVu",
            "dm95L2NvbmZpZy9saXN0ZW5lci92My9saXN0ZW5lcl9jb21wb25lbnRzLnBy",
            "b3RvGjJlbnZveS9jb25maWcvbGlzdGVuZXIvdjMvdWRwX2xpc3RlbmVyX2Nv",
            "bmZpZy5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvGh5n",
            "b29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG8aInhkcy9jb3JlL3YzL2Nv",
            "bGxlY3Rpb25fZW50cnkucHJvdG8aI2Vudm95L2Fubm90YXRpb25zL2RlcHJl",
            "Y2F0aW9uLnByb3RvGh91ZHBhL2Fubm90YXRpb25zL3NlY3VyaXR5LnByb3Rv",
            "Gh11ZHBhL2Fubm90YXRpb25zL3N0YXR1cy5wcm90bxohdWRwYS9hbm5vdGF0",
            "aW9ucy92ZXJzaW9uaW5nLnByb3RvGhd2YWxpZGF0ZS92YWxpZGF0ZS5wcm90",
            "byJDChJMaXN0ZW5lckNvbGxlY3Rpb24SLQoHZW50cmllcxgBIAMoCzIcLnhk",
            "cy5jb3JlLnYzLkNvbGxlY3Rpb25FbnRyeSLSEAoITGlzdGVuZXISDAoEbmFt",
            "ZRgBIAEoCRI4CgdhZGRyZXNzGAIgASgLMh0uZW52b3kuY29uZmlnLmNvcmUu",
            "djMuQWRkcmVzc0II+kIFigECEAESEwoLc3RhdF9wcmVmaXgYHCABKAkSPAoN",
            "ZmlsdGVyX2NoYWlucxgDIAMoCzIlLmVudm95LmNvbmZpZy5saXN0ZW5lci52",
            "My5GaWx0ZXJDaGFpbhI0ChB1c2Vfb3JpZ2luYWxfZHN0GAQgASgLMhouZ29v",
            "Z2xlLnByb3RvYnVmLkJvb2xWYWx1ZRJDChRkZWZhdWx0X2ZpbHRlcl9jaGFp",
            "bhgZIAEoCzIlLmVudm95LmNvbmZpZy5saXN0ZW5lci52My5GaWx0ZXJDaGFp",
            "bhJQCiFwZXJfY29ubmVjdGlvbl9idWZmZXJfbGltaXRfYnl0ZXMYBSABKAsy",
            "HC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVCB4qTtyoCCAESMAoIbWV0",
            "YWRhdGEYBiABKAsyHi5lbnZveS5jb25maWcuY29yZS52My5NZXRhZGF0YRJT",
            "Cg1kZXByZWNhdGVkX3YxGAcgASgLMi8uZW52b3kuY29uZmlnLmxpc3RlbmVy",
            "LnYzLkxpc3RlbmVyLkRlcHJlY2F0ZWRWMUILGAGSx4bYBAMzLjASQAoKZHJh",
            "aW5fdHlwZRgIIAEoDjIsLmVudm95LmNvbmZpZy5saXN0ZW5lci52My5MaXN0",
            "ZW5lci5EcmFpblR5cGUSQgoQbGlzdGVuZXJfZmlsdGVycxgJIAMoCzIoLmVu",
            "dm95LmNvbmZpZy5saXN0ZW5lci52My5MaXN0ZW5lckZpbHRlchI7ChhsaXN0",
            "ZW5lcl9maWx0ZXJzX3RpbWVvdXQYDyABKAsyGS5nb29nbGUucHJvdG9idWYu",
            "RHVyYXRpb24SLAokY29udGludWVfb25fbGlzdGVuZXJfZmlsdGVyc190aW1l",
            "b3V0GBEgASgIEi8KC3RyYW5zcGFyZW50GAogASgLMhouZ29vZ2xlLnByb3Rv",
            "YnVmLkJvb2xWYWx1ZRIsCghmcmVlYmluZBgLIAEoCzIaLmdvb2dsZS5wcm90",
            "b2J1Zi5Cb29sVmFsdWUSOgoOc29ja2V0X29wdGlvbnMYDSADKAsyIi5lbnZv",
            "eS5jb25maWcuY29yZS52My5Tb2NrZXRPcHRpb24SQAoadGNwX2Zhc3Rfb3Bl",
            "bl9xdWV1ZV9sZW5ndGgYDCABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMy",
            "VmFsdWUSQQoRdHJhZmZpY19kaXJlY3Rpb24YECABKA4yJi5lbnZveS5jb25m",
            "aWcuY29yZS52My5UcmFmZmljRGlyZWN0aW9uEkgKE3VkcF9saXN0ZW5lcl9j",
            "b25maWcYEiABKAsyKy5lbnZveS5jb25maWcubGlzdGVuZXIudjMuVWRwTGlz",
            "dGVuZXJDb25maWcSOwoMYXBpX2xpc3RlbmVyGBMgASgLMiUuZW52b3kuY29u",
            "ZmlnLmxpc3RlbmVyLnYzLkFwaUxpc3RlbmVyEl0KGWNvbm5lY3Rpb25fYmFs",
            "YW5jZV9jb25maWcYFCABKAsyOi5lbnZveS5jb25maWcubGlzdGVuZXIudjMu",
            "TGlzdGVuZXIuQ29ubmVjdGlvbkJhbGFuY2VDb25maWcSHwoKcmV1c2VfcG9y",
            "dBgVIAEoCEILGAGSx4bYBAMzLjASNQoRZW5hYmxlX3JldXNlX3BvcnQYHSAB",
            "KAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlEjgKCmFjY2Vzc19sb2cY",
            "FiADKAsyJC5lbnZveS5jb25maWcuYWNjZXNzbG9nLnYzLkFjY2Vzc0xvZxI2",
            "ChB0Y3BfYmFja2xvZ19zaXplGBggASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJ",
            "bnQzMlZhbHVlEjAKDGJpbmRfdG9fcG9ydBgaIAEoCzIaLmdvb2dsZS5wcm90",
            "b2J1Zi5Cb29sVmFsdWUSVgoRaW50ZXJuYWxfbGlzdGVuZXIYGyABKAsyOS5l",
            "bnZveS5jb25maWcubGlzdGVuZXIudjMuTGlzdGVuZXIuSW50ZXJuYWxMaXN0",
            "ZW5lckNvbmZpZ0gAGmsKDERlcHJlY2F0ZWRWMRIwCgxiaW5kX3RvX3BvcnQY",
            "ASABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlOimaxYgeJAoiZW52",
            "b3kuYXBpLnYyLkxpc3RlbmVyLkRlcHJlY2F0ZWRWMRqZAgoXQ29ubmVjdGlv",
            "bkJhbGFuY2VDb25maWcSYAoNZXhhY3RfYmFsYW5jZRgBIAEoCzJHLmVudm95",
            "LmNvbmZpZy5saXN0ZW5lci52My5MaXN0ZW5lci5Db25uZWN0aW9uQmFsYW5j",
            "ZUNvbmZpZy5FeGFjdEJhbGFuY2VIABpRCgxFeGFjdEJhbGFuY2U6QZrFiB48",
            "CjplbnZveS5hcGkudjIuTGlzdGVuZXIuQ29ubmVjdGlvbkJhbGFuY2VDb25m",
            "aWcuRXhhY3RCYWxhbmNlOjSaxYgeLwotZW52b3kuYXBpLnYyLkxpc3RlbmVy",
            "LkNvbm5lY3Rpb25CYWxhbmNlQ29uZmlnQhMKDGJhbGFuY2VfdHlwZRID+EIB",
            "GhgKFkludGVybmFsTGlzdGVuZXJDb25maWciKQoJRHJhaW5UeXBlEgsKB0RF",
            "RkFVTFQQABIPCgtNT0RJRllfT05MWRABOhyaxYgeFwoVZW52b3kuYXBpLnYy",
            "Lkxpc3RlbmVyQhQKEmxpc3RlbmVyX3NwZWNpZmllckoECA4QD0oECBcQGEJB",
            "CiZpby5lbnZveXByb3h5LmVudm95LmNvbmZpZy5saXN0ZW5lci52M0INTGlz",
            "dGVuZXJQcm90b1ABuoDI0QYCEAJiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Accesslog.V3.AccesslogReflection.Descriptor, global::Envoy.Config.Core.V3.AddressReflection.Descriptor, global::Envoy.Config.Core.V3.BaseReflection.Descriptor, global::Envoy.Config.Core.V3.SocketOptionReflection.Descriptor, global::Envoy.Config.Listener.V3.ApiListenerReflection.Descriptor, global::Envoy.Config.Listener.V3.ListenerComponentsReflection.Descriptor, global::Envoy.Config.Listener.V3.UdpListenerConfigReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Xds.Core.V3.CollectionEntryReflection.Descriptor, global::Envoy.Annotations.DeprecationReflection.Descriptor, global::Udpa.Annotations.SecurityReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Listener.V3.ListenerCollection), global::Envoy.Config.Listener.V3.ListenerCollection.Parser, new[]{ "Entries" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Listener.V3.Listener), global::Envoy.Config.Listener.V3.Listener.Parser, new[]{ "Name", "Address", "StatPrefix", "FilterChains", "UseOriginalDst", "DefaultFilterChain", "PerConnectionBufferLimitBytes", "Metadata", "DeprecatedV1", "DrainType", "ListenerFilters", "ListenerFiltersTimeout", "ContinueOnListenerFiltersTimeout", "Transparent", "Freebind", "SocketOptions", "TcpFastOpenQueueLength", "TrafficDirection", "UdpListenerConfig", "ApiListener", "ConnectionBalanceConfig", "ReusePort", "EnableReusePort", "AccessLog", "TcpBacklogSize", "BindToPort", "InternalListener" }, new[]{ "ListenerSpecifier" }, new[]{ typeof(global::Envoy.Config.Listener.V3.Listener.Types.DrainType) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Listener.V3.Listener.Types.DeprecatedV1), global::Envoy.Config.Listener.V3.Listener.Types.DeprecatedV1.Parser, new[]{ "BindToPort" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig), global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig.Parser, new[]{ "ExactBalance" }, new[]{ "BalanceType" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance), global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance.Parser, null, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Listener.V3.Listener.Types.InternalListenerConfig), global::Envoy.Config.Listener.V3.Listener.Types.InternalListenerConfig.Parser, null, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Listener list collections. Entries are *Listener* resources or references.
  /// [#not-implemented-hide:]
  /// </summary>
  public sealed partial class ListenerCollection : pb::IMessage<ListenerCollection>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ListenerCollection> _parser = new pb::MessageParser<ListenerCollection>(() => new ListenerCollection());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ListenerCollection> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Listener.V3.ListenerReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ListenerCollection() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ListenerCollection(ListenerCollection other) : this() {
      entries_ = other.entries_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ListenerCollection Clone() {
      return new ListenerCollection(this);
    }

    /// <summary>Field number for the "entries" field.</summary>
    public const int EntriesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Xds.Core.V3.CollectionEntry> _repeated_entries_codec
        = pb::FieldCodec.ForMessage(10, global::Xds.Core.V3.CollectionEntry.Parser);
    private readonly pbc::RepeatedField<global::Xds.Core.V3.CollectionEntry> entries_ = new pbc::RepeatedField<global::Xds.Core.V3.CollectionEntry>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Xds.Core.V3.CollectionEntry> Entries {
      get { return entries_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ListenerCollection);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ListenerCollection other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!entries_.Equals(other.entries_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= entries_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      entries_.WriteTo(output, _repeated_entries_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      entries_.WriteTo(ref output, _repeated_entries_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += entries_.CalculateSize(_repeated_entries_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ListenerCollection other) {
      if (other == null) {
        return;
      }
      entries_.Add(other.entries_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            entries_.AddEntriesFrom(input, _repeated_entries_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            entries_.AddEntriesFrom(ref input, _repeated_entries_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#next-free-field: 30]
  /// </summary>
  public sealed partial class Listener : pb::IMessage<Listener>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Listener> _parser = new pb::MessageParser<Listener>(() => new Listener());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Listener> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Listener.V3.ListenerReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Listener() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Listener(Listener other) : this() {
      name_ = other.name_;
      address_ = other.address_ != null ? other.address_.Clone() : null;
      statPrefix_ = other.statPrefix_;
      filterChains_ = other.filterChains_.Clone();
      UseOriginalDst = other.UseOriginalDst;
      defaultFilterChain_ = other.defaultFilterChain_ != null ? other.defaultFilterChain_.Clone() : null;
      PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      deprecatedV1_ = other.deprecatedV1_ != null ? other.deprecatedV1_.Clone() : null;
      drainType_ = other.drainType_;
      listenerFilters_ = other.listenerFilters_.Clone();
      listenerFiltersTimeout_ = other.listenerFiltersTimeout_ != null ? other.listenerFiltersTimeout_.Clone() : null;
      continueOnListenerFiltersTimeout_ = other.continueOnListenerFiltersTimeout_;
      Transparent = other.Transparent;
      Freebind = other.Freebind;
      socketOptions_ = other.socketOptions_.Clone();
      TcpFastOpenQueueLength = other.TcpFastOpenQueueLength;
      trafficDirection_ = other.trafficDirection_;
      udpListenerConfig_ = other.udpListenerConfig_ != null ? other.udpListenerConfig_.Clone() : null;
      apiListener_ = other.apiListener_ != null ? other.apiListener_.Clone() : null;
      connectionBalanceConfig_ = other.connectionBalanceConfig_ != null ? other.connectionBalanceConfig_.Clone() : null;
      reusePort_ = other.reusePort_;
      EnableReusePort = other.EnableReusePort;
      accessLog_ = other.accessLog_.Clone();
      TcpBacklogSize = other.TcpBacklogSize;
      BindToPort = other.BindToPort;
      switch (other.ListenerSpecifierCase) {
        case ListenerSpecifierOneofCase.InternalListener:
          InternalListener = other.InternalListener.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Listener Clone() {
      return new Listener(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The unique name by which this listener is known. If no name is provided,
    /// Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
    /// updated or removed via :ref:`LDS &lt;config_listeners_lds>` a unique name must be provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 2;
    private global::Envoy.Config.Core.V3.Address address_;
    /// <summary>
    /// The address that the listener should listen on. In general, the address must be unique, though
    /// that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
    /// Linux as the actual port will be allocated by the OS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.Address Address {
      get { return address_; }
      set {
        address_ = value;
      }
    }

    /// <summary>Field number for the "stat_prefix" field.</summary>
    public const int StatPrefixFieldNumber = 28;
    private string statPrefix_ = "";
    /// <summary>
    /// Optional prefix to use on listener stats. If empty, the stats will be rooted at
    /// `listener.&lt;address as string>.`. If non-empty, stats will be rooted at
    /// `listener.&lt;stat_prefix>.`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StatPrefix {
      get { return statPrefix_; }
      set {
        statPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "filter_chains" field.</summary>
    public const int FilterChainsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Config.Listener.V3.FilterChain> _repeated_filterChains_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Config.Listener.V3.FilterChain.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Listener.V3.FilterChain> filterChains_ = new pbc::RepeatedField<global::Envoy.Config.Listener.V3.FilterChain>();
    /// <summary>
    /// A list of filter chains to consider for this listener. The
    /// :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain>` with the most specific
    /// :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch>` criteria is used on a
    /// connection.
    ///
    /// Example using SNI for filter chain selection can be found in the
    /// :ref:`FAQ entry &lt;faq_how_to_setup_sni>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Listener.V3.FilterChain> FilterChains {
      get { return filterChains_; }
    }

    /// <summary>Field number for the "use_original_dst" field.</summary>
    public const int UseOriginalDstFieldNumber = 4;
    private static readonly pb::FieldCodec<bool?> _single_useOriginalDst_codec = pb::FieldCodec.ForStructWrapper<bool>(34);
    private bool? useOriginalDst_;
    /// <summary>
    /// If a connection is redirected using *iptables*, the port on which the proxy
    /// receives it might be different from the original destination address. When this flag is set to
    /// true, the listener hands off redirected connections to the listener associated with the
    /// original destination address. If there is no listener associated with the original destination
    /// address, the connection is handled by the listener that receives it. Defaults to false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? UseOriginalDst {
      get { return useOriginalDst_; }
      set {
        useOriginalDst_ = value;
      }
    }


    /// <summary>Field number for the "default_filter_chain" field.</summary>
    public const int DefaultFilterChainFieldNumber = 25;
    private global::Envoy.Config.Listener.V3.FilterChain defaultFilterChain_;
    /// <summary>
    /// The default filter chain if none of the filter chain matches. If no default filter chain is supplied,
    /// the connection will be closed. The filter chain match is ignored in this field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Listener.V3.FilterChain DefaultFilterChain {
      get { return defaultFilterChain_; }
      set {
        defaultFilterChain_ = value;
      }
    }

    /// <summary>Field number for the "per_connection_buffer_limit_bytes" field.</summary>
    public const int PerConnectionBufferLimitBytesFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_perConnectionBufferLimitBytes_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? perConnectionBufferLimitBytes_;
    /// <summary>
    /// Soft limit on size of the listener’s new connection read and write buffers.
    /// If unspecified, an implementation defined default is applied (1MiB).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? PerConnectionBufferLimitBytes {
      get { return perConnectionBufferLimitBytes_; }
      set {
        perConnectionBufferLimitBytes_ = value;
      }
    }


    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 6;
    private global::Envoy.Config.Core.V3.Metadata metadata_;
    /// <summary>
    /// Listener metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "deprecated_v1" field.</summary>
    public const int DeprecatedV1FieldNumber = 7;
    private global::Envoy.Config.Listener.V3.Listener.Types.DeprecatedV1 deprecatedV1_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Listener.V3.Listener.Types.DeprecatedV1 DeprecatedV1 {
      get { return deprecatedV1_; }
      set {
        deprecatedV1_ = value;
      }
    }

    /// <summary>Field number for the "drain_type" field.</summary>
    public const int DrainTypeFieldNumber = 8;
    private global::Envoy.Config.Listener.V3.Listener.Types.DrainType drainType_ = global::Envoy.Config.Listener.V3.Listener.Types.DrainType.Default;
    /// <summary>
    /// The type of draining to perform at a listener-wide level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Listener.V3.Listener.Types.DrainType DrainType {
      get { return drainType_; }
      set {
        drainType_ = value;
      }
    }

    /// <summary>Field number for the "listener_filters" field.</summary>
    public const int ListenerFiltersFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Envoy.Config.Listener.V3.ListenerFilter> _repeated_listenerFilters_codec
        = pb::FieldCodec.ForMessage(74, global::Envoy.Config.Listener.V3.ListenerFilter.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Listener.V3.ListenerFilter> listenerFilters_ = new pbc::RepeatedField<global::Envoy.Config.Listener.V3.ListenerFilter>();
    /// <summary>
    /// Listener filters have the opportunity to manipulate and augment the connection metadata that
    /// is used in connection filter chain matching, for example. These filters are run before any in
    /// :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains>`. Order matters as the
    /// filters are processed sequentially right after a socket has been accepted by the listener, and
    /// before a connection is created.
    /// UDP Listener filters can be specified when the protocol in the listener socket address in
    /// :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol>` is :ref:`UDP
    /// &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP>`.
    /// UDP listeners currently support a single filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Listener.V3.ListenerFilter> ListenerFilters {
      get { return listenerFilters_; }
    }

    /// <summary>Field number for the "listener_filters_timeout" field.</summary>
    public const int ListenerFiltersTimeoutFieldNumber = 15;
    private global::Google.Protobuf.WellKnownTypes.Duration listenerFiltersTimeout_;
    /// <summary>
    /// The timeout to wait for all listener filters to complete operation. If the timeout is reached,
    /// the accepted socket is closed without a connection being created unless
    /// `continue_on_listener_filters_timeout` is set to true. Specify 0 to disable the
    /// timeout. If not specified, a default timeout of 15s is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration ListenerFiltersTimeout {
      get { return listenerFiltersTimeout_; }
      set {
        listenerFiltersTimeout_ = value;
      }
    }

    /// <summary>Field number for the "continue_on_listener_filters_timeout" field.</summary>
    public const int ContinueOnListenerFiltersTimeoutFieldNumber = 17;
    private bool continueOnListenerFiltersTimeout_;
    /// <summary>
    /// Whether a connection should be created when listener filters timeout. Default is false.
    ///
    /// .. attention::
    ///
    ///   Some listener filters, such as :ref:`Proxy Protocol filter
    ///   &lt;config_listener_filters_proxy_protocol>`, should not be used with this option. It will cause
    ///   unexpected behavior when a connection is created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ContinueOnListenerFiltersTimeout {
      get { return continueOnListenerFiltersTimeout_; }
      set {
        continueOnListenerFiltersTimeout_ = value;
      }
    }

    /// <summary>Field number for the "transparent" field.</summary>
    public const int TransparentFieldNumber = 10;
    private static readonly pb::FieldCodec<bool?> _single_transparent_codec = pb::FieldCodec.ForStructWrapper<bool>(82);
    private bool? transparent_;
    /// <summary>
    /// Whether the listener should be set as a transparent socket.
    /// When this flag is set to true, connections can be redirected to the listener using an
    /// *iptables* *TPROXY* target, in which case the original source and destination addresses and
    /// ports are preserved on accepted connections. This flag should be used in combination with
    /// :ref:`an original_dst &lt;config_listener_filters_original_dst>` :ref:`listener filter
    /// &lt;envoy_v3_api_field_config.listener.v3.Listener.listener_filters>` to mark the connections' local addresses as
    /// "restored." This can be used to hand off each redirected connection to another listener
    /// associated with the connection's destination address. Direct connections to the socket without
    /// using *TPROXY* cannot be distinguished from connections redirected using *TPROXY* and are
    /// therefore treated as if they were redirected.
    /// When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
    /// Setting this flag requires Envoy to run with the *CAP_NET_ADMIN* capability.
    /// When this flag is not set (default), the socket is not modified, i.e. the transparent option
    /// is neither set nor reset.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? Transparent {
      get { return transparent_; }
      set {
        transparent_ = value;
      }
    }


    /// <summary>Field number for the "freebind" field.</summary>
    public const int FreebindFieldNumber = 11;
    private static readonly pb::FieldCodec<bool?> _single_freebind_codec = pb::FieldCodec.ForStructWrapper<bool>(90);
    private bool? freebind_;
    /// <summary>
    /// Whether the listener should set the *IP_FREEBIND* socket option. When this
    /// flag is set to true, listeners can be bound to an IP address that is not
    /// configured on the system running Envoy. When this flag is set to false, the
    /// option *IP_FREEBIND* is disabled on the socket. When this flag is not set
    /// (default), the socket is not modified, i.e. the option is neither enabled
    /// nor disabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? Freebind {
      get { return freebind_; }
      set {
        freebind_ = value;
      }
    }


    /// <summary>Field number for the "socket_options" field.</summary>
    public const int SocketOptionsFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.SocketOption> _repeated_socketOptions_codec
        = pb::FieldCodec.ForMessage(106, global::Envoy.Config.Core.V3.SocketOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.SocketOption> socketOptions_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.SocketOption>();
    /// <summary>
    /// Additional socket options that may not be present in Envoy source code or
    /// precompiled binaries.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.SocketOption> SocketOptions {
      get { return socketOptions_; }
    }

    /// <summary>Field number for the "tcp_fast_open_queue_length" field.</summary>
    public const int TcpFastOpenQueueLengthFieldNumber = 12;
    private static readonly pb::FieldCodec<uint?> _single_tcpFastOpenQueueLength_codec = pb::FieldCodec.ForStructWrapper<uint>(98);
    private uint? tcpFastOpenQueueLength_;
    /// <summary>
    /// Whether the listener should accept TCP Fast Open (TFO) connections.
    /// When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
    /// the socket, with a queue length of the specified size
    /// (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1>`_).
    /// When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
    /// When this flag is not set (default), the socket is not modified,
    /// i.e. the option is neither enabled nor disabled.
    ///
    /// On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
    /// TCP_FASTOPEN.
    /// See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt>`_.
    ///
    /// On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
    /// To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? TcpFastOpenQueueLength {
      get { return tcpFastOpenQueueLength_; }
      set {
        tcpFastOpenQueueLength_ = value;
      }
    }


    /// <summary>Field number for the "traffic_direction" field.</summary>
    public const int TrafficDirectionFieldNumber = 16;
    private global::Envoy.Config.Core.V3.TrafficDirection trafficDirection_ = global::Envoy.Config.Core.V3.TrafficDirection.Unspecified;
    /// <summary>
    /// Specifies the intended direction of the traffic relative to the local Envoy.
    /// This property is required on Windows for listeners using the original destination filter,
    /// see :ref:`Original Destination &lt;config_listener_filters_original_dst>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TrafficDirection TrafficDirection {
      get { return trafficDirection_; }
      set {
        trafficDirection_ = value;
      }
    }

    /// <summary>Field number for the "udp_listener_config" field.</summary>
    public const int UdpListenerConfigFieldNumber = 18;
    private global::Envoy.Config.Listener.V3.UdpListenerConfig udpListenerConfig_;
    /// <summary>
    /// If the protocol in the listener socket address in :ref:`protocol
    /// &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol>` is :ref:`UDP
    /// &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP>`, this field specifies UDP
    /// listener specific configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Listener.V3.UdpListenerConfig UdpListenerConfig {
      get { return udpListenerConfig_; }
      set {
        udpListenerConfig_ = value;
      }
    }

    /// <summary>Field number for the "api_listener" field.</summary>
    public const int ApiListenerFieldNumber = 19;
    private global::Envoy.Config.Listener.V3.ApiListener apiListener_;
    /// <summary>
    /// Used to represent an API listener, which is used in non-proxy clients. The type of API
    /// exposed to the non-proxy application depends on the type of API listener.
    /// When this field is set, no other field except for :ref:`name&lt;envoy_v3_api_field_config.listener.v3.Listener.name>`
    /// should be set.
    ///
    /// .. note::
    ///
    ///  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
    ///  not LDS.
    ///
    /// [#next-major-version: In the v3 API, instead of this messy approach where the socket
    /// listener fields are directly in the top-level Listener message and the API listener types
    /// are in the ApiListener message, the socket listener messages should be in their own message,
    /// and the top-level Listener should essentially be a oneof that selects between the
    /// socket listener and the various types of API listener. That way, a given Listener message
    /// can structurally only contain the fields of the relevant type.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Listener.V3.ApiListener ApiListener {
      get { return apiListener_; }
      set {
        apiListener_ = value;
      }
    }

    /// <summary>Field number for the "connection_balance_config" field.</summary>
    public const int ConnectionBalanceConfigFieldNumber = 20;
    private global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig connectionBalanceConfig_;
    /// <summary>
    /// The listener's connection balancer configuration, currently only applicable to TCP listeners.
    /// If no configuration is specified, Envoy will not attempt to balance active connections between
    /// worker threads.
    ///
    /// In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2
    /// by setting :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst>` in X
    /// and :ref:`bind_to_port &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port>` to false in Y1 and Y2,
    /// it is recommended to disable the balance config in listener X to avoid the cost of balancing, and
    /// enable the balance config in Y1 and Y2 to balance the connections among the workers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig ConnectionBalanceConfig {
      get { return connectionBalanceConfig_; }
      set {
        connectionBalanceConfig_ = value;
      }
    }

    /// <summary>Field number for the "reuse_port" field.</summary>
    public const int ReusePortFieldNumber = 21;
    private bool reusePort_;
    /// <summary>
    /// Deprecated. Use `enable_reuse_port` instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReusePort {
      get { return reusePort_; }
      set {
        reusePort_ = value;
      }
    }

    /// <summary>Field number for the "enable_reuse_port" field.</summary>
    public const int EnableReusePortFieldNumber = 29;
    private static readonly pb::FieldCodec<bool?> _single_enableReusePort_codec = pb::FieldCodec.ForStructWrapper<bool>(234);
    private bool? enableReusePort_;
    /// <summary>
    /// When this flag is set to true, listeners set the *SO_REUSEPORT* socket option and
    /// create one socket for each worker thread. This makes inbound connections
    /// distribute among worker threads roughly evenly in cases where there are a high number
    /// of connections. When this flag is set to false, all worker threads share one socket. This field
    /// defaults to true.
    ///
    /// .. attention::
    ///
    ///   Although this field defaults to true, it has different behavior on different platforms. See
    ///   the following text for more information.
    ///
    /// * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly
    ///   with hot restart.
    /// * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,
    ///   the last socket wins and receives all connections/packets. For TCP, reuse_port is force
    ///   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive
    ///   packets. For QUIC/H3, SW routing will send packets to other workers. For "raw" UDP, only
    ///   a single worker will currently receive packets.
    /// * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user
    ///   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? EnableReusePort {
      get { return enableReusePort_; }
      set {
        enableReusePort_ = value;
      }
    }


    /// <summary>Field number for the "access_log" field.</summary>
    public const int AccessLogFieldNumber = 22;
    private static readonly pb::FieldCodec<global::Envoy.Config.Accesslog.V3.AccessLog> _repeated_accessLog_codec
        = pb::FieldCodec.ForMessage(178, global::Envoy.Config.Accesslog.V3.AccessLog.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Accesslog.V3.AccessLog> accessLog_ = new pbc::RepeatedField<global::Envoy.Config.Accesslog.V3.AccessLog>();
    /// <summary>
    /// Configuration for :ref:`access logs &lt;arch_overview_access_logs>`
    /// emitted by this listener.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Accesslog.V3.AccessLog> AccessLog {
      get { return accessLog_; }
    }

    /// <summary>Field number for the "tcp_backlog_size" field.</summary>
    public const int TcpBacklogSizeFieldNumber = 24;
    private static readonly pb::FieldCodec<uint?> _single_tcpBacklogSize_codec = pb::FieldCodec.ForStructWrapper<uint>(194);
    private uint? tcpBacklogSize_;
    /// <summary>
    /// The maximum length a tcp listener's pending connections queue can grow to. If no value is
    /// provided net.core.somaxconn will be used on Linux and 128 otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? TcpBacklogSize {
      get { return tcpBacklogSize_; }
      set {
        tcpBacklogSize_ = value;
      }
    }


    /// <summary>Field number for the "bind_to_port" field.</summary>
    public const int BindToPortFieldNumber = 26;
    private static readonly pb::FieldCodec<bool?> _single_bindToPort_codec = pb::FieldCodec.ForStructWrapper<bool>(210);
    private bool? bindToPort_;
    /// <summary>
    /// Whether the listener should bind to the port. A listener that doesn't
    /// bind can only receive connections redirected from other listeners that set
    /// :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst>`
    /// to true. Default is true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? BindToPort {
      get { return bindToPort_; }
      set {
        bindToPort_ = value;
      }
    }


    /// <summary>Field number for the "internal_listener" field.</summary>
    public const int InternalListenerFieldNumber = 27;
    /// <summary>
    /// Used to represent an internal listener which does not listen on OSI L4 address but can be used by the
    /// :ref:`envoy cluster &lt;envoy_v3_api_msg_config.cluster.v3.Cluster>` to create a user space connection to.
    /// The internal listener acts as a tcp listener. It supports listener filters and network filter chains.
    /// The internal listener require :ref:`address &lt;envoy_v3_api_field_config.listener.v3.Listener.address>` has
    /// field `envoy_internal_address`.
    ///
    /// There are some limitations are derived from the implementation. The known limitations include
    ///
    /// * :ref:`ConnectionBalanceConfig &lt;envoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig>` is not
    ///   allowed because both cluster connection and listener connection must be owned by the same dispatcher.
    /// * :ref:`tcp_backlog_size &lt;envoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size>`
    /// * :ref:`freebind &lt;envoy_v3_api_field_config.listener.v3.Listener.freebind>`
    /// * :ref:`transparent &lt;envoy_v3_api_field_config.listener.v3.Listener.transparent>`
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Listener.V3.Listener.Types.InternalListenerConfig InternalListener {
      get { return listenerSpecifierCase_ == ListenerSpecifierOneofCase.InternalListener ? (global::Envoy.Config.Listener.V3.Listener.Types.InternalListenerConfig) listenerSpecifier_ : null; }
      set {
        listenerSpecifier_ = value;
        listenerSpecifierCase_ = value == null ? ListenerSpecifierOneofCase.None : ListenerSpecifierOneofCase.InternalListener;
      }
    }

    private object listenerSpecifier_;
    /// <summary>Enum of possible cases for the "listener_specifier" oneof.</summary>
    public enum ListenerSpecifierOneofCase {
      None = 0,
      InternalListener = 27,
    }
    private ListenerSpecifierOneofCase listenerSpecifierCase_ = ListenerSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ListenerSpecifierOneofCase ListenerSpecifierCase {
      get { return listenerSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearListenerSpecifier() {
      listenerSpecifierCase_ = ListenerSpecifierOneofCase.None;
      listenerSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Listener);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Listener other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Address, other.Address)) return false;
      if (StatPrefix != other.StatPrefix) return false;
      if(!filterChains_.Equals(other.filterChains_)) return false;
      if (UseOriginalDst != other.UseOriginalDst) return false;
      if (!object.Equals(DefaultFilterChain, other.DefaultFilterChain)) return false;
      if (PerConnectionBufferLimitBytes != other.PerConnectionBufferLimitBytes) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(DeprecatedV1, other.DeprecatedV1)) return false;
      if (DrainType != other.DrainType) return false;
      if(!listenerFilters_.Equals(other.listenerFilters_)) return false;
      if (!object.Equals(ListenerFiltersTimeout, other.ListenerFiltersTimeout)) return false;
      if (ContinueOnListenerFiltersTimeout != other.ContinueOnListenerFiltersTimeout) return false;
      if (Transparent != other.Transparent) return false;
      if (Freebind != other.Freebind) return false;
      if(!socketOptions_.Equals(other.socketOptions_)) return false;
      if (TcpFastOpenQueueLength != other.TcpFastOpenQueueLength) return false;
      if (TrafficDirection != other.TrafficDirection) return false;
      if (!object.Equals(UdpListenerConfig, other.UdpListenerConfig)) return false;
      if (!object.Equals(ApiListener, other.ApiListener)) return false;
      if (!object.Equals(ConnectionBalanceConfig, other.ConnectionBalanceConfig)) return false;
      if (ReusePort != other.ReusePort) return false;
      if (EnableReusePort != other.EnableReusePort) return false;
      if(!accessLog_.Equals(other.accessLog_)) return false;
      if (TcpBacklogSize != other.TcpBacklogSize) return false;
      if (BindToPort != other.BindToPort) return false;
      if (!object.Equals(InternalListener, other.InternalListener)) return false;
      if (ListenerSpecifierCase != other.ListenerSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (address_ != null) hash ^= Address.GetHashCode();
      if (StatPrefix.Length != 0) hash ^= StatPrefix.GetHashCode();
      hash ^= filterChains_.GetHashCode();
      if (useOriginalDst_ != null) hash ^= UseOriginalDst.GetHashCode();
      if (defaultFilterChain_ != null) hash ^= DefaultFilterChain.GetHashCode();
      if (perConnectionBufferLimitBytes_ != null) hash ^= PerConnectionBufferLimitBytes.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (deprecatedV1_ != null) hash ^= DeprecatedV1.GetHashCode();
      if (DrainType != global::Envoy.Config.Listener.V3.Listener.Types.DrainType.Default) hash ^= DrainType.GetHashCode();
      hash ^= listenerFilters_.GetHashCode();
      if (listenerFiltersTimeout_ != null) hash ^= ListenerFiltersTimeout.GetHashCode();
      if (ContinueOnListenerFiltersTimeout != false) hash ^= ContinueOnListenerFiltersTimeout.GetHashCode();
      if (transparent_ != null) hash ^= Transparent.GetHashCode();
      if (freebind_ != null) hash ^= Freebind.GetHashCode();
      hash ^= socketOptions_.GetHashCode();
      if (tcpFastOpenQueueLength_ != null) hash ^= TcpFastOpenQueueLength.GetHashCode();
      if (TrafficDirection != global::Envoy.Config.Core.V3.TrafficDirection.Unspecified) hash ^= TrafficDirection.GetHashCode();
      if (udpListenerConfig_ != null) hash ^= UdpListenerConfig.GetHashCode();
      if (apiListener_ != null) hash ^= ApiListener.GetHashCode();
      if (connectionBalanceConfig_ != null) hash ^= ConnectionBalanceConfig.GetHashCode();
      if (ReusePort != false) hash ^= ReusePort.GetHashCode();
      if (enableReusePort_ != null) hash ^= EnableReusePort.GetHashCode();
      hash ^= accessLog_.GetHashCode();
      if (tcpBacklogSize_ != null) hash ^= TcpBacklogSize.GetHashCode();
      if (bindToPort_ != null) hash ^= BindToPort.GetHashCode();
      if (listenerSpecifierCase_ == ListenerSpecifierOneofCase.InternalListener) hash ^= InternalListener.GetHashCode();
      hash ^= (int) listenerSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (address_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Address);
      }
      filterChains_.WriteTo(output, _repeated_filterChains_codec);
      if (useOriginalDst_ != null) {
        _single_useOriginalDst_codec.WriteTagAndValue(output, UseOriginalDst);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        _single_perConnectionBufferLimitBytes_codec.WriteTagAndValue(output, PerConnectionBufferLimitBytes);
      }
      if (metadata_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Metadata);
      }
      if (deprecatedV1_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DeprecatedV1);
      }
      if (DrainType != global::Envoy.Config.Listener.V3.Listener.Types.DrainType.Default) {
        output.WriteRawTag(64);
        output.WriteEnum((int) DrainType);
      }
      listenerFilters_.WriteTo(output, _repeated_listenerFilters_codec);
      if (transparent_ != null) {
        _single_transparent_codec.WriteTagAndValue(output, Transparent);
      }
      if (freebind_ != null) {
        _single_freebind_codec.WriteTagAndValue(output, Freebind);
      }
      if (tcpFastOpenQueueLength_ != null) {
        _single_tcpFastOpenQueueLength_codec.WriteTagAndValue(output, TcpFastOpenQueueLength);
      }
      socketOptions_.WriteTo(output, _repeated_socketOptions_codec);
      if (listenerFiltersTimeout_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(ListenerFiltersTimeout);
      }
      if (TrafficDirection != global::Envoy.Config.Core.V3.TrafficDirection.Unspecified) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) TrafficDirection);
      }
      if (ContinueOnListenerFiltersTimeout != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(ContinueOnListenerFiltersTimeout);
      }
      if (udpListenerConfig_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(UdpListenerConfig);
      }
      if (apiListener_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ApiListener);
      }
      if (connectionBalanceConfig_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(ConnectionBalanceConfig);
      }
      if (ReusePort != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(ReusePort);
      }
      accessLog_.WriteTo(output, _repeated_accessLog_codec);
      if (tcpBacklogSize_ != null) {
        _single_tcpBacklogSize_codec.WriteTagAndValue(output, TcpBacklogSize);
      }
      if (defaultFilterChain_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(DefaultFilterChain);
      }
      if (bindToPort_ != null) {
        _single_bindToPort_codec.WriteTagAndValue(output, BindToPort);
      }
      if (listenerSpecifierCase_ == ListenerSpecifierOneofCase.InternalListener) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(InternalListener);
      }
      if (StatPrefix.Length != 0) {
        output.WriteRawTag(226, 1);
        output.WriteString(StatPrefix);
      }
      if (enableReusePort_ != null) {
        _single_enableReusePort_codec.WriteTagAndValue(output, EnableReusePort);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (address_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Address);
      }
      filterChains_.WriteTo(ref output, _repeated_filterChains_codec);
      if (useOriginalDst_ != null) {
        _single_useOriginalDst_codec.WriteTagAndValue(ref output, UseOriginalDst);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        _single_perConnectionBufferLimitBytes_codec.WriteTagAndValue(ref output, PerConnectionBufferLimitBytes);
      }
      if (metadata_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Metadata);
      }
      if (deprecatedV1_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DeprecatedV1);
      }
      if (DrainType != global::Envoy.Config.Listener.V3.Listener.Types.DrainType.Default) {
        output.WriteRawTag(64);
        output.WriteEnum((int) DrainType);
      }
      listenerFilters_.WriteTo(ref output, _repeated_listenerFilters_codec);
      if (transparent_ != null) {
        _single_transparent_codec.WriteTagAndValue(ref output, Transparent);
      }
      if (freebind_ != null) {
        _single_freebind_codec.WriteTagAndValue(ref output, Freebind);
      }
      if (tcpFastOpenQueueLength_ != null) {
        _single_tcpFastOpenQueueLength_codec.WriteTagAndValue(ref output, TcpFastOpenQueueLength);
      }
      socketOptions_.WriteTo(ref output, _repeated_socketOptions_codec);
      if (listenerFiltersTimeout_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(ListenerFiltersTimeout);
      }
      if (TrafficDirection != global::Envoy.Config.Core.V3.TrafficDirection.Unspecified) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) TrafficDirection);
      }
      if (ContinueOnListenerFiltersTimeout != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(ContinueOnListenerFiltersTimeout);
      }
      if (udpListenerConfig_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(UdpListenerConfig);
      }
      if (apiListener_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ApiListener);
      }
      if (connectionBalanceConfig_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(ConnectionBalanceConfig);
      }
      if (ReusePort != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(ReusePort);
      }
      accessLog_.WriteTo(ref output, _repeated_accessLog_codec);
      if (tcpBacklogSize_ != null) {
        _single_tcpBacklogSize_codec.WriteTagAndValue(ref output, TcpBacklogSize);
      }
      if (defaultFilterChain_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(DefaultFilterChain);
      }
      if (bindToPort_ != null) {
        _single_bindToPort_codec.WriteTagAndValue(ref output, BindToPort);
      }
      if (listenerSpecifierCase_ == ListenerSpecifierOneofCase.InternalListener) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(InternalListener);
      }
      if (StatPrefix.Length != 0) {
        output.WriteRawTag(226, 1);
        output.WriteString(StatPrefix);
      }
      if (enableReusePort_ != null) {
        _single_enableReusePort_codec.WriteTagAndValue(ref output, EnableReusePort);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (address_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Address);
      }
      if (StatPrefix.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(StatPrefix);
      }
      size += filterChains_.CalculateSize(_repeated_filterChains_codec);
      if (useOriginalDst_ != null) {
        size += _single_useOriginalDst_codec.CalculateSizeWithTag(UseOriginalDst);
      }
      if (defaultFilterChain_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DefaultFilterChain);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        size += _single_perConnectionBufferLimitBytes_codec.CalculateSizeWithTag(PerConnectionBufferLimitBytes);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (deprecatedV1_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeprecatedV1);
      }
      if (DrainType != global::Envoy.Config.Listener.V3.Listener.Types.DrainType.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DrainType);
      }
      size += listenerFilters_.CalculateSize(_repeated_listenerFilters_codec);
      if (listenerFiltersTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ListenerFiltersTimeout);
      }
      if (ContinueOnListenerFiltersTimeout != false) {
        size += 2 + 1;
      }
      if (transparent_ != null) {
        size += _single_transparent_codec.CalculateSizeWithTag(Transparent);
      }
      if (freebind_ != null) {
        size += _single_freebind_codec.CalculateSizeWithTag(Freebind);
      }
      size += socketOptions_.CalculateSize(_repeated_socketOptions_codec);
      if (tcpFastOpenQueueLength_ != null) {
        size += _single_tcpFastOpenQueueLength_codec.CalculateSizeWithTag(TcpFastOpenQueueLength);
      }
      if (TrafficDirection != global::Envoy.Config.Core.V3.TrafficDirection.Unspecified) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) TrafficDirection);
      }
      if (udpListenerConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UdpListenerConfig);
      }
      if (apiListener_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ApiListener);
      }
      if (connectionBalanceConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ConnectionBalanceConfig);
      }
      if (ReusePort != false) {
        size += 2 + 1;
      }
      if (enableReusePort_ != null) {
        size += _single_enableReusePort_codec.CalculateSizeWithTag(EnableReusePort);
      }
      size += accessLog_.CalculateSize(_repeated_accessLog_codec);
      if (tcpBacklogSize_ != null) {
        size += _single_tcpBacklogSize_codec.CalculateSizeWithTag(TcpBacklogSize);
      }
      if (bindToPort_ != null) {
        size += _single_bindToPort_codec.CalculateSizeWithTag(BindToPort);
      }
      if (listenerSpecifierCase_ == ListenerSpecifierOneofCase.InternalListener) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(InternalListener);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Listener other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.address_ != null) {
        if (address_ == null) {
          Address = new global::Envoy.Config.Core.V3.Address();
        }
        Address.MergeFrom(other.Address);
      }
      if (other.StatPrefix.Length != 0) {
        StatPrefix = other.StatPrefix;
      }
      filterChains_.Add(other.filterChains_);
      if (other.useOriginalDst_ != null) {
        if (useOriginalDst_ == null || other.UseOriginalDst != false) {
          UseOriginalDst = other.UseOriginalDst;
        }
      }
      if (other.defaultFilterChain_ != null) {
        if (defaultFilterChain_ == null) {
          DefaultFilterChain = new global::Envoy.Config.Listener.V3.FilterChain();
        }
        DefaultFilterChain.MergeFrom(other.DefaultFilterChain);
      }
      if (other.perConnectionBufferLimitBytes_ != null) {
        if (perConnectionBufferLimitBytes_ == null || other.PerConnectionBufferLimitBytes != 0) {
          PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
        }
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::Envoy.Config.Core.V3.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.deprecatedV1_ != null) {
        if (deprecatedV1_ == null) {
          DeprecatedV1 = new global::Envoy.Config.Listener.V3.Listener.Types.DeprecatedV1();
        }
        DeprecatedV1.MergeFrom(other.DeprecatedV1);
      }
      if (other.DrainType != global::Envoy.Config.Listener.V3.Listener.Types.DrainType.Default) {
        DrainType = other.DrainType;
      }
      listenerFilters_.Add(other.listenerFilters_);
      if (other.listenerFiltersTimeout_ != null) {
        if (listenerFiltersTimeout_ == null) {
          ListenerFiltersTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        ListenerFiltersTimeout.MergeFrom(other.ListenerFiltersTimeout);
      }
      if (other.ContinueOnListenerFiltersTimeout != false) {
        ContinueOnListenerFiltersTimeout = other.ContinueOnListenerFiltersTimeout;
      }
      if (other.transparent_ != null) {
        if (transparent_ == null || other.Transparent != false) {
          Transparent = other.Transparent;
        }
      }
      if (other.freebind_ != null) {
        if (freebind_ == null || other.Freebind != false) {
          Freebind = other.Freebind;
        }
      }
      socketOptions_.Add(other.socketOptions_);
      if (other.tcpFastOpenQueueLength_ != null) {
        if (tcpFastOpenQueueLength_ == null || other.TcpFastOpenQueueLength != 0) {
          TcpFastOpenQueueLength = other.TcpFastOpenQueueLength;
        }
      }
      if (other.TrafficDirection != global::Envoy.Config.Core.V3.TrafficDirection.Unspecified) {
        TrafficDirection = other.TrafficDirection;
      }
      if (other.udpListenerConfig_ != null) {
        if (udpListenerConfig_ == null) {
          UdpListenerConfig = new global::Envoy.Config.Listener.V3.UdpListenerConfig();
        }
        UdpListenerConfig.MergeFrom(other.UdpListenerConfig);
      }
      if (other.apiListener_ != null) {
        if (apiListener_ == null) {
          ApiListener = new global::Envoy.Config.Listener.V3.ApiListener();
        }
        ApiListener.MergeFrom(other.ApiListener);
      }
      if (other.connectionBalanceConfig_ != null) {
        if (connectionBalanceConfig_ == null) {
          ConnectionBalanceConfig = new global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig();
        }
        ConnectionBalanceConfig.MergeFrom(other.ConnectionBalanceConfig);
      }
      if (other.ReusePort != false) {
        ReusePort = other.ReusePort;
      }
      if (other.enableReusePort_ != null) {
        if (enableReusePort_ == null || other.EnableReusePort != false) {
          EnableReusePort = other.EnableReusePort;
        }
      }
      accessLog_.Add(other.accessLog_);
      if (other.tcpBacklogSize_ != null) {
        if (tcpBacklogSize_ == null || other.TcpBacklogSize != 0) {
          TcpBacklogSize = other.TcpBacklogSize;
        }
      }
      if (other.bindToPort_ != null) {
        if (bindToPort_ == null || other.BindToPort != false) {
          BindToPort = other.BindToPort;
        }
      }
      switch (other.ListenerSpecifierCase) {
        case ListenerSpecifierOneofCase.InternalListener:
          if (InternalListener == null) {
            InternalListener = new global::Envoy.Config.Listener.V3.Listener.Types.InternalListenerConfig();
          }
          InternalListener.MergeFrom(other.InternalListener);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (address_ == null) {
              Address = new global::Envoy.Config.Core.V3.Address();
            }
            input.ReadMessage(Address);
            break;
          }
          case 26: {
            filterChains_.AddEntriesFrom(input, _repeated_filterChains_codec);
            break;
          }
          case 34: {
            bool? value = _single_useOriginalDst_codec.Read(input);
            if (useOriginalDst_ == null || value != false) {
              UseOriginalDst = value;
            }
            break;
          }
          case 42: {
            uint? value = _single_perConnectionBufferLimitBytes_codec.Read(input);
            if (perConnectionBufferLimitBytes_ == null || value != 0) {
              PerConnectionBufferLimitBytes = value;
            }
            break;
          }
          case 50: {
            if (metadata_ == null) {
              Metadata = new global::Envoy.Config.Core.V3.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 58: {
            if (deprecatedV1_ == null) {
              DeprecatedV1 = new global::Envoy.Config.Listener.V3.Listener.Types.DeprecatedV1();
            }
            input.ReadMessage(DeprecatedV1);
            break;
          }
          case 64: {
            DrainType = (global::Envoy.Config.Listener.V3.Listener.Types.DrainType) input.ReadEnum();
            break;
          }
          case 74: {
            listenerFilters_.AddEntriesFrom(input, _repeated_listenerFilters_codec);
            break;
          }
          case 82: {
            bool? value = _single_transparent_codec.Read(input);
            if (transparent_ == null || value != false) {
              Transparent = value;
            }
            break;
          }
          case 90: {
            bool? value = _single_freebind_codec.Read(input);
            if (freebind_ == null || value != false) {
              Freebind = value;
            }
            break;
          }
          case 98: {
            uint? value = _single_tcpFastOpenQueueLength_codec.Read(input);
            if (tcpFastOpenQueueLength_ == null || value != 0) {
              TcpFastOpenQueueLength = value;
            }
            break;
          }
          case 106: {
            socketOptions_.AddEntriesFrom(input, _repeated_socketOptions_codec);
            break;
          }
          case 122: {
            if (listenerFiltersTimeout_ == null) {
              ListenerFiltersTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(ListenerFiltersTimeout);
            break;
          }
          case 128: {
            TrafficDirection = (global::Envoy.Config.Core.V3.TrafficDirection) input.ReadEnum();
            break;
          }
          case 136: {
            ContinueOnListenerFiltersTimeout = input.ReadBool();
            break;
          }
          case 146: {
            if (udpListenerConfig_ == null) {
              UdpListenerConfig = new global::Envoy.Config.Listener.V3.UdpListenerConfig();
            }
            input.ReadMessage(UdpListenerConfig);
            break;
          }
          case 154: {
            if (apiListener_ == null) {
              ApiListener = new global::Envoy.Config.Listener.V3.ApiListener();
            }
            input.ReadMessage(ApiListener);
            break;
          }
          case 162: {
            if (connectionBalanceConfig_ == null) {
              ConnectionBalanceConfig = new global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig();
            }
            input.ReadMessage(ConnectionBalanceConfig);
            break;
          }
          case 168: {
            ReusePort = input.ReadBool();
            break;
          }
          case 178: {
            accessLog_.AddEntriesFrom(input, _repeated_accessLog_codec);
            break;
          }
          case 194: {
            uint? value = _single_tcpBacklogSize_codec.Read(input);
            if (tcpBacklogSize_ == null || value != 0) {
              TcpBacklogSize = value;
            }
            break;
          }
          case 202: {
            if (defaultFilterChain_ == null) {
              DefaultFilterChain = new global::Envoy.Config.Listener.V3.FilterChain();
            }
            input.ReadMessage(DefaultFilterChain);
            break;
          }
          case 210: {
            bool? value = _single_bindToPort_codec.Read(input);
            if (bindToPort_ == null || value != false) {
              BindToPort = value;
            }
            break;
          }
          case 218: {
            global::Envoy.Config.Listener.V3.Listener.Types.InternalListenerConfig subBuilder = new global::Envoy.Config.Listener.V3.Listener.Types.InternalListenerConfig();
            if (listenerSpecifierCase_ == ListenerSpecifierOneofCase.InternalListener) {
              subBuilder.MergeFrom(InternalListener);
            }
            input.ReadMessage(subBuilder);
            InternalListener = subBuilder;
            break;
          }
          case 226: {
            StatPrefix = input.ReadString();
            break;
          }
          case 234: {
            bool? value = _single_enableReusePort_codec.Read(input);
            if (enableReusePort_ == null || value != false) {
              EnableReusePort = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (address_ == null) {
              Address = new global::Envoy.Config.Core.V3.Address();
            }
            input.ReadMessage(Address);
            break;
          }
          case 26: {
            filterChains_.AddEntriesFrom(ref input, _repeated_filterChains_codec);
            break;
          }
          case 34: {
            bool? value = _single_useOriginalDst_codec.Read(ref input);
            if (useOriginalDst_ == null || value != false) {
              UseOriginalDst = value;
            }
            break;
          }
          case 42: {
            uint? value = _single_perConnectionBufferLimitBytes_codec.Read(ref input);
            if (perConnectionBufferLimitBytes_ == null || value != 0) {
              PerConnectionBufferLimitBytes = value;
            }
            break;
          }
          case 50: {
            if (metadata_ == null) {
              Metadata = new global::Envoy.Config.Core.V3.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 58: {
            if (deprecatedV1_ == null) {
              DeprecatedV1 = new global::Envoy.Config.Listener.V3.Listener.Types.DeprecatedV1();
            }
            input.ReadMessage(DeprecatedV1);
            break;
          }
          case 64: {
            DrainType = (global::Envoy.Config.Listener.V3.Listener.Types.DrainType) input.ReadEnum();
            break;
          }
          case 74: {
            listenerFilters_.AddEntriesFrom(ref input, _repeated_listenerFilters_codec);
            break;
          }
          case 82: {
            bool? value = _single_transparent_codec.Read(ref input);
            if (transparent_ == null || value != false) {
              Transparent = value;
            }
            break;
          }
          case 90: {
            bool? value = _single_freebind_codec.Read(ref input);
            if (freebind_ == null || value != false) {
              Freebind = value;
            }
            break;
          }
          case 98: {
            uint? value = _single_tcpFastOpenQueueLength_codec.Read(ref input);
            if (tcpFastOpenQueueLength_ == null || value != 0) {
              TcpFastOpenQueueLength = value;
            }
            break;
          }
          case 106: {
            socketOptions_.AddEntriesFrom(ref input, _repeated_socketOptions_codec);
            break;
          }
          case 122: {
            if (listenerFiltersTimeout_ == null) {
              ListenerFiltersTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(ListenerFiltersTimeout);
            break;
          }
          case 128: {
            TrafficDirection = (global::Envoy.Config.Core.V3.TrafficDirection) input.ReadEnum();
            break;
          }
          case 136: {
            ContinueOnListenerFiltersTimeout = input.ReadBool();
            break;
          }
          case 146: {
            if (udpListenerConfig_ == null) {
              UdpListenerConfig = new global::Envoy.Config.Listener.V3.UdpListenerConfig();
            }
            input.ReadMessage(UdpListenerConfig);
            break;
          }
          case 154: {
            if (apiListener_ == null) {
              ApiListener = new global::Envoy.Config.Listener.V3.ApiListener();
            }
            input.ReadMessage(ApiListener);
            break;
          }
          case 162: {
            if (connectionBalanceConfig_ == null) {
              ConnectionBalanceConfig = new global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig();
            }
            input.ReadMessage(ConnectionBalanceConfig);
            break;
          }
          case 168: {
            ReusePort = input.ReadBool();
            break;
          }
          case 178: {
            accessLog_.AddEntriesFrom(ref input, _repeated_accessLog_codec);
            break;
          }
          case 194: {
            uint? value = _single_tcpBacklogSize_codec.Read(ref input);
            if (tcpBacklogSize_ == null || value != 0) {
              TcpBacklogSize = value;
            }
            break;
          }
          case 202: {
            if (defaultFilterChain_ == null) {
              DefaultFilterChain = new global::Envoy.Config.Listener.V3.FilterChain();
            }
            input.ReadMessage(DefaultFilterChain);
            break;
          }
          case 210: {
            bool? value = _single_bindToPort_codec.Read(ref input);
            if (bindToPort_ == null || value != false) {
              BindToPort = value;
            }
            break;
          }
          case 218: {
            global::Envoy.Config.Listener.V3.Listener.Types.InternalListenerConfig subBuilder = new global::Envoy.Config.Listener.V3.Listener.Types.InternalListenerConfig();
            if (listenerSpecifierCase_ == ListenerSpecifierOneofCase.InternalListener) {
              subBuilder.MergeFrom(InternalListener);
            }
            input.ReadMessage(subBuilder);
            InternalListener = subBuilder;
            break;
          }
          case 226: {
            StatPrefix = input.ReadString();
            break;
          }
          case 234: {
            bool? value = _single_enableReusePort_codec.Read(ref input);
            if (enableReusePort_ == null || value != false) {
              EnableReusePort = value;
            }
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Listener message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum DrainType {
        /// <summary>
        /// Drain in response to calling /healthcheck/fail admin endpoint (along with the health check
        /// filter), listener removal/modification, and hot restart.
        /// </summary>
        [pbr::OriginalName("DEFAULT")] Default = 0,
        /// <summary>
        /// Drain in response to listener removal/modification and hot restart. This setting does not
        /// include /healthcheck/fail. This setting may be desirable if Envoy is hosting both ingress
        /// and egress listeners.
        /// </summary>
        [pbr::OriginalName("MODIFY_ONLY")] ModifyOnly = 1,
      }

      /// <summary>
      /// [#not-implemented-hide:]
      /// </summary>
      public sealed partial class DeprecatedV1 : pb::IMessage<DeprecatedV1>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<DeprecatedV1> _parser = new pb::MessageParser<DeprecatedV1>(() => new DeprecatedV1());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<DeprecatedV1> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Listener.V3.Listener.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DeprecatedV1() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DeprecatedV1(DeprecatedV1 other) : this() {
          BindToPort = other.BindToPort;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DeprecatedV1 Clone() {
          return new DeprecatedV1(this);
        }

        /// <summary>Field number for the "bind_to_port" field.</summary>
        public const int BindToPortFieldNumber = 1;
        private static readonly pb::FieldCodec<bool?> _single_bindToPort_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
        private bool? bindToPort_;
        /// <summary>
        /// Whether the listener should bind to the port. A listener that doesn't
        /// bind can only receive connections redirected from other listeners that
        /// set use_original_dst parameter to true. Default is true.
        ///
        /// This is deprecated. Use :ref:`Listener.bind_to_port
        /// &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port>`
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool? BindToPort {
          get { return bindToPort_; }
          set {
            bindToPort_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as DeprecatedV1);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(DeprecatedV1 other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (BindToPort != other.BindToPort) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (bindToPort_ != null) hash ^= BindToPort.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (bindToPort_ != null) {
            _single_bindToPort_codec.WriteTagAndValue(output, BindToPort);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (bindToPort_ != null) {
            _single_bindToPort_codec.WriteTagAndValue(ref output, BindToPort);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (bindToPort_ != null) {
            size += _single_bindToPort_codec.CalculateSizeWithTag(BindToPort);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(DeprecatedV1 other) {
          if (other == null) {
            return;
          }
          if (other.bindToPort_ != null) {
            if (bindToPort_ == null || other.BindToPort != false) {
              BindToPort = other.BindToPort;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                bool? value = _single_bindToPort_codec.Read(input);
                if (bindToPort_ == null || value != false) {
                  BindToPort = value;
                }
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                bool? value = _single_bindToPort_codec.Read(ref input);
                if (bindToPort_ == null || value != false) {
                  BindToPort = value;
                }
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Configuration for listener connection balancing.
      /// </summary>
      public sealed partial class ConnectionBalanceConfig : pb::IMessage<ConnectionBalanceConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ConnectionBalanceConfig> _parser = new pb::MessageParser<ConnectionBalanceConfig>(() => new ConnectionBalanceConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ConnectionBalanceConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Listener.V3.Listener.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConnectionBalanceConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConnectionBalanceConfig(ConnectionBalanceConfig other) : this() {
          switch (other.BalanceTypeCase) {
            case BalanceTypeOneofCase.ExactBalance:
              ExactBalance = other.ExactBalance.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConnectionBalanceConfig Clone() {
          return new ConnectionBalanceConfig(this);
        }

        /// <summary>Field number for the "exact_balance" field.</summary>
        public const int ExactBalanceFieldNumber = 1;
        /// <summary>
        /// If specified, the listener will use the exact connection balancer.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance ExactBalance {
          get { return balanceTypeCase_ == BalanceTypeOneofCase.ExactBalance ? (global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance) balanceType_ : null; }
          set {
            balanceType_ = value;
            balanceTypeCase_ = value == null ? BalanceTypeOneofCase.None : BalanceTypeOneofCase.ExactBalance;
          }
        }

        private object balanceType_;
        /// <summary>Enum of possible cases for the "balance_type" oneof.</summary>
        public enum BalanceTypeOneofCase {
          None = 0,
          ExactBalance = 1,
        }
        private BalanceTypeOneofCase balanceTypeCase_ = BalanceTypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BalanceTypeOneofCase BalanceTypeCase {
          get { return balanceTypeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearBalanceType() {
          balanceTypeCase_ = BalanceTypeOneofCase.None;
          balanceType_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ConnectionBalanceConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ConnectionBalanceConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(ExactBalance, other.ExactBalance)) return false;
          if (BalanceTypeCase != other.BalanceTypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (balanceTypeCase_ == BalanceTypeOneofCase.ExactBalance) hash ^= ExactBalance.GetHashCode();
          hash ^= (int) balanceTypeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (balanceTypeCase_ == BalanceTypeOneofCase.ExactBalance) {
            output.WriteRawTag(10);
            output.WriteMessage(ExactBalance);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (balanceTypeCase_ == BalanceTypeOneofCase.ExactBalance) {
            output.WriteRawTag(10);
            output.WriteMessage(ExactBalance);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (balanceTypeCase_ == BalanceTypeOneofCase.ExactBalance) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExactBalance);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ConnectionBalanceConfig other) {
          if (other == null) {
            return;
          }
          switch (other.BalanceTypeCase) {
            case BalanceTypeOneofCase.ExactBalance:
              if (ExactBalance == null) {
                ExactBalance = new global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance();
              }
              ExactBalance.MergeFrom(other.ExactBalance);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance subBuilder = new global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance();
                if (balanceTypeCase_ == BalanceTypeOneofCase.ExactBalance) {
                  subBuilder.MergeFrom(ExactBalance);
                }
                input.ReadMessage(subBuilder);
                ExactBalance = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance subBuilder = new global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig.Types.ExactBalance();
                if (balanceTypeCase_ == BalanceTypeOneofCase.ExactBalance) {
                  subBuilder.MergeFrom(ExactBalance);
                }
                input.ReadMessage(subBuilder);
                ExactBalance = subBuilder;
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the ConnectionBalanceConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// A connection balancer implementation that does exact balancing. This means that a lock is
          /// held during balancing so that connection counts are nearly exactly balanced between worker
          /// threads. This is "nearly" exact in the sense that a connection might close in parallel thus
          /// making the counts incorrect, but this should be rectified on the next accept. This balancer
          /// sacrifices accept throughput for accuracy and should be used when there are a small number of
          /// connections that rarely cycle (e.g., service mesh gRPC egress).
          /// </summary>
          public sealed partial class ExactBalance : pb::IMessage<ExactBalance>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<ExactBalance> _parser = new pb::MessageParser<ExactBalance>(() => new ExactBalance());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<ExactBalance> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Listener.V3.Listener.Types.ConnectionBalanceConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ExactBalance() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ExactBalance(ExactBalance other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ExactBalance Clone() {
              return new ExactBalance(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as ExactBalance);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(ExactBalance other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(ExactBalance other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

      /// <summary>
      /// Configuration for envoy internal listener. All the future internal listener features should be added here.
      /// [#not-implemented-hide:]
      /// </summary>
      public sealed partial class InternalListenerConfig : pb::IMessage<InternalListenerConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<InternalListenerConfig> _parser = new pb::MessageParser<InternalListenerConfig>(() => new InternalListenerConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<InternalListenerConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Listener.V3.Listener.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InternalListenerConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InternalListenerConfig(InternalListenerConfig other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InternalListenerConfig Clone() {
          return new InternalListenerConfig(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as InternalListenerConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(InternalListenerConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(InternalListenerConfig other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
