// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/extensions/retry/priority/previous_priorities/v3/previous_priorities_config.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Extensions.Retry.Priority.PreviousPriorities.V3 {

  /// <summary>Holder for reflection information generated from envoy/extensions/retry/priority/previous_priorities/v3/previous_priorities_config.proto</summary>
  public static partial class PreviousPrioritiesConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/extensions/retry/priority/previous_priorities/v3/previous_priorities_config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static PreviousPrioritiesConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CldlbnZveS9leHRlbnNpb25zL3JldHJ5L3ByaW9yaXR5L3ByZXZpb3VzX3By",
            "aW9yaXRpZXMvdjMvcHJldmlvdXNfcHJpb3JpdGllc19jb25maWcucHJvdG8S",
            "NmVudm95LmV4dGVuc2lvbnMucmV0cnkucHJpb3JpdHkucHJldmlvdXNfcHJp",
            "b3JpdGllcy52MxoddWRwYS9hbm5vdGF0aW9ucy9zdGF0dXMucHJvdG8aIXVk",
            "cGEvYW5ub3RhdGlvbnMvdmVyc2lvbmluZy5wcm90bxoXdmFsaWRhdGUvdmFs",
            "aWRhdGUucHJvdG8ihQEKGFByZXZpb3VzUHJpb3JpdGllc0NvbmZpZxIhChB1",
            "cGRhdGVfZnJlcXVlbmN5GAEgASgFQgf6QgQaAiAAOkaaxYgeQQo/ZW52b3ku",
            "Y29uZmlnLnJldHJ5LnByZXZpb3VzX3ByaW9yaXRpZXMuUHJldmlvdXNQcmlv",
            "cml0aWVzQ29uZmlnQm8KRGlvLmVudm95cHJveHkuZW52b3kuZXh0ZW5zaW9u",
            "cy5yZXRyeS5wcmlvcml0eS5wcmV2aW91c19wcmlvcml0aWVzLnYzQh1QcmV2",
            "aW91c1ByaW9yaXRpZXNDb25maWdQcm90b1ABuoDI0QYCEAJiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Retry.Priority.PreviousPriorities.V3.PreviousPrioritiesConfig), global::Envoy.Extensions.Retry.Priority.PreviousPriorities.V3.PreviousPrioritiesConfig.Parser, new[]{ "UpdateFrequency" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// A retry host selector that attempts to spread retries between priorities, even if certain
  /// priorities would not normally be attempted due to higher priorities being available.
  ///
  /// As priorities get excluded, load will be distributed amongst the remaining healthy priorities
  /// based on the relative health of the priorities, matching how load is distributed during regular
  /// host selection. For example, given priority healths of {100, 50, 50}, the original load will be
  /// {100, 0, 0} (since P0 has capacity to handle 100% of the traffic). If P0 is excluded, the load
  /// changes to {0, 50, 50}, because P1 is only able to handle 50% of the traffic, causing the
  /// remaining to spill over to P2.
  ///
  /// Each priority attempted will be excluded until there are no healthy priorities left, at which
  /// point the list of attempted priorities will be reset, essentially starting from the beginning.
  /// For example, given three priorities P0, P1, P2 with healthy % of 100, 0 and 50 respectively, the
  /// following sequence of priorities would be selected (assuming update_frequency = 1):
  /// Attempt 1: P0 (P0 is 100% healthy)
  /// Attempt 2: P2 (P0 already attempted, P2 only healthy priority)
  /// Attempt 3: P0 (no healthy priorities, reset)
  /// Attempt 4: P2
  ///
  /// In the case of all upstream hosts being unhealthy, no adjustments will be made to the original
  /// priority load, so behavior should be identical to not using this plugin.
  ///
  /// Using this PriorityFilter requires rebuilding the priority load, which runs in O(# of
  /// priorities), which might incur significant overhead for clusters with many priorities.
  /// [#extension: envoy.retry_priorities.previous_priorities]
  /// </summary>
  public sealed partial class PreviousPrioritiesConfig : pb::IMessage<PreviousPrioritiesConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PreviousPrioritiesConfig> _parser = new pb::MessageParser<PreviousPrioritiesConfig>(() => new PreviousPrioritiesConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PreviousPrioritiesConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Retry.Priority.PreviousPriorities.V3.PreviousPrioritiesConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PreviousPrioritiesConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PreviousPrioritiesConfig(PreviousPrioritiesConfig other) : this() {
      updateFrequency_ = other.updateFrequency_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PreviousPrioritiesConfig Clone() {
      return new PreviousPrioritiesConfig(this);
    }

    /// <summary>Field number for the "update_frequency" field.</summary>
    public const int UpdateFrequencyFieldNumber = 1;
    private int updateFrequency_;
    /// <summary>
    /// How often the priority load should be updated based on previously attempted priorities. Useful
    /// to allow each priorities to receive more than one request before being excluded or to reduce
    /// the number of times that the priority load has to be recomputed.
    ///
    /// For example, by setting this to 2, then the first two attempts (initial attempt and first
    /// retry) will use the unmodified priority load. The third and fourth attempt will use priority
    /// load which excludes the priorities routed to with the first two attempts, and the fifth and
    /// sixth attempt will use the priority load excluding the priorities used for the first four
    /// attempts.
    ///
    /// Must be greater than 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int UpdateFrequency {
      get { return updateFrequency_; }
      set {
        updateFrequency_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PreviousPrioritiesConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PreviousPrioritiesConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (UpdateFrequency != other.UpdateFrequency) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (UpdateFrequency != 0) hash ^= UpdateFrequency.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (UpdateFrequency != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(UpdateFrequency);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (UpdateFrequency != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(UpdateFrequency);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (UpdateFrequency != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(UpdateFrequency);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PreviousPrioritiesConfig other) {
      if (other == null) {
        return;
      }
      if (other.UpdateFrequency != 0) {
        UpdateFrequency = other.UpdateFrequency;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            UpdateFrequency = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            UpdateFrequency = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
