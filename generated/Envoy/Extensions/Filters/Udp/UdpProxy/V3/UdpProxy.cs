// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/extensions/filters/udp/udp_proxy/v3/udp_proxy.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Extensions.Filters.Udp.UdpProxy.V3 {

  /// <summary>Holder for reflection information generated from envoy/extensions/filters/udp/udp_proxy/v3/udp_proxy.proto</summary>
  public static partial class UdpProxyReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/extensions/filters/udp/udp_proxy/v3/udp_proxy.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static UdpProxyReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjllbnZveS9leHRlbnNpb25zL2ZpbHRlcnMvdWRwL3VkcF9wcm94eS92My91",
            "ZHBfcHJveHkucHJvdG8SKWVudm95LmV4dGVuc2lvbnMuZmlsdGVycy51ZHAu",
            "dWRwX3Byb3h5LnYzGixlbnZveS9jb25maWcvY29yZS92My91ZHBfc29ja2V0",
            "X2NvbmZpZy5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3Rv",
            "Gh11ZHBhL2Fubm90YXRpb25zL3N0YXR1cy5wcm90bxohdWRwYS9hbm5vdGF0",
            "aW9ucy92ZXJzaW9uaW5nLnByb3RvGhd2YWxpZGF0ZS92YWxpZGF0ZS5wcm90",
            "byL8AwoOVWRwUHJveHlDb25maWcSHAoLc3RhdF9wcmVmaXgYASABKAlCB/pC",
            "BHICEAESGgoHY2x1c3RlchgCIAEoCUIH+kIEcgIQAUgAEi8KDGlkbGVfdGlt",
            "ZW91dBgDIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIbChN1c2Vf",
            "b3JpZ2luYWxfc3JjX2lwGAQgASgIEmUKDWhhc2hfcG9saWNpZXMYBSADKAsy",
            "RC5lbnZveS5leHRlbnNpb25zLmZpbHRlcnMudWRwLnVkcF9wcm94eS52My5V",
            "ZHBQcm94eUNvbmZpZy5IYXNoUG9saWN5Qgj6QgWSAQIQARJFChZ1cHN0cmVh",
            "bV9zb2NrZXRfY29uZmlnGAYgASgLMiUuZW52b3kuY29uZmlnLmNvcmUudjMu",
            "VWRwU29ja2V0Q29uZmlnGlsKCkhhc2hQb2xpY3kSHAoJc291cmNlX2lwGAEg",
            "ASgIQgf6QgRqAggBSAASFgoDa2V5GAIgASgJQgf6QgRyAhABSABCFwoQcG9s",
            "aWN5X3NwZWNpZmllchID+EIBOj+axYgeOgo4ZW52b3kuY29uZmlnLmZpbHRl",
            "ci51ZHAudWRwX3Byb3h5LnYyYWxwaGEuVWRwUHJveHlDb25maWdCFgoPcm91",
            "dGVfc3BlY2lmaWVyEgP4QgFCUgo3aW8uZW52b3lwcm94eS5lbnZveS5leHRl",
            "bnNpb25zLmZpbHRlcnMudWRwLnVkcF9wcm94eS52M0INVWRwUHJveHlQcm90",
            "b1ABuoDI0QYCEAJiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Core.V3.UdpSocketConfigReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Udp.UdpProxy.V3.UdpProxyConfig), global::Envoy.Extensions.Filters.Udp.UdpProxy.V3.UdpProxyConfig.Parser, new[]{ "StatPrefix", "Cluster", "IdleTimeout", "UseOriginalSrcIp", "HashPolicies", "UpstreamSocketConfig" }, new[]{ "RouteSpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Udp.UdpProxy.V3.UdpProxyConfig.Types.HashPolicy), global::Envoy.Extensions.Filters.Udp.UdpProxy.V3.UdpProxyConfig.Types.HashPolicy.Parser, new[]{ "SourceIp", "Key" }, new[]{ "PolicySpecifier" }, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration for the UDP proxy filter.
  /// [#next-free-field: 7]
  /// </summary>
  public sealed partial class UdpProxyConfig : pb::IMessage<UdpProxyConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UdpProxyConfig> _parser = new pb::MessageParser<UdpProxyConfig>(() => new UdpProxyConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UdpProxyConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Udp.UdpProxy.V3.UdpProxyReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UdpProxyConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UdpProxyConfig(UdpProxyConfig other) : this() {
      statPrefix_ = other.statPrefix_;
      idleTimeout_ = other.idleTimeout_ != null ? other.idleTimeout_.Clone() : null;
      useOriginalSrcIp_ = other.useOriginalSrcIp_;
      hashPolicies_ = other.hashPolicies_.Clone();
      upstreamSocketConfig_ = other.upstreamSocketConfig_ != null ? other.upstreamSocketConfig_.Clone() : null;
      switch (other.RouteSpecifierCase) {
        case RouteSpecifierOneofCase.Cluster:
          Cluster = other.Cluster;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UdpProxyConfig Clone() {
      return new UdpProxyConfig(this);
    }

    /// <summary>Field number for the "stat_prefix" field.</summary>
    public const int StatPrefixFieldNumber = 1;
    private string statPrefix_ = "";
    /// <summary>
    /// The stat prefix used when emitting UDP proxy filter stats.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StatPrefix {
      get { return statPrefix_; }
      set {
        statPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "cluster" field.</summary>
    public const int ClusterFieldNumber = 2;
    /// <summary>
    /// The upstream cluster to connect to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Cluster {
      get { return routeSpecifierCase_ == RouteSpecifierOneofCase.Cluster ? (string) routeSpecifier_ : ""; }
      set {
        routeSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        routeSpecifierCase_ = RouteSpecifierOneofCase.Cluster;
      }
    }

    /// <summary>Field number for the "idle_timeout" field.</summary>
    public const int IdleTimeoutFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration idleTimeout_;
    /// <summary>
    /// The idle timeout for sessions. Idle is defined as no datagrams between received or sent by
    /// the session. The default if not specified is 1 minute.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration IdleTimeout {
      get { return idleTimeout_; }
      set {
        idleTimeout_ = value;
      }
    }

    /// <summary>Field number for the "use_original_src_ip" field.</summary>
    public const int UseOriginalSrcIpFieldNumber = 4;
    private bool useOriginalSrcIp_;
    /// <summary>
    /// Use the remote downstream IP address as the sender IP address when sending packets to upstream hosts.
    /// This option requires Envoy to be run with the *CAP_NET_ADMIN* capability on Linux.
    /// And the IPv6 stack must be enabled on Linux kernel.
    /// This option does not preserve the remote downstream port.
    /// If this option is enabled, the IP address of sent datagrams will be changed to the remote downstream IP address.
    /// This means that Envoy will not receive packets that are sent by upstream hosts because the upstream hosts
    /// will send the packets with the remote downstream IP address as the destination. All packets will be routed
    /// to the remote downstream directly if there are route rules on the upstream host side.
    /// There are two options to return the packets back to the remote downstream.
    /// The first one is to use DSR (Direct Server Return).
    /// The other one is to configure routing rules on the upstream hosts to forward
    /// all packets back to Envoy and configure iptables rules on the host running Envoy to
    /// forward all packets from upstream hosts to the Envoy process so that Envoy can forward the packets to the downstream.
    /// If the platform does not support this option, Envoy will raise a configuration error.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UseOriginalSrcIp {
      get { return useOriginalSrcIp_; }
      set {
        useOriginalSrcIp_ = value;
      }
    }

    /// <summary>Field number for the "hash_policies" field.</summary>
    public const int HashPoliciesFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Envoy.Extensions.Filters.Udp.UdpProxy.V3.UdpProxyConfig.Types.HashPolicy> _repeated_hashPolicies_codec
        = pb::FieldCodec.ForMessage(42, global::Envoy.Extensions.Filters.Udp.UdpProxy.V3.UdpProxyConfig.Types.HashPolicy.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Extensions.Filters.Udp.UdpProxy.V3.UdpProxyConfig.Types.HashPolicy> hashPolicies_ = new pbc::RepeatedField<global::Envoy.Extensions.Filters.Udp.UdpProxy.V3.UdpProxyConfig.Types.HashPolicy>();
    /// <summary>
    /// Optional configuration for UDP proxy hash policies. If hash_policies is not set, the hash-based
    /// load balancing algorithms will select a host randomly. Currently the number of hash policies is
    /// limited to 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Extensions.Filters.Udp.UdpProxy.V3.UdpProxyConfig.Types.HashPolicy> HashPolicies {
      get { return hashPolicies_; }
    }

    /// <summary>Field number for the "upstream_socket_config" field.</summary>
    public const int UpstreamSocketConfigFieldNumber = 6;
    private global::Envoy.Config.Core.V3.UdpSocketConfig upstreamSocketConfig_;
    /// <summary>
    /// UDP socket configuration for upstream sockets. The default for
    /// :ref:`prefer_gro &lt;envoy_v3_api_field_config.core.v3.UdpSocketConfig.prefer_gro>` is true for upstream
    /// sockets as the assumption is datagrams will be received from a single source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.UdpSocketConfig UpstreamSocketConfig {
      get { return upstreamSocketConfig_; }
      set {
        upstreamSocketConfig_ = value;
      }
    }

    private object routeSpecifier_;
    /// <summary>Enum of possible cases for the "route_specifier" oneof.</summary>
    public enum RouteSpecifierOneofCase {
      None = 0,
      Cluster = 2,
    }
    private RouteSpecifierOneofCase routeSpecifierCase_ = RouteSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RouteSpecifierOneofCase RouteSpecifierCase {
      get { return routeSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRouteSpecifier() {
      routeSpecifierCase_ = RouteSpecifierOneofCase.None;
      routeSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UdpProxyConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UdpProxyConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StatPrefix != other.StatPrefix) return false;
      if (Cluster != other.Cluster) return false;
      if (!object.Equals(IdleTimeout, other.IdleTimeout)) return false;
      if (UseOriginalSrcIp != other.UseOriginalSrcIp) return false;
      if(!hashPolicies_.Equals(other.hashPolicies_)) return false;
      if (!object.Equals(UpstreamSocketConfig, other.UpstreamSocketConfig)) return false;
      if (RouteSpecifierCase != other.RouteSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (StatPrefix.Length != 0) hash ^= StatPrefix.GetHashCode();
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.Cluster) hash ^= Cluster.GetHashCode();
      if (idleTimeout_ != null) hash ^= IdleTimeout.GetHashCode();
      if (UseOriginalSrcIp != false) hash ^= UseOriginalSrcIp.GetHashCode();
      hash ^= hashPolicies_.GetHashCode();
      if (upstreamSocketConfig_ != null) hash ^= UpstreamSocketConfig.GetHashCode();
      hash ^= (int) routeSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (StatPrefix.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(StatPrefix);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.Cluster) {
        output.WriteRawTag(18);
        output.WriteString(Cluster);
      }
      if (idleTimeout_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(IdleTimeout);
      }
      if (UseOriginalSrcIp != false) {
        output.WriteRawTag(32);
        output.WriteBool(UseOriginalSrcIp);
      }
      hashPolicies_.WriteTo(output, _repeated_hashPolicies_codec);
      if (upstreamSocketConfig_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(UpstreamSocketConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (StatPrefix.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(StatPrefix);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.Cluster) {
        output.WriteRawTag(18);
        output.WriteString(Cluster);
      }
      if (idleTimeout_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(IdleTimeout);
      }
      if (UseOriginalSrcIp != false) {
        output.WriteRawTag(32);
        output.WriteBool(UseOriginalSrcIp);
      }
      hashPolicies_.WriteTo(ref output, _repeated_hashPolicies_codec);
      if (upstreamSocketConfig_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(UpstreamSocketConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (StatPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StatPrefix);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.Cluster) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Cluster);
      }
      if (idleTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(IdleTimeout);
      }
      if (UseOriginalSrcIp != false) {
        size += 1 + 1;
      }
      size += hashPolicies_.CalculateSize(_repeated_hashPolicies_codec);
      if (upstreamSocketConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpstreamSocketConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UdpProxyConfig other) {
      if (other == null) {
        return;
      }
      if (other.StatPrefix.Length != 0) {
        StatPrefix = other.StatPrefix;
      }
      if (other.idleTimeout_ != null) {
        if (idleTimeout_ == null) {
          IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        IdleTimeout.MergeFrom(other.IdleTimeout);
      }
      if (other.UseOriginalSrcIp != false) {
        UseOriginalSrcIp = other.UseOriginalSrcIp;
      }
      hashPolicies_.Add(other.hashPolicies_);
      if (other.upstreamSocketConfig_ != null) {
        if (upstreamSocketConfig_ == null) {
          UpstreamSocketConfig = new global::Envoy.Config.Core.V3.UdpSocketConfig();
        }
        UpstreamSocketConfig.MergeFrom(other.UpstreamSocketConfig);
      }
      switch (other.RouteSpecifierCase) {
        case RouteSpecifierOneofCase.Cluster:
          Cluster = other.Cluster;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            StatPrefix = input.ReadString();
            break;
          }
          case 18: {
            Cluster = input.ReadString();
            break;
          }
          case 26: {
            if (idleTimeout_ == null) {
              IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(IdleTimeout);
            break;
          }
          case 32: {
            UseOriginalSrcIp = input.ReadBool();
            break;
          }
          case 42: {
            hashPolicies_.AddEntriesFrom(input, _repeated_hashPolicies_codec);
            break;
          }
          case 50: {
            if (upstreamSocketConfig_ == null) {
              UpstreamSocketConfig = new global::Envoy.Config.Core.V3.UdpSocketConfig();
            }
            input.ReadMessage(UpstreamSocketConfig);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            StatPrefix = input.ReadString();
            break;
          }
          case 18: {
            Cluster = input.ReadString();
            break;
          }
          case 26: {
            if (idleTimeout_ == null) {
              IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(IdleTimeout);
            break;
          }
          case 32: {
            UseOriginalSrcIp = input.ReadBool();
            break;
          }
          case 42: {
            hashPolicies_.AddEntriesFrom(ref input, _repeated_hashPolicies_codec);
            break;
          }
          case 50: {
            if (upstreamSocketConfig_ == null) {
              UpstreamSocketConfig = new global::Envoy.Config.Core.V3.UdpSocketConfig();
            }
            input.ReadMessage(UpstreamSocketConfig);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the UdpProxyConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Specifies the UDP hash policy.
      /// The packets can be routed by hash policy.
      /// </summary>
      public sealed partial class HashPolicy : pb::IMessage<HashPolicy>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<HashPolicy> _parser = new pb::MessageParser<HashPolicy>(() => new HashPolicy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<HashPolicy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Extensions.Filters.Udp.UdpProxy.V3.UdpProxyConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HashPolicy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HashPolicy(HashPolicy other) : this() {
          switch (other.PolicySpecifierCase) {
            case PolicySpecifierOneofCase.SourceIp:
              SourceIp = other.SourceIp;
              break;
            case PolicySpecifierOneofCase.Key:
              Key = other.Key;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HashPolicy Clone() {
          return new HashPolicy(this);
        }

        /// <summary>Field number for the "source_ip" field.</summary>
        public const int SourceIpFieldNumber = 1;
        /// <summary>
        /// The source IP will be used to compute the hash used by hash-based load balancing algorithms.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool SourceIp {
          get { return policySpecifierCase_ == PolicySpecifierOneofCase.SourceIp ? (bool) policySpecifier_ : false; }
          set {
            policySpecifier_ = value;
            policySpecifierCase_ = PolicySpecifierOneofCase.SourceIp;
          }
        }

        /// <summary>Field number for the "key" field.</summary>
        public const int KeyFieldNumber = 2;
        /// <summary>
        /// A given key will be used to compute the hash used by hash-based load balancing algorithms.
        /// In certain cases there is a need to direct different UDP streams jointly towards the selected set of endpoints.
        /// A possible use-case is VoIP telephony, where media (RTP) and its corresponding control (RTCP) belong to the same logical session,
        /// although they travel in separate streams. To ensure that these pair of streams are load-balanced on session level
        /// (instead of individual stream level), dynamically created listeners can use the same hash key for each stream in the session.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Key {
          get { return policySpecifierCase_ == PolicySpecifierOneofCase.Key ? (string) policySpecifier_ : ""; }
          set {
            policySpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            policySpecifierCase_ = PolicySpecifierOneofCase.Key;
          }
        }

        private object policySpecifier_;
        /// <summary>Enum of possible cases for the "policy_specifier" oneof.</summary>
        public enum PolicySpecifierOneofCase {
          None = 0,
          SourceIp = 1,
          Key = 2,
        }
        private PolicySpecifierOneofCase policySpecifierCase_ = PolicySpecifierOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PolicySpecifierOneofCase PolicySpecifierCase {
          get { return policySpecifierCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearPolicySpecifier() {
          policySpecifierCase_ = PolicySpecifierOneofCase.None;
          policySpecifier_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as HashPolicy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(HashPolicy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (SourceIp != other.SourceIp) return false;
          if (Key != other.Key) return false;
          if (PolicySpecifierCase != other.PolicySpecifierCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (policySpecifierCase_ == PolicySpecifierOneofCase.SourceIp) hash ^= SourceIp.GetHashCode();
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Key) hash ^= Key.GetHashCode();
          hash ^= (int) policySpecifierCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (policySpecifierCase_ == PolicySpecifierOneofCase.SourceIp) {
            output.WriteRawTag(8);
            output.WriteBool(SourceIp);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Key) {
            output.WriteRawTag(18);
            output.WriteString(Key);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (policySpecifierCase_ == PolicySpecifierOneofCase.SourceIp) {
            output.WriteRawTag(8);
            output.WriteBool(SourceIp);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Key) {
            output.WriteRawTag(18);
            output.WriteString(Key);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (policySpecifierCase_ == PolicySpecifierOneofCase.SourceIp) {
            size += 1 + 1;
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Key) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(HashPolicy other) {
          if (other == null) {
            return;
          }
          switch (other.PolicySpecifierCase) {
            case PolicySpecifierOneofCase.SourceIp:
              SourceIp = other.SourceIp;
              break;
            case PolicySpecifierOneofCase.Key:
              Key = other.Key;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                SourceIp = input.ReadBool();
                break;
              }
              case 18: {
                Key = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                SourceIp = input.ReadBool();
                break;
              }
              case 18: {
                Key = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
