// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/rbac/v2/rbac.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Rbac.V2 {

  /// <summary>Holder for reflection information generated from envoy/config/rbac/v2/rbac.proto</summary>
  public static partial class RbacReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/rbac/v2/rbac.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RbacReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ch9lbnZveS9jb25maWcvcmJhYy92Mi9yYmFjLnByb3RvEhRlbnZveS5jb25m",
            "aWcucmJhYy52MhofZW52b3kvYXBpL3YyL2NvcmUvYWRkcmVzcy5wcm90bxop",
            "ZW52b3kvYXBpL3YyL3JvdXRlL3JvdXRlX2NvbXBvbmVudHMucHJvdG8aIWVu",
            "dm95L3R5cGUvbWF0Y2hlci9tZXRhZGF0YS5wcm90bxodZW52b3kvdHlwZS9t",
            "YXRjaGVyL3BhdGgucHJvdG8aH2Vudm95L3R5cGUvbWF0Y2hlci9zdHJpbmcu",
            "cHJvdG8aJWdvb2dsZS9hcGkvZXhwci92MWFscGhhMS9zeW50YXgucHJvdG8a",
            "HXVkcGEvYW5ub3RhdGlvbnMvc3RhdHVzLnByb3RvGhd2YWxpZGF0ZS92YWxp",
            "ZGF0ZS5wcm90byLjAQoEUkJBQxIxCgZhY3Rpb24YASABKA4yIS5lbnZveS5j",
            "b25maWcucmJhYy52Mi5SQkFDLkFjdGlvbhI6Cghwb2xpY2llcxgCIAMoCzIo",
            "LmVudm95LmNvbmZpZy5yYmFjLnYyLlJCQUMuUG9saWNpZXNFbnRyeRpNCg1Q",
            "b2xpY2llc0VudHJ5EgsKA2tleRgBIAEoCRIrCgV2YWx1ZRgCIAEoCzIcLmVu",
            "dm95LmNvbmZpZy5yYmFjLnYyLlBvbGljeToCOAEiHQoGQWN0aW9uEgkKBUFM",
            "TE9XEAASCAoEREVOWRABIrsBCgZQb2xpY3kSPwoLcGVybWlzc2lvbnMYASAD",
            "KAsyIC5lbnZveS5jb25maWcucmJhYy52Mi5QZXJtaXNzaW9uQgj6QgWSAQII",
            "ARI9CgpwcmluY2lwYWxzGAIgAygLMh8uZW52b3kuY29uZmlnLnJiYWMudjIu",
            "UHJpbmNpcGFsQgj6QgWSAQIIARIxCgljb25kaXRpb24YAyABKAsyHi5nb29n",
            "bGUuYXBpLmV4cHIudjFhbHBoYTEuRXhwciLkBAoKUGVybWlzc2lvbhI5Cglh",
            "bmRfcnVsZXMYASABKAsyJC5lbnZveS5jb25maWcucmJhYy52Mi5QZXJtaXNz",
            "aW9uLlNldEgAEjgKCG9yX3J1bGVzGAIgASgLMiQuZW52b3kuY29uZmlnLnJi",
            "YWMudjIuUGVybWlzc2lvbi5TZXRIABIWCgNhbnkYAyABKAhCB/pCBGoCCAFI",
            "ABIzCgZoZWFkZXIYBCABKAsyIS5lbnZveS5hcGkudjIucm91dGUuSGVhZGVy",
            "TWF0Y2hlckgAEjMKCHVybF9wYXRoGAogASgLMh8uZW52b3kudHlwZS5tYXRj",
            "aGVyLlBhdGhNYXRjaGVySAASNgoOZGVzdGluYXRpb25faXAYBSABKAsyHC5l",
            "bnZveS5hcGkudjIuY29yZS5DaWRyUmFuZ2VIABIlChBkZXN0aW5hdGlvbl9w",
            "b3J0GAYgASgNQgn6QgYqBBj//wNIABI3CghtZXRhZGF0YRgHIAEoCzIjLmVu",
            "dm95LnR5cGUubWF0Y2hlci5NZXRhZGF0YU1hdGNoZXJIABI0Cghub3RfcnVs",
            "ZRgIIAEoCzIgLmVudm95LmNvbmZpZy5yYmFjLnYyLlBlcm1pc3Npb25IABJC",
            "ChVyZXF1ZXN0ZWRfc2VydmVyX25hbWUYCSABKAsyIS5lbnZveS50eXBlLm1h",
            "dGNoZXIuU3RyaW5nTWF0Y2hlckgAGkAKA1NldBI5CgVydWxlcxgBIAMoCzIg",
            "LmVudm95LmNvbmZpZy5yYmFjLnYyLlBlcm1pc3Npb25CCPpCBZIBAggBQgsK",
            "BHJ1bGUSA/hCASL4BQoJUHJpbmNpcGFsEjYKB2FuZF9pZHMYASABKAsyIy5l",
            "bnZveS5jb25maWcucmJhYy52Mi5QcmluY2lwYWwuU2V0SAASNQoGb3JfaWRz",
            "GAIgASgLMiMuZW52b3kuY29uZmlnLnJiYWMudjIuUHJpbmNpcGFsLlNldEgA",
            "EhYKA2FueRgDIAEoCEIH+kIEagIIAUgAEkYKDWF1dGhlbnRpY2F0ZWQYBCAB",
            "KAsyLS5lbnZveS5jb25maWcucmJhYy52Mi5QcmluY2lwYWwuQXV0aGVudGlj",
            "YXRlZEgAEjUKCXNvdXJjZV9pcBgFIAEoCzIcLmVudm95LmFwaS52Mi5jb3Jl",
            "LkNpZHJSYW5nZUICGAFIABI4ChBkaXJlY3RfcmVtb3RlX2lwGAogASgLMhwu",
            "ZW52b3kuYXBpLnYyLmNvcmUuQ2lkclJhbmdlSAASMQoJcmVtb3RlX2lwGAsg",
            "ASgLMhwuZW52b3kuYXBpLnYyLmNvcmUuQ2lkclJhbmdlSAASMwoGaGVhZGVy",
            "GAYgASgLMiEuZW52b3kuYXBpLnYyLnJvdXRlLkhlYWRlck1hdGNoZXJIABIz",
            "Cgh1cmxfcGF0aBgJIAEoCzIfLmVudm95LnR5cGUubWF0Y2hlci5QYXRoTWF0",
            "Y2hlckgAEjcKCG1ldGFkYXRhGAcgASgLMiMuZW52b3kudHlwZS5tYXRjaGVy",
            "Lk1ldGFkYXRhTWF0Y2hlckgAEjEKBm5vdF9pZBgIIAEoCzIfLmVudm95LmNv",
            "bmZpZy5yYmFjLnYyLlByaW5jaXBhbEgAGj0KA1NldBI2CgNpZHMYASADKAsy",
            "Hy5lbnZveS5jb25maWcucmJhYy52Mi5QcmluY2lwYWxCCPpCBZIBAggBGlAK",
            "DUF1dGhlbnRpY2F0ZWQSOQoOcHJpbmNpcGFsX25hbWUYAiABKAsyIS5lbnZv",
            "eS50eXBlLm1hdGNoZXIuU3RyaW5nTWF0Y2hlckoECAEQAkIRCgppZGVudGlm",
            "aWVyEgP4QgFCOQoiaW8uZW52b3lwcm94eS5lbnZveS5jb25maWcucmJhYy52",
            "MkIJUmJhY1Byb3RvUAG6gMjRBgIQAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.AddressReflection.Descriptor, global::Envoy.Api.V2.Route.RouteComponentsReflection.Descriptor, global::Envoy.Type.Matcher.MetadataReflection.Descriptor, global::Envoy.Type.Matcher.PathReflection.Descriptor, global::Envoy.Type.Matcher.StringReflection.Descriptor, global::Google.Api.Expr.V1Alpha1.SyntaxReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2.RBAC), global::Envoy.Config.Rbac.V2.RBAC.Parser, new[]{ "Action", "Policies" }, null, new[]{ typeof(global::Envoy.Config.Rbac.V2.RBAC.Types.Action) }, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2.Policy), global::Envoy.Config.Rbac.V2.Policy.Parser, new[]{ "Permissions", "Principals", "Condition" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2.Permission), global::Envoy.Config.Rbac.V2.Permission.Parser, new[]{ "AndRules", "OrRules", "Any", "Header", "UrlPath", "DestinationIp", "DestinationPort", "Metadata", "NotRule", "RequestedServerName" }, new[]{ "Rule" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2.Permission.Types.Set), global::Envoy.Config.Rbac.V2.Permission.Types.Set.Parser, new[]{ "Rules" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2.Principal), global::Envoy.Config.Rbac.V2.Principal.Parser, new[]{ "AndIds", "OrIds", "Any", "Authenticated", "SourceIp", "DirectRemoteIp", "RemoteIp", "Header", "UrlPath", "Metadata", "NotId" }, new[]{ "Identifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2.Principal.Types.Set), global::Envoy.Config.Rbac.V2.Principal.Types.Set.Parser, new[]{ "Ids" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated), global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated.Parser, new[]{ "PrincipalName" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Role Based Access Control (RBAC) provides service-level and method-level access control for a
  /// service. RBAC policies are additive. The policies are examined in order. A request is allowed
  /// once a matching policy is found (suppose the `action` is ALLOW).
  ///
  /// Here is an example of RBAC configuration. It has two policies:
  ///
  /// * Service account "cluster.local/ns/default/sa/admin" has full access to the service, and so
  ///   does "cluster.local/ns/default/sa/superuser".
  ///
  /// * Any user can read ("GET") the service at paths with prefix "/products", so long as the
  ///   destination port is either 80 or 443.
  ///
  ///  .. code-block:: yaml
  ///
  ///   action: ALLOW
  ///   policies:
  ///     "service-admin":
  ///       permissions:
  ///         - any: true
  ///       principals:
  ///         - authenticated:
  ///             principal_name:
  ///               exact: "cluster.local/ns/default/sa/admin"
  ///         - authenticated:
  ///             principal_name:
  ///               exact: "cluster.local/ns/default/sa/superuser"
  ///     "product-viewer":
  ///       permissions:
  ///           - and_rules:
  ///               rules:
  ///                 - header: { name: ":method", exact_match: "GET" }
  ///                 - url_path:
  ///                     path: { prefix: "/products" }
  ///                 - or_rules:
  ///                     rules:
  ///                       - destination_port: 80
  ///                       - destination_port: 443
  ///       principals:
  ///         - any: true
  ///
  /// </summary>
  public sealed partial class RBAC : pb::IMessage<RBAC>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RBAC> _parser = new pb::MessageParser<RBAC>(() => new RBAC());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RBAC> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V2.RbacReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RBAC() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RBAC(RBAC other) : this() {
      action_ = other.action_;
      policies_ = other.policies_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RBAC Clone() {
      return new RBAC(this);
    }

    /// <summary>Field number for the "action" field.</summary>
    public const int ActionFieldNumber = 1;
    private global::Envoy.Config.Rbac.V2.RBAC.Types.Action action_ = global::Envoy.Config.Rbac.V2.RBAC.Types.Action.Allow;
    /// <summary>
    /// The action to take if a policy matches. The request is allowed if and only if:
    ///
    ///   * `action` is "ALLOWED" and at least one policy matches
    ///   * `action` is "DENY" and none of the policies match
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V2.RBAC.Types.Action Action {
      get { return action_; }
      set {
        action_ = value;
      }
    }

    /// <summary>Field number for the "policies" field.</summary>
    public const int PoliciesFieldNumber = 2;
    private static readonly pbc::MapField<string, global::Envoy.Config.Rbac.V2.Policy>.Codec _map_policies_codec
        = new pbc::MapField<string, global::Envoy.Config.Rbac.V2.Policy>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Envoy.Config.Rbac.V2.Policy.Parser), 18);
    private readonly pbc::MapField<string, global::Envoy.Config.Rbac.V2.Policy> policies_ = new pbc::MapField<string, global::Envoy.Config.Rbac.V2.Policy>();
    /// <summary>
    /// Maps from policy name to policy. A match occurs when at least one policy matches the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Envoy.Config.Rbac.V2.Policy> Policies {
      get { return policies_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RBAC);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RBAC other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Action != other.Action) return false;
      if (!Policies.Equals(other.Policies)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Action != global::Envoy.Config.Rbac.V2.RBAC.Types.Action.Allow) hash ^= Action.GetHashCode();
      hash ^= Policies.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Action != global::Envoy.Config.Rbac.V2.RBAC.Types.Action.Allow) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Action);
      }
      policies_.WriteTo(output, _map_policies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Action != global::Envoy.Config.Rbac.V2.RBAC.Types.Action.Allow) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Action);
      }
      policies_.WriteTo(ref output, _map_policies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Action != global::Envoy.Config.Rbac.V2.RBAC.Types.Action.Allow) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Action);
      }
      size += policies_.CalculateSize(_map_policies_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RBAC other) {
      if (other == null) {
        return;
      }
      if (other.Action != global::Envoy.Config.Rbac.V2.RBAC.Types.Action.Allow) {
        Action = other.Action;
      }
      policies_.Add(other.policies_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Action = (global::Envoy.Config.Rbac.V2.RBAC.Types.Action) input.ReadEnum();
            break;
          }
          case 18: {
            policies_.AddEntriesFrom(input, _map_policies_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Action = (global::Envoy.Config.Rbac.V2.RBAC.Types.Action) input.ReadEnum();
            break;
          }
          case 18: {
            policies_.AddEntriesFrom(ref input, _map_policies_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the RBAC message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Should we do safe-list or block-list style access control?
      /// </summary>
      public enum Action {
        /// <summary>
        /// The policies grant access to principals. The rest is denied. This is safe-list style
        /// access control. This is the default type.
        /// </summary>
        [pbr::OriginalName("ALLOW")] Allow = 0,
        /// <summary>
        /// The policies deny access to principals. The rest is allowed. This is block-list style
        /// access control.
        /// </summary>
        [pbr::OriginalName("DENY")] Deny = 1,
      }

    }
    #endregion

  }

  /// <summary>
  /// Policy specifies a role and the principals that are assigned/denied the role. A policy matches if
  /// and only if at least one of its permissions match the action taking place AND at least one of its
  /// principals match the downstream AND the condition is true if specified.
  /// </summary>
  public sealed partial class Policy : pb::IMessage<Policy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Policy> _parser = new pb::MessageParser<Policy>(() => new Policy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Policy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V2.RbacReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Policy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Policy(Policy other) : this() {
      permissions_ = other.permissions_.Clone();
      principals_ = other.principals_.Clone();
      condition_ = other.condition_ != null ? other.condition_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Policy Clone() {
      return new Policy(this);
    }

    /// <summary>Field number for the "permissions" field.</summary>
    public const int PermissionsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V2.Permission> _repeated_permissions_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Rbac.V2.Permission.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Permission> permissions_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Permission>();
    /// <summary>
    /// Required. The set of permissions that define a role. Each permission is matched with OR
    /// semantics. To match all actions for this policy, a single Permission with the `any` field set
    /// to true should be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Permission> Permissions {
      get { return permissions_; }
    }

    /// <summary>Field number for the "principals" field.</summary>
    public const int PrincipalsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V2.Principal> _repeated_principals_codec
        = pb::FieldCodec.ForMessage(18, global::Envoy.Config.Rbac.V2.Principal.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Principal> principals_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Principal>();
    /// <summary>
    /// Required. The set of principals that are assigned/denied the role based on “action”. Each
    /// principal is matched with OR semantics. To match all downstreams for this policy, a single
    /// Principal with the `any` field set to true should be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Principal> Principals {
      get { return principals_; }
    }

    /// <summary>Field number for the "condition" field.</summary>
    public const int ConditionFieldNumber = 3;
    private global::Google.Api.Expr.V1Alpha1.Expr condition_;
    /// <summary>
    /// An optional symbolic expression specifying an access control
    /// :ref:`condition &lt;arch_overview_condition>`. The condition is combined
    /// with the permissions and the principals as a clause with AND semantics.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Api.Expr.V1Alpha1.Expr Condition {
      get { return condition_; }
      set {
        condition_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Policy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Policy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!permissions_.Equals(other.permissions_)) return false;
      if(!principals_.Equals(other.principals_)) return false;
      if (!object.Equals(Condition, other.Condition)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= permissions_.GetHashCode();
      hash ^= principals_.GetHashCode();
      if (condition_ != null) hash ^= Condition.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      permissions_.WriteTo(output, _repeated_permissions_codec);
      principals_.WriteTo(output, _repeated_principals_codec);
      if (condition_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Condition);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      permissions_.WriteTo(ref output, _repeated_permissions_codec);
      principals_.WriteTo(ref output, _repeated_principals_codec);
      if (condition_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Condition);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += permissions_.CalculateSize(_repeated_permissions_codec);
      size += principals_.CalculateSize(_repeated_principals_codec);
      if (condition_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Condition);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Policy other) {
      if (other == null) {
        return;
      }
      permissions_.Add(other.permissions_);
      principals_.Add(other.principals_);
      if (other.condition_ != null) {
        if (condition_ == null) {
          Condition = new global::Google.Api.Expr.V1Alpha1.Expr();
        }
        Condition.MergeFrom(other.Condition);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            permissions_.AddEntriesFrom(input, _repeated_permissions_codec);
            break;
          }
          case 18: {
            principals_.AddEntriesFrom(input, _repeated_principals_codec);
            break;
          }
          case 26: {
            if (condition_ == null) {
              Condition = new global::Google.Api.Expr.V1Alpha1.Expr();
            }
            input.ReadMessage(Condition);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            permissions_.AddEntriesFrom(ref input, _repeated_permissions_codec);
            break;
          }
          case 18: {
            principals_.AddEntriesFrom(ref input, _repeated_principals_codec);
            break;
          }
          case 26: {
            if (condition_ == null) {
              Condition = new global::Google.Api.Expr.V1Alpha1.Expr();
            }
            input.ReadMessage(Condition);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Permission defines an action (or actions) that a principal can take.
  /// [#next-free-field: 11]
  /// </summary>
  public sealed partial class Permission : pb::IMessage<Permission>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Permission> _parser = new pb::MessageParser<Permission>(() => new Permission());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Permission> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V2.RbacReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Permission() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Permission(Permission other) : this() {
      switch (other.RuleCase) {
        case RuleOneofCase.AndRules:
          AndRules = other.AndRules.Clone();
          break;
        case RuleOneofCase.OrRules:
          OrRules = other.OrRules.Clone();
          break;
        case RuleOneofCase.Any:
          Any = other.Any;
          break;
        case RuleOneofCase.Header:
          Header = other.Header.Clone();
          break;
        case RuleOneofCase.UrlPath:
          UrlPath = other.UrlPath.Clone();
          break;
        case RuleOneofCase.DestinationIp:
          DestinationIp = other.DestinationIp.Clone();
          break;
        case RuleOneofCase.DestinationPort:
          DestinationPort = other.DestinationPort;
          break;
        case RuleOneofCase.Metadata:
          Metadata = other.Metadata.Clone();
          break;
        case RuleOneofCase.NotRule:
          NotRule = other.NotRule.Clone();
          break;
        case RuleOneofCase.RequestedServerName:
          RequestedServerName = other.RequestedServerName.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Permission Clone() {
      return new Permission(this);
    }

    /// <summary>Field number for the "and_rules" field.</summary>
    public const int AndRulesFieldNumber = 1;
    /// <summary>
    /// A set of rules that all must match in order to define the action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V2.Permission.Types.Set AndRules {
      get { return ruleCase_ == RuleOneofCase.AndRules ? (global::Envoy.Config.Rbac.V2.Permission.Types.Set) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.AndRules;
      }
    }

    /// <summary>Field number for the "or_rules" field.</summary>
    public const int OrRulesFieldNumber = 2;
    /// <summary>
    /// A set of rules where at least one must match in order to define the action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V2.Permission.Types.Set OrRules {
      get { return ruleCase_ == RuleOneofCase.OrRules ? (global::Envoy.Config.Rbac.V2.Permission.Types.Set) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.OrRules;
      }
    }

    /// <summary>Field number for the "any" field.</summary>
    public const int AnyFieldNumber = 3;
    /// <summary>
    /// When any is set, it matches any action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Any {
      get { return ruleCase_ == RuleOneofCase.Any ? (bool) rule_ : false; }
      set {
        rule_ = value;
        ruleCase_ = RuleOneofCase.Any;
      }
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 4;
    /// <summary>
    /// A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
    /// available for HTTP request.
    /// Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
    /// field if you want to match the URL path without the query and fragment string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Route.HeaderMatcher Header {
      get { return ruleCase_ == RuleOneofCase.Header ? (global::Envoy.Api.V2.Route.HeaderMatcher) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.Header;
      }
    }

    /// <summary>Field number for the "url_path" field.</summary>
    public const int UrlPathFieldNumber = 10;
    /// <summary>
    /// A URL path on the incoming HTTP request. Only available for HTTP.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.PathMatcher UrlPath {
      get { return ruleCase_ == RuleOneofCase.UrlPath ? (global::Envoy.Type.Matcher.PathMatcher) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.UrlPath;
      }
    }

    /// <summary>Field number for the "destination_ip" field.</summary>
    public const int DestinationIpFieldNumber = 5;
    /// <summary>
    /// A CIDR block that describes the destination IP.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.CidrRange DestinationIp {
      get { return ruleCase_ == RuleOneofCase.DestinationIp ? (global::Envoy.Api.V2.Core.CidrRange) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.DestinationIp;
      }
    }

    /// <summary>Field number for the "destination_port" field.</summary>
    public const int DestinationPortFieldNumber = 6;
    /// <summary>
    /// A port number that describes the destination port connecting to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint DestinationPort {
      get { return ruleCase_ == RuleOneofCase.DestinationPort ? (uint) rule_ : 0; }
      set {
        rule_ = value;
        ruleCase_ = RuleOneofCase.DestinationPort;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 7;
    /// <summary>
    /// Metadata that describes additional information about the action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.MetadataMatcher Metadata {
      get { return ruleCase_ == RuleOneofCase.Metadata ? (global::Envoy.Type.Matcher.MetadataMatcher) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.Metadata;
      }
    }

    /// <summary>Field number for the "not_rule" field.</summary>
    public const int NotRuleFieldNumber = 8;
    /// <summary>
    /// Negates matching the provided permission. For instance, if the value of `not_rule` would
    /// match, this permission would not match. Conversely, if the value of `not_rule` would not
    /// match, this permission would match.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V2.Permission NotRule {
      get { return ruleCase_ == RuleOneofCase.NotRule ? (global::Envoy.Config.Rbac.V2.Permission) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.NotRule;
      }
    }

    /// <summary>Field number for the "requested_server_name" field.</summary>
    public const int RequestedServerNameFieldNumber = 9;
    /// <summary>
    /// The request server from the client's connection request. This is
    /// typically TLS SNI.
    ///
    /// .. attention::
    ///
    ///   The behavior of this field may be affected by how Envoy is configured
    ///   as explained below.
    ///
    ///   * If the :ref:`TLS Inspector &lt;config_listener_filters_tls_inspector>`
    ///     filter is not added, and if a `FilterChainMatch` is not defined for
    ///     the :ref:`server name &lt;envoy_api_field_listener.FilterChainMatch.server_names>`,
    ///     a TLS connection's requested SNI server name will be treated as if it
    ///     wasn't present.
    ///
    ///   * A :ref:`listener filter &lt;arch_overview_listener_filters>` may
    ///     overwrite a connection's requested server name within Envoy.
    ///
    /// Please refer to :ref:`this FAQ entry &lt;faq_how_to_setup_sni>` to learn to
    /// setup SNI.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.StringMatcher RequestedServerName {
      get { return ruleCase_ == RuleOneofCase.RequestedServerName ? (global::Envoy.Type.Matcher.StringMatcher) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.RequestedServerName;
      }
    }

    private object rule_;
    /// <summary>Enum of possible cases for the "rule" oneof.</summary>
    public enum RuleOneofCase {
      None = 0,
      AndRules = 1,
      OrRules = 2,
      Any = 3,
      Header = 4,
      UrlPath = 10,
      DestinationIp = 5,
      DestinationPort = 6,
      Metadata = 7,
      NotRule = 8,
      RequestedServerName = 9,
    }
    private RuleOneofCase ruleCase_ = RuleOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RuleOneofCase RuleCase {
      get { return ruleCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRule() {
      ruleCase_ = RuleOneofCase.None;
      rule_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Permission);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Permission other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AndRules, other.AndRules)) return false;
      if (!object.Equals(OrRules, other.OrRules)) return false;
      if (Any != other.Any) return false;
      if (!object.Equals(Header, other.Header)) return false;
      if (!object.Equals(UrlPath, other.UrlPath)) return false;
      if (!object.Equals(DestinationIp, other.DestinationIp)) return false;
      if (DestinationPort != other.DestinationPort) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(NotRule, other.NotRule)) return false;
      if (!object.Equals(RequestedServerName, other.RequestedServerName)) return false;
      if (RuleCase != other.RuleCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ruleCase_ == RuleOneofCase.AndRules) hash ^= AndRules.GetHashCode();
      if (ruleCase_ == RuleOneofCase.OrRules) hash ^= OrRules.GetHashCode();
      if (ruleCase_ == RuleOneofCase.Any) hash ^= Any.GetHashCode();
      if (ruleCase_ == RuleOneofCase.Header) hash ^= Header.GetHashCode();
      if (ruleCase_ == RuleOneofCase.UrlPath) hash ^= UrlPath.GetHashCode();
      if (ruleCase_ == RuleOneofCase.DestinationIp) hash ^= DestinationIp.GetHashCode();
      if (ruleCase_ == RuleOneofCase.DestinationPort) hash ^= DestinationPort.GetHashCode();
      if (ruleCase_ == RuleOneofCase.Metadata) hash ^= Metadata.GetHashCode();
      if (ruleCase_ == RuleOneofCase.NotRule) hash ^= NotRule.GetHashCode();
      if (ruleCase_ == RuleOneofCase.RequestedServerName) hash ^= RequestedServerName.GetHashCode();
      hash ^= (int) ruleCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ruleCase_ == RuleOneofCase.AndRules) {
        output.WriteRawTag(10);
        output.WriteMessage(AndRules);
      }
      if (ruleCase_ == RuleOneofCase.OrRules) {
        output.WriteRawTag(18);
        output.WriteMessage(OrRules);
      }
      if (ruleCase_ == RuleOneofCase.Any) {
        output.WriteRawTag(24);
        output.WriteBool(Any);
      }
      if (ruleCase_ == RuleOneofCase.Header) {
        output.WriteRawTag(34);
        output.WriteMessage(Header);
      }
      if (ruleCase_ == RuleOneofCase.DestinationIp) {
        output.WriteRawTag(42);
        output.WriteMessage(DestinationIp);
      }
      if (ruleCase_ == RuleOneofCase.DestinationPort) {
        output.WriteRawTag(48);
        output.WriteUInt32(DestinationPort);
      }
      if (ruleCase_ == RuleOneofCase.Metadata) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (ruleCase_ == RuleOneofCase.NotRule) {
        output.WriteRawTag(66);
        output.WriteMessage(NotRule);
      }
      if (ruleCase_ == RuleOneofCase.RequestedServerName) {
        output.WriteRawTag(74);
        output.WriteMessage(RequestedServerName);
      }
      if (ruleCase_ == RuleOneofCase.UrlPath) {
        output.WriteRawTag(82);
        output.WriteMessage(UrlPath);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ruleCase_ == RuleOneofCase.AndRules) {
        output.WriteRawTag(10);
        output.WriteMessage(AndRules);
      }
      if (ruleCase_ == RuleOneofCase.OrRules) {
        output.WriteRawTag(18);
        output.WriteMessage(OrRules);
      }
      if (ruleCase_ == RuleOneofCase.Any) {
        output.WriteRawTag(24);
        output.WriteBool(Any);
      }
      if (ruleCase_ == RuleOneofCase.Header) {
        output.WriteRawTag(34);
        output.WriteMessage(Header);
      }
      if (ruleCase_ == RuleOneofCase.DestinationIp) {
        output.WriteRawTag(42);
        output.WriteMessage(DestinationIp);
      }
      if (ruleCase_ == RuleOneofCase.DestinationPort) {
        output.WriteRawTag(48);
        output.WriteUInt32(DestinationPort);
      }
      if (ruleCase_ == RuleOneofCase.Metadata) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (ruleCase_ == RuleOneofCase.NotRule) {
        output.WriteRawTag(66);
        output.WriteMessage(NotRule);
      }
      if (ruleCase_ == RuleOneofCase.RequestedServerName) {
        output.WriteRawTag(74);
        output.WriteMessage(RequestedServerName);
      }
      if (ruleCase_ == RuleOneofCase.UrlPath) {
        output.WriteRawTag(82);
        output.WriteMessage(UrlPath);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ruleCase_ == RuleOneofCase.AndRules) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AndRules);
      }
      if (ruleCase_ == RuleOneofCase.OrRules) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OrRules);
      }
      if (ruleCase_ == RuleOneofCase.Any) {
        size += 1 + 1;
      }
      if (ruleCase_ == RuleOneofCase.Header) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (ruleCase_ == RuleOneofCase.UrlPath) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UrlPath);
      }
      if (ruleCase_ == RuleOneofCase.DestinationIp) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DestinationIp);
      }
      if (ruleCase_ == RuleOneofCase.DestinationPort) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DestinationPort);
      }
      if (ruleCase_ == RuleOneofCase.Metadata) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (ruleCase_ == RuleOneofCase.NotRule) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NotRule);
      }
      if (ruleCase_ == RuleOneofCase.RequestedServerName) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequestedServerName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Permission other) {
      if (other == null) {
        return;
      }
      switch (other.RuleCase) {
        case RuleOneofCase.AndRules:
          if (AndRules == null) {
            AndRules = new global::Envoy.Config.Rbac.V2.Permission.Types.Set();
          }
          AndRules.MergeFrom(other.AndRules);
          break;
        case RuleOneofCase.OrRules:
          if (OrRules == null) {
            OrRules = new global::Envoy.Config.Rbac.V2.Permission.Types.Set();
          }
          OrRules.MergeFrom(other.OrRules);
          break;
        case RuleOneofCase.Any:
          Any = other.Any;
          break;
        case RuleOneofCase.Header:
          if (Header == null) {
            Header = new global::Envoy.Api.V2.Route.HeaderMatcher();
          }
          Header.MergeFrom(other.Header);
          break;
        case RuleOneofCase.UrlPath:
          if (UrlPath == null) {
            UrlPath = new global::Envoy.Type.Matcher.PathMatcher();
          }
          UrlPath.MergeFrom(other.UrlPath);
          break;
        case RuleOneofCase.DestinationIp:
          if (DestinationIp == null) {
            DestinationIp = new global::Envoy.Api.V2.Core.CidrRange();
          }
          DestinationIp.MergeFrom(other.DestinationIp);
          break;
        case RuleOneofCase.DestinationPort:
          DestinationPort = other.DestinationPort;
          break;
        case RuleOneofCase.Metadata:
          if (Metadata == null) {
            Metadata = new global::Envoy.Type.Matcher.MetadataMatcher();
          }
          Metadata.MergeFrom(other.Metadata);
          break;
        case RuleOneofCase.NotRule:
          if (NotRule == null) {
            NotRule = new global::Envoy.Config.Rbac.V2.Permission();
          }
          NotRule.MergeFrom(other.NotRule);
          break;
        case RuleOneofCase.RequestedServerName:
          if (RequestedServerName == null) {
            RequestedServerName = new global::Envoy.Type.Matcher.StringMatcher();
          }
          RequestedServerName.MergeFrom(other.RequestedServerName);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Envoy.Config.Rbac.V2.Permission.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2.Permission.Types.Set();
            if (ruleCase_ == RuleOneofCase.AndRules) {
              subBuilder.MergeFrom(AndRules);
            }
            input.ReadMessage(subBuilder);
            AndRules = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Config.Rbac.V2.Permission.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2.Permission.Types.Set();
            if (ruleCase_ == RuleOneofCase.OrRules) {
              subBuilder.MergeFrom(OrRules);
            }
            input.ReadMessage(subBuilder);
            OrRules = subBuilder;
            break;
          }
          case 24: {
            Any = input.ReadBool();
            break;
          }
          case 34: {
            global::Envoy.Api.V2.Route.HeaderMatcher subBuilder = new global::Envoy.Api.V2.Route.HeaderMatcher();
            if (ruleCase_ == RuleOneofCase.Header) {
              subBuilder.MergeFrom(Header);
            }
            input.ReadMessage(subBuilder);
            Header = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Api.V2.Core.CidrRange subBuilder = new global::Envoy.Api.V2.Core.CidrRange();
            if (ruleCase_ == RuleOneofCase.DestinationIp) {
              subBuilder.MergeFrom(DestinationIp);
            }
            input.ReadMessage(subBuilder);
            DestinationIp = subBuilder;
            break;
          }
          case 48: {
            DestinationPort = input.ReadUInt32();
            break;
          }
          case 58: {
            global::Envoy.Type.Matcher.MetadataMatcher subBuilder = new global::Envoy.Type.Matcher.MetadataMatcher();
            if (ruleCase_ == RuleOneofCase.Metadata) {
              subBuilder.MergeFrom(Metadata);
            }
            input.ReadMessage(subBuilder);
            Metadata = subBuilder;
            break;
          }
          case 66: {
            global::Envoy.Config.Rbac.V2.Permission subBuilder = new global::Envoy.Config.Rbac.V2.Permission();
            if (ruleCase_ == RuleOneofCase.NotRule) {
              subBuilder.MergeFrom(NotRule);
            }
            input.ReadMessage(subBuilder);
            NotRule = subBuilder;
            break;
          }
          case 74: {
            global::Envoy.Type.Matcher.StringMatcher subBuilder = new global::Envoy.Type.Matcher.StringMatcher();
            if (ruleCase_ == RuleOneofCase.RequestedServerName) {
              subBuilder.MergeFrom(RequestedServerName);
            }
            input.ReadMessage(subBuilder);
            RequestedServerName = subBuilder;
            break;
          }
          case 82: {
            global::Envoy.Type.Matcher.PathMatcher subBuilder = new global::Envoy.Type.Matcher.PathMatcher();
            if (ruleCase_ == RuleOneofCase.UrlPath) {
              subBuilder.MergeFrom(UrlPath);
            }
            input.ReadMessage(subBuilder);
            UrlPath = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Envoy.Config.Rbac.V2.Permission.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2.Permission.Types.Set();
            if (ruleCase_ == RuleOneofCase.AndRules) {
              subBuilder.MergeFrom(AndRules);
            }
            input.ReadMessage(subBuilder);
            AndRules = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Config.Rbac.V2.Permission.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2.Permission.Types.Set();
            if (ruleCase_ == RuleOneofCase.OrRules) {
              subBuilder.MergeFrom(OrRules);
            }
            input.ReadMessage(subBuilder);
            OrRules = subBuilder;
            break;
          }
          case 24: {
            Any = input.ReadBool();
            break;
          }
          case 34: {
            global::Envoy.Api.V2.Route.HeaderMatcher subBuilder = new global::Envoy.Api.V2.Route.HeaderMatcher();
            if (ruleCase_ == RuleOneofCase.Header) {
              subBuilder.MergeFrom(Header);
            }
            input.ReadMessage(subBuilder);
            Header = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Api.V2.Core.CidrRange subBuilder = new global::Envoy.Api.V2.Core.CidrRange();
            if (ruleCase_ == RuleOneofCase.DestinationIp) {
              subBuilder.MergeFrom(DestinationIp);
            }
            input.ReadMessage(subBuilder);
            DestinationIp = subBuilder;
            break;
          }
          case 48: {
            DestinationPort = input.ReadUInt32();
            break;
          }
          case 58: {
            global::Envoy.Type.Matcher.MetadataMatcher subBuilder = new global::Envoy.Type.Matcher.MetadataMatcher();
            if (ruleCase_ == RuleOneofCase.Metadata) {
              subBuilder.MergeFrom(Metadata);
            }
            input.ReadMessage(subBuilder);
            Metadata = subBuilder;
            break;
          }
          case 66: {
            global::Envoy.Config.Rbac.V2.Permission subBuilder = new global::Envoy.Config.Rbac.V2.Permission();
            if (ruleCase_ == RuleOneofCase.NotRule) {
              subBuilder.MergeFrom(NotRule);
            }
            input.ReadMessage(subBuilder);
            NotRule = subBuilder;
            break;
          }
          case 74: {
            global::Envoy.Type.Matcher.StringMatcher subBuilder = new global::Envoy.Type.Matcher.StringMatcher();
            if (ruleCase_ == RuleOneofCase.RequestedServerName) {
              subBuilder.MergeFrom(RequestedServerName);
            }
            input.ReadMessage(subBuilder);
            RequestedServerName = subBuilder;
            break;
          }
          case 82: {
            global::Envoy.Type.Matcher.PathMatcher subBuilder = new global::Envoy.Type.Matcher.PathMatcher();
            if (ruleCase_ == RuleOneofCase.UrlPath) {
              subBuilder.MergeFrom(UrlPath);
            }
            input.ReadMessage(subBuilder);
            UrlPath = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Permission message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Used in the `and_rules` and `or_rules` fields in the `rule` oneof. Depending on the context,
      /// each are applied with the associated behavior.
      /// </summary>
      public sealed partial class Set : pb::IMessage<Set>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Set> _parser = new pb::MessageParser<Set>(() => new Set());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Set> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Rbac.V2.Permission.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Set() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Set(Set other) : this() {
          rules_ = other.rules_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Set Clone() {
          return new Set(this);
        }

        /// <summary>Field number for the "rules" field.</summary>
        public const int RulesFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V2.Permission> _repeated_rules_codec
            = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Rbac.V2.Permission.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Permission> rules_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Permission>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Permission> Rules {
          get { return rules_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Set);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Set other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!rules_.Equals(other.rules_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= rules_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          rules_.WriteTo(output, _repeated_rules_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          rules_.WriteTo(ref output, _repeated_rules_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          size += rules_.CalculateSize(_repeated_rules_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Set other) {
          if (other == null) {
            return;
          }
          rules_.Add(other.rules_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                rules_.AddEntriesFrom(input, _repeated_rules_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                rules_.AddEntriesFrom(ref input, _repeated_rules_codec);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Principal defines an identity or a group of identities for a downstream subject.
  /// [#next-free-field: 12]
  /// </summary>
  public sealed partial class Principal : pb::IMessage<Principal>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Principal> _parser = new pb::MessageParser<Principal>(() => new Principal());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Principal> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V2.RbacReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Principal() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Principal(Principal other) : this() {
      switch (other.IdentifierCase) {
        case IdentifierOneofCase.AndIds:
          AndIds = other.AndIds.Clone();
          break;
        case IdentifierOneofCase.OrIds:
          OrIds = other.OrIds.Clone();
          break;
        case IdentifierOneofCase.Any:
          Any = other.Any;
          break;
        case IdentifierOneofCase.Authenticated:
          Authenticated = other.Authenticated.Clone();
          break;
        case IdentifierOneofCase.SourceIp:
          SourceIp = other.SourceIp.Clone();
          break;
        case IdentifierOneofCase.DirectRemoteIp:
          DirectRemoteIp = other.DirectRemoteIp.Clone();
          break;
        case IdentifierOneofCase.RemoteIp:
          RemoteIp = other.RemoteIp.Clone();
          break;
        case IdentifierOneofCase.Header:
          Header = other.Header.Clone();
          break;
        case IdentifierOneofCase.UrlPath:
          UrlPath = other.UrlPath.Clone();
          break;
        case IdentifierOneofCase.Metadata:
          Metadata = other.Metadata.Clone();
          break;
        case IdentifierOneofCase.NotId:
          NotId = other.NotId.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Principal Clone() {
      return new Principal(this);
    }

    /// <summary>Field number for the "and_ids" field.</summary>
    public const int AndIdsFieldNumber = 1;
    /// <summary>
    /// A set of identifiers that all must match in order to define the downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V2.Principal.Types.Set AndIds {
      get { return identifierCase_ == IdentifierOneofCase.AndIds ? (global::Envoy.Config.Rbac.V2.Principal.Types.Set) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.AndIds;
      }
    }

    /// <summary>Field number for the "or_ids" field.</summary>
    public const int OrIdsFieldNumber = 2;
    /// <summary>
    /// A set of identifiers at least one must match in order to define the downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V2.Principal.Types.Set OrIds {
      get { return identifierCase_ == IdentifierOneofCase.OrIds ? (global::Envoy.Config.Rbac.V2.Principal.Types.Set) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.OrIds;
      }
    }

    /// <summary>Field number for the "any" field.</summary>
    public const int AnyFieldNumber = 3;
    /// <summary>
    /// When any is set, it matches any downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Any {
      get { return identifierCase_ == IdentifierOneofCase.Any ? (bool) identifier_ : false; }
      set {
        identifier_ = value;
        identifierCase_ = IdentifierOneofCase.Any;
      }
    }

    /// <summary>Field number for the "authenticated" field.</summary>
    public const int AuthenticatedFieldNumber = 4;
    /// <summary>
    /// Authenticated attributes that identify the downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated Authenticated {
      get { return identifierCase_ == IdentifierOneofCase.Authenticated ? (global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.Authenticated;
      }
    }

    /// <summary>Field number for the "source_ip" field.</summary>
    public const int SourceIpFieldNumber = 5;
    /// <summary>
    /// A CIDR block that describes the downstream IP.
    /// This address will honor proxy protocol, but will not honor XFF.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.CidrRange SourceIp {
      get { return identifierCase_ == IdentifierOneofCase.SourceIp ? (global::Envoy.Api.V2.Core.CidrRange) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.SourceIp;
      }
    }

    /// <summary>Field number for the "direct_remote_ip" field.</summary>
    public const int DirectRemoteIpFieldNumber = 10;
    /// <summary>
    /// A CIDR block that describes the downstream remote/origin address.
    /// Note: This is always the physical peer even if the
    /// :ref:`remote_ip &lt;envoy_api_field_config.rbac.v2.Principal.remote_ip>` is inferred
    /// from for example the x-forwarder-for header, proxy protocol, etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.CidrRange DirectRemoteIp {
      get { return identifierCase_ == IdentifierOneofCase.DirectRemoteIp ? (global::Envoy.Api.V2.Core.CidrRange) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.DirectRemoteIp;
      }
    }

    /// <summary>Field number for the "remote_ip" field.</summary>
    public const int RemoteIpFieldNumber = 11;
    /// <summary>
    /// A CIDR block that describes the downstream remote/origin address.
    /// Note: This may not be the physical peer and could be different from the
    /// :ref:`direct_remote_ip &lt;envoy_api_field_config.rbac.v2.Principal.direct_remote_ip>`.
    /// E.g, if the remote ip is inferred from for example the x-forwarder-for header,
    /// proxy protocol, etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Core.CidrRange RemoteIp {
      get { return identifierCase_ == IdentifierOneofCase.RemoteIp ? (global::Envoy.Api.V2.Core.CidrRange) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.RemoteIp;
      }
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 6;
    /// <summary>
    /// A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
    /// available for HTTP request.
    /// Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
    /// field if you want to match the URL path without the query and fragment string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Api.V2.Route.HeaderMatcher Header {
      get { return identifierCase_ == IdentifierOneofCase.Header ? (global::Envoy.Api.V2.Route.HeaderMatcher) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.Header;
      }
    }

    /// <summary>Field number for the "url_path" field.</summary>
    public const int UrlPathFieldNumber = 9;
    /// <summary>
    /// A URL path on the incoming HTTP request. Only available for HTTP.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.PathMatcher UrlPath {
      get { return identifierCase_ == IdentifierOneofCase.UrlPath ? (global::Envoy.Type.Matcher.PathMatcher) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.UrlPath;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 7;
    /// <summary>
    /// Metadata that describes additional information about the principal.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.MetadataMatcher Metadata {
      get { return identifierCase_ == IdentifierOneofCase.Metadata ? (global::Envoy.Type.Matcher.MetadataMatcher) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.Metadata;
      }
    }

    /// <summary>Field number for the "not_id" field.</summary>
    public const int NotIdFieldNumber = 8;
    /// <summary>
    /// Negates matching the provided principal. For instance, if the value of `not_id` would match,
    /// this principal would not match. Conversely, if the value of `not_id` would not match, this
    /// principal would match.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Rbac.V2.Principal NotId {
      get { return identifierCase_ == IdentifierOneofCase.NotId ? (global::Envoy.Config.Rbac.V2.Principal) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.NotId;
      }
    }

    private object identifier_;
    /// <summary>Enum of possible cases for the "identifier" oneof.</summary>
    public enum IdentifierOneofCase {
      None = 0,
      AndIds = 1,
      OrIds = 2,
      Any = 3,
      Authenticated = 4,
      SourceIp = 5,
      DirectRemoteIp = 10,
      RemoteIp = 11,
      Header = 6,
      UrlPath = 9,
      Metadata = 7,
      NotId = 8,
    }
    private IdentifierOneofCase identifierCase_ = IdentifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IdentifierOneofCase IdentifierCase {
      get { return identifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIdentifier() {
      identifierCase_ = IdentifierOneofCase.None;
      identifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Principal);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Principal other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AndIds, other.AndIds)) return false;
      if (!object.Equals(OrIds, other.OrIds)) return false;
      if (Any != other.Any) return false;
      if (!object.Equals(Authenticated, other.Authenticated)) return false;
      if (!object.Equals(SourceIp, other.SourceIp)) return false;
      if (!object.Equals(DirectRemoteIp, other.DirectRemoteIp)) return false;
      if (!object.Equals(RemoteIp, other.RemoteIp)) return false;
      if (!object.Equals(Header, other.Header)) return false;
      if (!object.Equals(UrlPath, other.UrlPath)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(NotId, other.NotId)) return false;
      if (IdentifierCase != other.IdentifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (identifierCase_ == IdentifierOneofCase.AndIds) hash ^= AndIds.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.OrIds) hash ^= OrIds.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Any) hash ^= Any.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Authenticated) hash ^= Authenticated.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.SourceIp) hash ^= SourceIp.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.DirectRemoteIp) hash ^= DirectRemoteIp.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.RemoteIp) hash ^= RemoteIp.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Header) hash ^= Header.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.UrlPath) hash ^= UrlPath.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Metadata) hash ^= Metadata.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.NotId) hash ^= NotId.GetHashCode();
      hash ^= (int) identifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (identifierCase_ == IdentifierOneofCase.AndIds) {
        output.WriteRawTag(10);
        output.WriteMessage(AndIds);
      }
      if (identifierCase_ == IdentifierOneofCase.OrIds) {
        output.WriteRawTag(18);
        output.WriteMessage(OrIds);
      }
      if (identifierCase_ == IdentifierOneofCase.Any) {
        output.WriteRawTag(24);
        output.WriteBool(Any);
      }
      if (identifierCase_ == IdentifierOneofCase.Authenticated) {
        output.WriteRawTag(34);
        output.WriteMessage(Authenticated);
      }
      if (identifierCase_ == IdentifierOneofCase.SourceIp) {
        output.WriteRawTag(42);
        output.WriteMessage(SourceIp);
      }
      if (identifierCase_ == IdentifierOneofCase.Header) {
        output.WriteRawTag(50);
        output.WriteMessage(Header);
      }
      if (identifierCase_ == IdentifierOneofCase.Metadata) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (identifierCase_ == IdentifierOneofCase.NotId) {
        output.WriteRawTag(66);
        output.WriteMessage(NotId);
      }
      if (identifierCase_ == IdentifierOneofCase.UrlPath) {
        output.WriteRawTag(74);
        output.WriteMessage(UrlPath);
      }
      if (identifierCase_ == IdentifierOneofCase.DirectRemoteIp) {
        output.WriteRawTag(82);
        output.WriteMessage(DirectRemoteIp);
      }
      if (identifierCase_ == IdentifierOneofCase.RemoteIp) {
        output.WriteRawTag(90);
        output.WriteMessage(RemoteIp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (identifierCase_ == IdentifierOneofCase.AndIds) {
        output.WriteRawTag(10);
        output.WriteMessage(AndIds);
      }
      if (identifierCase_ == IdentifierOneofCase.OrIds) {
        output.WriteRawTag(18);
        output.WriteMessage(OrIds);
      }
      if (identifierCase_ == IdentifierOneofCase.Any) {
        output.WriteRawTag(24);
        output.WriteBool(Any);
      }
      if (identifierCase_ == IdentifierOneofCase.Authenticated) {
        output.WriteRawTag(34);
        output.WriteMessage(Authenticated);
      }
      if (identifierCase_ == IdentifierOneofCase.SourceIp) {
        output.WriteRawTag(42);
        output.WriteMessage(SourceIp);
      }
      if (identifierCase_ == IdentifierOneofCase.Header) {
        output.WriteRawTag(50);
        output.WriteMessage(Header);
      }
      if (identifierCase_ == IdentifierOneofCase.Metadata) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (identifierCase_ == IdentifierOneofCase.NotId) {
        output.WriteRawTag(66);
        output.WriteMessage(NotId);
      }
      if (identifierCase_ == IdentifierOneofCase.UrlPath) {
        output.WriteRawTag(74);
        output.WriteMessage(UrlPath);
      }
      if (identifierCase_ == IdentifierOneofCase.DirectRemoteIp) {
        output.WriteRawTag(82);
        output.WriteMessage(DirectRemoteIp);
      }
      if (identifierCase_ == IdentifierOneofCase.RemoteIp) {
        output.WriteRawTag(90);
        output.WriteMessage(RemoteIp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (identifierCase_ == IdentifierOneofCase.AndIds) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AndIds);
      }
      if (identifierCase_ == IdentifierOneofCase.OrIds) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OrIds);
      }
      if (identifierCase_ == IdentifierOneofCase.Any) {
        size += 1 + 1;
      }
      if (identifierCase_ == IdentifierOneofCase.Authenticated) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Authenticated);
      }
      if (identifierCase_ == IdentifierOneofCase.SourceIp) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceIp);
      }
      if (identifierCase_ == IdentifierOneofCase.DirectRemoteIp) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DirectRemoteIp);
      }
      if (identifierCase_ == IdentifierOneofCase.RemoteIp) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RemoteIp);
      }
      if (identifierCase_ == IdentifierOneofCase.Header) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (identifierCase_ == IdentifierOneofCase.UrlPath) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UrlPath);
      }
      if (identifierCase_ == IdentifierOneofCase.Metadata) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (identifierCase_ == IdentifierOneofCase.NotId) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NotId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Principal other) {
      if (other == null) {
        return;
      }
      switch (other.IdentifierCase) {
        case IdentifierOneofCase.AndIds:
          if (AndIds == null) {
            AndIds = new global::Envoy.Config.Rbac.V2.Principal.Types.Set();
          }
          AndIds.MergeFrom(other.AndIds);
          break;
        case IdentifierOneofCase.OrIds:
          if (OrIds == null) {
            OrIds = new global::Envoy.Config.Rbac.V2.Principal.Types.Set();
          }
          OrIds.MergeFrom(other.OrIds);
          break;
        case IdentifierOneofCase.Any:
          Any = other.Any;
          break;
        case IdentifierOneofCase.Authenticated:
          if (Authenticated == null) {
            Authenticated = new global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated();
          }
          Authenticated.MergeFrom(other.Authenticated);
          break;
        case IdentifierOneofCase.SourceIp:
          if (SourceIp == null) {
            SourceIp = new global::Envoy.Api.V2.Core.CidrRange();
          }
          SourceIp.MergeFrom(other.SourceIp);
          break;
        case IdentifierOneofCase.DirectRemoteIp:
          if (DirectRemoteIp == null) {
            DirectRemoteIp = new global::Envoy.Api.V2.Core.CidrRange();
          }
          DirectRemoteIp.MergeFrom(other.DirectRemoteIp);
          break;
        case IdentifierOneofCase.RemoteIp:
          if (RemoteIp == null) {
            RemoteIp = new global::Envoy.Api.V2.Core.CidrRange();
          }
          RemoteIp.MergeFrom(other.RemoteIp);
          break;
        case IdentifierOneofCase.Header:
          if (Header == null) {
            Header = new global::Envoy.Api.V2.Route.HeaderMatcher();
          }
          Header.MergeFrom(other.Header);
          break;
        case IdentifierOneofCase.UrlPath:
          if (UrlPath == null) {
            UrlPath = new global::Envoy.Type.Matcher.PathMatcher();
          }
          UrlPath.MergeFrom(other.UrlPath);
          break;
        case IdentifierOneofCase.Metadata:
          if (Metadata == null) {
            Metadata = new global::Envoy.Type.Matcher.MetadataMatcher();
          }
          Metadata.MergeFrom(other.Metadata);
          break;
        case IdentifierOneofCase.NotId:
          if (NotId == null) {
            NotId = new global::Envoy.Config.Rbac.V2.Principal();
          }
          NotId.MergeFrom(other.NotId);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Envoy.Config.Rbac.V2.Principal.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2.Principal.Types.Set();
            if (identifierCase_ == IdentifierOneofCase.AndIds) {
              subBuilder.MergeFrom(AndIds);
            }
            input.ReadMessage(subBuilder);
            AndIds = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Config.Rbac.V2.Principal.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2.Principal.Types.Set();
            if (identifierCase_ == IdentifierOneofCase.OrIds) {
              subBuilder.MergeFrom(OrIds);
            }
            input.ReadMessage(subBuilder);
            OrIds = subBuilder;
            break;
          }
          case 24: {
            Any = input.ReadBool();
            break;
          }
          case 34: {
            global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated subBuilder = new global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated();
            if (identifierCase_ == IdentifierOneofCase.Authenticated) {
              subBuilder.MergeFrom(Authenticated);
            }
            input.ReadMessage(subBuilder);
            Authenticated = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Api.V2.Core.CidrRange subBuilder = new global::Envoy.Api.V2.Core.CidrRange();
            if (identifierCase_ == IdentifierOneofCase.SourceIp) {
              subBuilder.MergeFrom(SourceIp);
            }
            input.ReadMessage(subBuilder);
            SourceIp = subBuilder;
            break;
          }
          case 50: {
            global::Envoy.Api.V2.Route.HeaderMatcher subBuilder = new global::Envoy.Api.V2.Route.HeaderMatcher();
            if (identifierCase_ == IdentifierOneofCase.Header) {
              subBuilder.MergeFrom(Header);
            }
            input.ReadMessage(subBuilder);
            Header = subBuilder;
            break;
          }
          case 58: {
            global::Envoy.Type.Matcher.MetadataMatcher subBuilder = new global::Envoy.Type.Matcher.MetadataMatcher();
            if (identifierCase_ == IdentifierOneofCase.Metadata) {
              subBuilder.MergeFrom(Metadata);
            }
            input.ReadMessage(subBuilder);
            Metadata = subBuilder;
            break;
          }
          case 66: {
            global::Envoy.Config.Rbac.V2.Principal subBuilder = new global::Envoy.Config.Rbac.V2.Principal();
            if (identifierCase_ == IdentifierOneofCase.NotId) {
              subBuilder.MergeFrom(NotId);
            }
            input.ReadMessage(subBuilder);
            NotId = subBuilder;
            break;
          }
          case 74: {
            global::Envoy.Type.Matcher.PathMatcher subBuilder = new global::Envoy.Type.Matcher.PathMatcher();
            if (identifierCase_ == IdentifierOneofCase.UrlPath) {
              subBuilder.MergeFrom(UrlPath);
            }
            input.ReadMessage(subBuilder);
            UrlPath = subBuilder;
            break;
          }
          case 82: {
            global::Envoy.Api.V2.Core.CidrRange subBuilder = new global::Envoy.Api.V2.Core.CidrRange();
            if (identifierCase_ == IdentifierOneofCase.DirectRemoteIp) {
              subBuilder.MergeFrom(DirectRemoteIp);
            }
            input.ReadMessage(subBuilder);
            DirectRemoteIp = subBuilder;
            break;
          }
          case 90: {
            global::Envoy.Api.V2.Core.CidrRange subBuilder = new global::Envoy.Api.V2.Core.CidrRange();
            if (identifierCase_ == IdentifierOneofCase.RemoteIp) {
              subBuilder.MergeFrom(RemoteIp);
            }
            input.ReadMessage(subBuilder);
            RemoteIp = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Envoy.Config.Rbac.V2.Principal.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2.Principal.Types.Set();
            if (identifierCase_ == IdentifierOneofCase.AndIds) {
              subBuilder.MergeFrom(AndIds);
            }
            input.ReadMessage(subBuilder);
            AndIds = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Config.Rbac.V2.Principal.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2.Principal.Types.Set();
            if (identifierCase_ == IdentifierOneofCase.OrIds) {
              subBuilder.MergeFrom(OrIds);
            }
            input.ReadMessage(subBuilder);
            OrIds = subBuilder;
            break;
          }
          case 24: {
            Any = input.ReadBool();
            break;
          }
          case 34: {
            global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated subBuilder = new global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated();
            if (identifierCase_ == IdentifierOneofCase.Authenticated) {
              subBuilder.MergeFrom(Authenticated);
            }
            input.ReadMessage(subBuilder);
            Authenticated = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Api.V2.Core.CidrRange subBuilder = new global::Envoy.Api.V2.Core.CidrRange();
            if (identifierCase_ == IdentifierOneofCase.SourceIp) {
              subBuilder.MergeFrom(SourceIp);
            }
            input.ReadMessage(subBuilder);
            SourceIp = subBuilder;
            break;
          }
          case 50: {
            global::Envoy.Api.V2.Route.HeaderMatcher subBuilder = new global::Envoy.Api.V2.Route.HeaderMatcher();
            if (identifierCase_ == IdentifierOneofCase.Header) {
              subBuilder.MergeFrom(Header);
            }
            input.ReadMessage(subBuilder);
            Header = subBuilder;
            break;
          }
          case 58: {
            global::Envoy.Type.Matcher.MetadataMatcher subBuilder = new global::Envoy.Type.Matcher.MetadataMatcher();
            if (identifierCase_ == IdentifierOneofCase.Metadata) {
              subBuilder.MergeFrom(Metadata);
            }
            input.ReadMessage(subBuilder);
            Metadata = subBuilder;
            break;
          }
          case 66: {
            global::Envoy.Config.Rbac.V2.Principal subBuilder = new global::Envoy.Config.Rbac.V2.Principal();
            if (identifierCase_ == IdentifierOneofCase.NotId) {
              subBuilder.MergeFrom(NotId);
            }
            input.ReadMessage(subBuilder);
            NotId = subBuilder;
            break;
          }
          case 74: {
            global::Envoy.Type.Matcher.PathMatcher subBuilder = new global::Envoy.Type.Matcher.PathMatcher();
            if (identifierCase_ == IdentifierOneofCase.UrlPath) {
              subBuilder.MergeFrom(UrlPath);
            }
            input.ReadMessage(subBuilder);
            UrlPath = subBuilder;
            break;
          }
          case 82: {
            global::Envoy.Api.V2.Core.CidrRange subBuilder = new global::Envoy.Api.V2.Core.CidrRange();
            if (identifierCase_ == IdentifierOneofCase.DirectRemoteIp) {
              subBuilder.MergeFrom(DirectRemoteIp);
            }
            input.ReadMessage(subBuilder);
            DirectRemoteIp = subBuilder;
            break;
          }
          case 90: {
            global::Envoy.Api.V2.Core.CidrRange subBuilder = new global::Envoy.Api.V2.Core.CidrRange();
            if (identifierCase_ == IdentifierOneofCase.RemoteIp) {
              subBuilder.MergeFrom(RemoteIp);
            }
            input.ReadMessage(subBuilder);
            RemoteIp = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Principal message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Used in the `and_ids` and `or_ids` fields in the `identifier` oneof. Depending on the context,
      /// each are applied with the associated behavior.
      /// </summary>
      public sealed partial class Set : pb::IMessage<Set>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Set> _parser = new pb::MessageParser<Set>(() => new Set());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Set> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Rbac.V2.Principal.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Set() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Set(Set other) : this() {
          ids_ = other.ids_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Set Clone() {
          return new Set(this);
        }

        /// <summary>Field number for the "ids" field.</summary>
        public const int IdsFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V2.Principal> _repeated_ids_codec
            = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Rbac.V2.Principal.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Principal> ids_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Principal>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Principal> Ids {
          get { return ids_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Set);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Set other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!ids_.Equals(other.ids_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= ids_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          ids_.WriteTo(output, _repeated_ids_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          ids_.WriteTo(ref output, _repeated_ids_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          size += ids_.CalculateSize(_repeated_ids_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Set other) {
          if (other == null) {
            return;
          }
          ids_.Add(other.ids_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                ids_.AddEntriesFrom(input, _repeated_ids_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                ids_.AddEntriesFrom(ref input, _repeated_ids_codec);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Authentication attributes for a downstream.
      /// </summary>
      public sealed partial class Authenticated : pb::IMessage<Authenticated>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Authenticated> _parser = new pb::MessageParser<Authenticated>(() => new Authenticated());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Authenticated> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Rbac.V2.Principal.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Authenticated() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Authenticated(Authenticated other) : this() {
          principalName_ = other.principalName_ != null ? other.principalName_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Authenticated Clone() {
          return new Authenticated(this);
        }

        /// <summary>Field number for the "principal_name" field.</summary>
        public const int PrincipalNameFieldNumber = 2;
        private global::Envoy.Type.Matcher.StringMatcher principalName_;
        /// <summary>
        /// The name of the principal. If set, The URI SAN or DNS SAN in that order is used from the
        /// certificate, otherwise the subject field is used. If unset, it applies to any user that is
        /// authenticated.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Type.Matcher.StringMatcher PrincipalName {
          get { return principalName_; }
          set {
            principalName_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Authenticated);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Authenticated other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(PrincipalName, other.PrincipalName)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (principalName_ != null) hash ^= PrincipalName.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (principalName_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(PrincipalName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (principalName_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(PrincipalName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (principalName_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrincipalName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Authenticated other) {
          if (other == null) {
            return;
          }
          if (other.principalName_ != null) {
            if (principalName_ == null) {
              PrincipalName = new global::Envoy.Type.Matcher.StringMatcher();
            }
            PrincipalName.MergeFrom(other.PrincipalName);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 18: {
                if (principalName_ == null) {
                  PrincipalName = new global::Envoy.Type.Matcher.StringMatcher();
                }
                input.ReadMessage(PrincipalName);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 18: {
                if (principalName_ == null) {
                  PrincipalName = new global::Envoy.Type.Matcher.StringMatcher();
                }
                input.ReadMessage(PrincipalName);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
